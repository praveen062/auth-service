
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>server: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">auth-service/cmd/server/main.go (12.7%)</option>
				
				<option value="file1">auth-service/docs/docs.go (100.0%)</option>
				
				<option value="file2">auth-service/internal/actuator/actuator.go (98.9%)</option>
				
				<option value="file3">auth-service/internal/actuator/health_checks.go (89.3%)</option>
				
				<option value="file4">auth-service/internal/config/config.go (90.2%)</option>
				
				<option value="file5">auth-service/internal/handler/rest/auth_handler.go (94.1%)</option>
				
				<option value="file6">auth-service/internal/handler/rest/oauth_handler.go (94.8%)</option>
				
				<option value="file7">auth-service/internal/logger/logger.go (62.7%)</option>
				
				<option value="file8">auth-service/internal/middleware/actuator_middleware.go (100.0%)</option>
				
				<option value="file9">auth-service/internal/middleware/logging_middleware.go (0.0%)</option>
				
				<option value="file10">auth-service/internal/middleware/rbac_middleware.go (100.0%)</option>
				
				<option value="file11">auth-service/internal/tracing/tracing.go (89.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"
        "log"
        "net/http"
        "strings"

        "auth-service/internal/actuator"
        "auth-service/internal/config"
        rest "auth-service/internal/handler/rest"
        "auth-service/internal/logger"
        "auth-service/internal/middleware"

        "github.com/gin-gonic/gin"
        swaggerFiles "github.com/swaggo/files"
        ginSwagger "github.com/swaggo/gin-swagger"
        "go.uber.org/zap"

        // Swagger documentation
        _ "auth-service/docs"
)

// @title           Multi-Tenant OAuth Service API
// @version         1.0
// @description     A comprehensive OAuth 2.0 service with multi-tenancy, Google OAuth, and service-to-service authentication.
// @termsOfService  http://swagger.io/terms/

// @contact.name   API Support
// @contact.url    http://www.swagger.io/support
// @contact.email  support@swagger.io

// @license.name  MIT
// @license.url   https://opensource.org/licenses/MIT

// @host      localhost:8080
// @BasePath  /api/v1

// @securityDefinitions.apikey BearerAuth
// @in header
// @name Authorization
// @description Type "Bearer" followed by a space and JWT token.

// @securityDefinitions.oauth2.application OAuth2ClientCredentials
// @tokenUrl /api/v1/oauth/token
// @scope.read "Read access"
// @scope.write "Write access"
// @scope.admin "Admin access"

// @tag.name Authentication
// @tag.description Authentication and authorization endpoints

// @tag.name OAuth
// @tag.description OAuth 2.0 flow endpoints

// @tag.name Tenants
// @tag.description Multi-tenant management endpoints

// @tag.name RBAC
// @tag.description Role-based access control endpoints

// @tag.name Services
// @tag.description Service-to-service authentication endpoints

// ipAllowlistMiddleware allows only requests from allowed IPs
func ipAllowlistMiddleware(allowedIPs []string) gin.HandlerFunc <span class="cov8" title="24">{
        return func(c *gin.Context) </span><span class="cov8" title="32">{
                clientIP := c.ClientIP()
                for _, ip := range allowedIPs </span><span class="cov10" title="55">{
                        if strings.HasPrefix(clientIP, ip) </span><span class="cov7" title="16">{
                                c.Next()
                                return
                        }</span>
                }
                <span class="cov7" title="16">c.AbortWithStatusJSON(http.StatusForbidden, gin.H{"error": "forbidden: internal access only"})</span>
        }
}

func main() <span class="cov0" title="0">{
        // Load configuration
        cfg, err := config.LoadConfig("configs/config.yaml")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to load config: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Loaded config: %+v\n", cfg.Server)

        // Initialize logger
        appLogger, err := logger.NewLogger(&amp;cfg.Logging)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to initialize logger: %v", err)
        }</span>

        // Log application startup
        <span class="cov0" title="0">appLogger.Info("Application starting",
                zap.String("version", "1.0.0"),
                zap.String("environment", "development"),
                zap.Int("port", cfg.Server.Port),
        )

        // Create actuator
        appInfo := &amp;actuator.AppInfo{
                Name:        "auth-service",
                Version:     "1.0.0",
                Description: "Multi-Tenant OAuth Service",
                BuildTime:   "2024-01-01T00:00:00Z",
                GitCommit:   "development",
                Environment: "development",
                Properties: map[string]string{
                        "server.port":   fmt.Sprintf("%d", cfg.Server.Port),
                        "database.host": cfg.Database.Host,
                        "redis.host":    cfg.Redis.Host,
                },
        }

        act := actuator.NewActuator(appInfo)

        // Register health checks
        act.RegisterHealthCheck("memory", actuator.MemoryHealthCheck(90))
        act.RegisterHealthCheck("goroutines", actuator.GoroutineHealthCheck(1000))
        act.RegisterHealthCheck("disk", actuator.DiskSpaceHealthCheck(1))

        // Register readiness checks (these would be added when DB/Redis are connected)
        // act.RegisterReadinessCheck("database", actuator.DatabaseHealthCheck(db))
        // act.RegisterReadinessCheck("redis", actuator.RedisHealthCheck(redisClient))

        // Set up Gin
        gin.SetMode(gin.ReleaseMode)
        r := gin.New()
        r.Use(gin.Recovery())

        // Add logging middleware
        r.Use(middleware.LoggingMiddleware(appLogger))

        // Register actuator routes
        act.RegisterRoutes(r)

        // Add actuator middleware for metrics tracking
        r.Use(middleware.ActuatorMiddleware(act))

        // Register REST handlers
        authHandler := rest.NewAuthHandler(cfg)
        oauthHandler := rest.NewOAuthHandler(cfg)

        api := r.Group("/api/v1")
        </span><span class="cov0" title="0">{
                auth := api.Group("/auth")
                auth.POST("/login", authHandler.Login)
                auth.POST("/register", authHandler.Register)
                auth.POST("/refresh", authHandler.RefreshToken)
                auth.POST("/logout", authHandler.Logout)

                oauth := api.Group("/oauth")
                oauth.GET("/google/login", oauthHandler.GoogleLogin)
                oauth.GET("/google/callback", oauthHandler.GoogleCallback)
                oauth.POST("/token", oauthHandler.ClientCredentials)
                oauth.POST("/one-time", oauthHandler.CreateOneTimeToken)
                oauth.GET("/verify", oauthHandler.VerifyOneTimeToken)
                oauth.POST("/refresh", oauthHandler.RefreshSession)
        }</span>

        // Swagger UI - internal only (localhost)
        <span class="cov0" title="0">allowedIPs := []string{"127.0.0.1", "::1"}
        r.GET("/swagger/*any", ipAllowlistMiddleware(allowedIPs), ginSwagger.WrapHandler(swaggerFiles.Handler))

        // Start server
        addr := fmt.Sprintf("%s:%d", cfg.Server.Host, cfg.Server.Port)
        fmt.Printf("Starting server on %s\n", addr)
        fmt.Printf("Actuator endpoints available at:\n")
        fmt.Printf("  Health: http://%s/actuator/health\n", addr)
        fmt.Printf("  Metrics: http://%s/actuator/metrics\n", addr)
        fmt.Printf("  Prometheus: http://%s/actuator/prometheus\n", addr)
        fmt.Printf("  Info: http://%s/actuator/info\n", addr)

        appLogger.Info("Server starting", zap.String("address", addr))

        if err := r.Run(addr); err != nil </span><span class="cov0" title="0">{
                appLogger.Error("Server failed to start", zap.Error(err))
                log.Fatalf("failed to start server: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "termsOfService": "http://swagger.io/terms/",
        "contact": {
            "name": "API Support",
            "url": "http://www.swagger.io/support",
            "email": "support@swagger.io"
        },
        "license": {
            "name": "MIT",
            "url": "https://opensource.org/licenses/MIT"
        },
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/auth/login": {
            "post": {
                "description": "Authenticate a user with email and password",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Authentication"
                ],
                "summary": "User login",
                "parameters": [
                    {
                        "description": "Login credentials",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/rest.LoginRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/rest.LoginResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/auth/logout": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Logout a user and invalidate their tokens",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Authentication"
                ],
                "summary": "User logout",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/rest.SuccessResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/auth/refresh": {
            "post": {
                "description": "Refresh an expired access token using a refresh token",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Authentication"
                ],
                "summary": "Refresh access token",
                "parameters": [
                    {
                        "description": "Refresh token",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/rest.RefreshTokenRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/rest.LoginResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/auth/register": {
            "post": {
                "description": "Register a new user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Authentication"
                ],
                "summary": "User registration",
                "parameters": [
                    {
                        "description": "Registration data",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/rest.RegisterRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/rest.User"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    },
                    "409": {
                        "description": "Conflict",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/oauth/complete": {
            "post": {
                "description": "Mark a one-time session as completed (e.g., survey submitted) and invalidate the token",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "OAuth"
                ],
                "summary": "Complete one-time session",
                "parameters": [
                    {
                        "type": "string",
                        "example": "\"one-time-token-123\"",
                        "description": "One-time token",
                        "name": "token",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "string",
                        "example": "\"survey-session-456\"",
                        "description": "Session ID",
                        "name": "session",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "string",
                        "example": "\"survey-submit-page\"",
                        "description": "Page ID",
                        "name": "page",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/rest.SuccessResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    },
                    "410": {
                        "description": "Gone",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/oauth/google/callback": {
            "get": {
                "description": "Handle Google OAuth callback and exchange code for tokens",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "OAuth"
                ],
                "summary": "Google OAuth callback",
                "parameters": [
                    {
                        "type": "string",
                        "example": "\"4/0AfJohXn...\"",
                        "description": "Authorization code from Google",
                        "name": "code",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "string",
                        "example": "\"tenant-123\"",
                        "description": "State parameter",
                        "name": "state",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "string",
                        "example": "\"access_denied\"",
                        "description": "Error from Google OAuth",
                        "name": "error",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/rest.LoginResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/oauth/google/login": {
            "get": {
                "description": "Redirect user to Google OAuth for authentication",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "OAuth"
                ],
                "summary": "Initiate Google OAuth login",
                "parameters": [
                    {
                        "type": "string",
                        "example": "\"tenant-123\"",
                        "description": "Tenant ID",
                        "name": "tenant_id",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "string",
                        "example": "\"https://app.example.com/callback\"",
                        "description": "Custom redirect URI",
                        "name": "redirect_uri",
                        "in": "query"
                    }
                ],
                "responses": {
                    "302": {
                        "description": "Redirect to Google OAuth",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/oauth/one-time": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Create a one-time token for secure access to specific URLs with session and page restrictions",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "OAuth"
                ],
                "summary": "Create one-time authentication token",
                "parameters": [
                    {
                        "description": "One-time token parameters",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/rest.OneTimeTokenRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/rest.OneTimeTokenResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/oauth/token": {
            "post": {
                "description": "Exchange client credentials for access token (service-to-service authentication)",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "OAuth"
                ],
                "summary": "OAuth 2.0 Client Credentials Flow",
                "parameters": [
                    {
                        "description": "Client credentials",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/rest.ClientCredentialsRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/rest.ClientCredentialsResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/oauth/verify": {
            "get": {
                "description": "Verify and consume a one-time token with session and page validation",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "OAuth"
                ],
                "summary": "Verify one-time authentication token",
                "parameters": [
                    {
                        "type": "string",
                        "example": "\"one-time-token-123\"",
                        "description": "One-time token",
                        "name": "token",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "string",
                        "example": "\"survey-session-456\"",
                        "description": "Session ID",
                        "name": "session",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "string",
                        "example": "\"survey-submit-page\"",
                        "description": "Page ID",
                        "name": "page",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/rest.OneTimeSessionResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    },
                    "410": {
                        "description": "Gone",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "rest.ClientCredentialsRequest": {
            "type": "object",
            "required": [
                "client_id",
                "client_secret",
                "grant_type"
            ],
            "properties": {
                "client_id": {
                    "type": "string",
                    "example": "service-client-123"
                },
                "client_secret": {
                    "type": "string",
                    "example": "service-secret-456"
                },
                "grant_type": {
                    "type": "string",
                    "example": "client_credentials"
                },
                "scope": {
                    "type": "string",
                    "example": "read:users write:users"
                }
            }
        },
        "rest.ClientCredentialsResponse": {
            "type": "object",
            "properties": {
                "access_token": {
                    "type": "string",
                    "example": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
                },
                "expires_in": {
                    "type": "integer",
                    "example": 3600
                },
                "scope": {
                    "type": "string",
                    "example": "read:users write:users"
                },
                "token_type": {
                    "type": "string",
                    "example": "Bearer"
                }
            }
        },
        "rest.ErrorResponse": {
            "type": "object",
            "properties": {
                "error": {
                    "type": "string",
                    "example": "validation_error"
                },
                "message": {
                    "type": "string",
                    "example": "Invalid request data"
                }
            }
        },
        "rest.LoginRequest": {
            "type": "object",
            "required": [
                "email",
                "password",
                "tenant_id"
            ],
            "properties": {
                "email": {
                    "type": "string",
                    "example": "user@example.com"
                },
                "password": {
                    "type": "string",
                    "example": "password123"
                },
                "tenant_id": {
                    "type": "string",
                    "example": "tenant-123"
                }
            }
        },
        "rest.LoginResponse": {
            "type": "object",
            "properties": {
                "access_token": {
                    "type": "string",
                    "example": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
                },
                "expires_in": {
                    "type": "integer",
                    "example": 3600
                },
                "refresh_token": {
                    "type": "string",
                    "example": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
                },
                "token_type": {
                    "type": "string",
                    "example": "Bearer"
                },
                "user": {
                    "$ref": "#/definitions/rest.User"
                }
            }
        },
        "rest.OneTimeSessionResponse": {
            "type": "object",
            "properties": {
                "is_valid": {
                    "type": "boolean",
                    "example": true
                },
                "message": {
                    "type": "string",
                    "example": "Token validated successfully"
                },
                "page_id": {
                    "type": "string",
                    "example": "survey-submit-page"
                },
                "session_id": {
                    "type": "string",
                    "example": "survey-session-456"
                },
                "token": {
                    "type": "string",
                    "example": "one-time-token-123"
                },
                "user": {
                    "$ref": "#/definitions/rest.User"
                }
            }
        },
        "rest.OneTimeTokenRequest": {
            "type": "object",
            "required": [
                "url"
            ],
            "properties": {
                "expires_in": {
                    "type": "integer",
                    "example": 3600
                },
                "max_uses": {
                    "type": "integer",
                    "example": 1
                },
                "page_id": {
                    "description": "Specific page/action identifier",
                    "type": "string",
                    "example": "survey-submit-page"
                },
                "session_id": {
                    "description": "Unique session identifier",
                    "type": "string",
                    "example": "survey-session-456"
                },
                "url": {
                    "type": "string",
                    "example": "https://app.example.com/survey/123"
                }
            }
        },
        "rest.OneTimeTokenResponse": {
            "type": "object",
            "properties": {
                "expires_in": {
                    "type": "integer",
                    "example": 3600
                },
                "max_uses": {
                    "type": "integer",
                    "example": 1
                },
                "page_id": {
                    "type": "string",
                    "example": "survey-submit-page"
                },
                "session_id": {
                    "type": "string",
                    "example": "survey-session-456"
                },
                "token": {
                    "type": "string",
                    "example": "one-time-token-123"
                },
                "url": {
                    "type": "string",
                    "example": "https://app.example.com/survey/123?token=one-time-token-123\u0026session=survey-session-456\u0026page=survey-submit-page"
                }
            }
        },
        "rest.RefreshTokenRequest": {
            "type": "object",
            "required": [
                "refresh_token"
            ],
            "properties": {
                "refresh_token": {
                    "type": "string",
                    "example": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
                }
            }
        },
        "rest.RegisterRequest": {
            "type": "object",
            "required": [
                "email",
                "first_name",
                "last_name",
                "password",
                "tenant_id"
            ],
            "properties": {
                "email": {
                    "type": "string",
                    "example": "user@example.com"
                },
                "first_name": {
                    "type": "string",
                    "example": "John"
                },
                "last_name": {
                    "type": "string",
                    "example": "Doe"
                },
                "password": {
                    "type": "string",
                    "example": "password123"
                },
                "tenant_id": {
                    "type": "string",
                    "example": "tenant-123"
                }
            }
        },
        "rest.Role": {
            "type": "object",
            "properties": {
                "id": {
                    "type": "string",
                    "example": "role-123"
                },
                "name": {
                    "type": "string",
                    "example": "admin"
                }
            }
        },
        "rest.SuccessResponse": {
            "type": "object",
            "properties": {
                "message": {
                    "type": "string",
                    "example": "Operation completed successfully"
                }
            }
        },
        "rest.User": {
            "type": "object",
            "properties": {
                "email": {
                    "type": "string",
                    "example": "user@example.com"
                },
                "id": {
                    "type": "string",
                    "example": "user-123"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/rest.Role"
                    }
                },
                "tenant_id": {
                    "type": "string",
                    "example": "tenant-123"
                }
            }
        }
    },
    "securityDefinitions": {
        "BearerAuth": {
            "description": "Type \"Bearer\" followed by a space and JWT token.",
            "type": "apiKey",
            "name": "Authorization",
            "in": "header"
        },
        "OAuth2ClientCredentials": {
            "type": "oauth2",
            "flow": "application",
            "tokenUrl": "/api/v1/oauth/token",
            "scopes": {
                "admin": "\"Admin access\"",
                "read": "\"Read access\"",
                "write": "\"Write access\""
            }
        }
    },
    "tags": [
        {
            "description": "Authentication and authorization endpoints",
            "name": "Authentication"
        },
        {
            "description": "OAuth 2.0 flow endpoints",
            "name": "OAuth"
        },
        {
            "description": "Multi-tenant management endpoints",
            "name": "Tenants"
        },
        {
            "description": "Role-based access control endpoints",
            "name": "RBAC"
        },
        {
            "description": "Service-to-service authentication endpoints",
            "name": "Services"
        }
    ]
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "localhost:8080",
        BasePath:         "/api/v1",
        Schemes:          []string{},
        Title:            "Multi-Tenant OAuth Service API",
        Description:      "A comprehensive OAuth 2.0 service with multi-tenancy, Google OAuth, and service-to-service authentication.",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov8" title="1">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package actuator

import (
        "auth-service/internal/config"
        "auth-service/internal/logger"
        "net/http"
        "runtime"
        "sync"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/heptiolabs/healthcheck"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promhttp"
        "go.uber.org/zap"
)

// Actuator provides health checks, metrics, and operational endpoints
type Actuator struct {
        appInfo         *AppInfo
        health          healthcheck.Handler
        registry        *prometheus.Registry
        startTime       time.Time
        requestCount    *prometheus.CounterVec
        requestDuration *prometheus.HistogramVec
        activeRequests  *prometheus.GaugeVec
        logger          *logger.Logger
        mu              sync.RWMutex
        healthChecks    map[string]healthcheck.Check
        readinessChecks map[string]healthcheck.Check
}

// AppInfo contains application metadata
type AppInfo struct {
        Name        string            `json:"name"`
        Version     string            `json:"version"`
        Description string            `json:"description"`
        BuildTime   string            `json:"buildTime"`
        GitCommit   string            `json:"gitCommit"`
        Environment string            `json:"environment"`
        Properties  map[string]string `json:"properties,omitempty"`
}

// NewActuator creates a new actuator instance
func NewActuator(appInfo *AppInfo) *Actuator <span class="cov10" title="33">{
        // Initialize logger for actuator
        appLogger, err := logger.NewLogger(&amp;config.LoggingConfig{
                Level:             "info",
                Format:            "json",
                Output:            "stdout",
                IncludeCaller:     true,
                IncludeStacktrace: true,
        })
        if err != nil </span><span class="cov0" title="0">{
                // Fallback to default logger if initialization fails
                appLogger = &amp;logger.Logger{}
        }</span>

        <span class="cov10" title="33">registry := prometheus.NewRegistry()

        // Create metrics
        requestCount := prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "http_requests_total",
                        Help: "Total number of HTTP requests",
                },
                []string{"method", "endpoint", "status"},
        )

        requestDuration := prometheus.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "http_request_duration_seconds",
                        Help:    "HTTP request duration in seconds",
                        Buckets: prometheus.DefBuckets,
                },
                []string{"method", "endpoint"},
        )

        activeRequests := prometheus.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "http_requests_active",
                        Help: "Number of active HTTP requests",
                },
                []string{"method", "endpoint"},
        )

        // Register metrics
        registry.MustRegister(requestCount, requestDuration, activeRequests)

        // Create health check handler
        health := healthcheck.NewHandler()

        return &amp;Actuator{
                appInfo:         appInfo,
                health:          health,
                registry:        registry,
                startTime:       time.Now(),
                requestCount:    requestCount,
                requestDuration: requestDuration,
                activeRequests:  activeRequests,
                logger:          appLogger,
                healthChecks:    make(map[string]healthcheck.Check),
                readinessChecks: make(map[string]healthcheck.Check),
        }</span>
}

// RegisterHealthCheck registers a health check with a name
func (a *Actuator) RegisterHealthCheck(name string, check healthcheck.Check) <span class="cov1" title="1">{
        a.health.AddLivenessCheck(name, check)
        a.logger.Info("Health check registered", zap.String("name", name))
}</span>

// RegisterReadinessCheck registers a readiness check with a name
func (a *Actuator) RegisterReadinessCheck(name string, check healthcheck.Check) <span class="cov1" title="1">{
        a.health.AddReadinessCheck(name, check)
        a.logger.Info("Readiness check registered", zap.String("name", name))
}</span>

// RegisterRoutes registers all actuator endpoints
func (a *Actuator) RegisterRoutes(router *gin.Engine) <span class="cov8" title="19">{
        actuator := router.Group("/actuator")
        </span><span class="cov8" title="19">{
                // Health endpoints
                actuator.GET("/health", a.Health)
                actuator.GET("/health/live", a.Liveness)
                actuator.GET("/health/ready", a.Readiness)

                // Info endpoints
                actuator.GET("/info", a.Info)
                actuator.GET("/env", a.Environment)

                // Metrics endpoints
                actuator.GET("/metrics", a.Metrics)
                actuator.GET("/prometheus", a.PrometheusMetrics)

                // Operational endpoints
                actuator.GET("/status", a.Status)
                actuator.GET("/uptime", a.Uptime)
                actuator.GET("/threaddump", a.ThreadDump)
                actuator.GET("/heapdump", a.HeapDump)

                // Configuration endpoints
                actuator.GET("/configprops", a.ConfigProps)
                actuator.GET("/mappings", a.Mappings)

                // Logging endpoints
                actuator.GET("/loggers", a.Loggers)
                actuator.POST("/loggers/:name", a.SetLoggerLevel)
        }</span>

        <span class="cov8" title="19">a.logger.Info("Actuator routes registered", zap.String("base_path", "/actuator"))</span>
}

// Health returns overall health status
func (a *Actuator) Health(c *gin.Context) <span class="cov2" title="2">{
        reqLogger := a.logger.WithRequest(c.Request)
        reqLogger.Info("Health check request received")

        // Use the healthcheck handler to get overall health
        a.health.LiveEndpoint(c.Writer, c.Request)

        reqLogger.BusinessEvent("health_check", "", "", map[string]interface{}{
                "endpoint": "/actuator/health",
        })
}</span>

// Liveness returns liveness check status
func (a *Actuator) Liveness(c *gin.Context) <span class="cov2" title="2">{
        reqLogger := a.logger.WithRequest(c.Request)
        reqLogger.Info("Liveness check request received")

        a.health.LiveEndpoint(c.Writer, c.Request)

        reqLogger.BusinessEvent("liveness_check", "", "", map[string]interface{}{
                "endpoint": "/actuator/health/live",
        })
}</span>

// Readiness returns readiness check status
func (a *Actuator) Readiness(c *gin.Context) <span class="cov2" title="2">{
        reqLogger := a.logger.WithRequest(c.Request)
        reqLogger.Info("Readiness check request received")

        a.health.ReadyEndpoint(c.Writer, c.Request)

        reqLogger.BusinessEvent("readiness_check", "", "", map[string]interface{}{
                "endpoint": "/actuator/health/ready",
        })
}</span>

// Info returns application information
func (a *Actuator) Info(c *gin.Context) <span class="cov2" title="2">{
        reqLogger := a.logger.WithRequest(c.Request)
        reqLogger.Info("Application info request received")

        c.JSON(http.StatusOK, a.appInfo)
}</span>

// Environment returns environment information
func (a *Actuator) Environment(c *gin.Context) <span class="cov2" title="2">{
        reqLogger := a.logger.WithRequest(c.Request)
        reqLogger.Info("Environment info request received")

        env := gin.H{
                "environment": a.appInfo.Environment,
                "properties":  a.appInfo.Properties,
                "goVersion":   runtime.Version(),
                "os":          runtime.GOOS,
                "arch":        runtime.GOARCH,
                "startTime":   a.startTime,
                "uptime":      time.Since(a.startTime).String(),
        }

        c.JSON(http.StatusOK, env)
}</span>

// Metrics returns application metrics
func (a *Actuator) Metrics(c *gin.Context) <span class="cov2" title="2">{
        reqLogger := a.logger.WithRequest(c.Request)
        reqLogger.Info("Metrics request received")

        metrics := gin.H{
                "uptime":    time.Since(a.startTime).String(),
                "memory":    a.getMemoryStats(),
                "runtime":   a.getRuntimeStats(),
                "requests":  a.getRequestStats(),
                "timestamp": time.Now(),
        }

        reqLogger.BusinessEvent("metrics_request", "", "", map[string]interface{}{
                "endpoint": "/actuator/metrics",
        })

        c.JSON(http.StatusOK, metrics)
}</span>

// PrometheusMetrics returns Prometheus-formatted metrics
func (a *Actuator) PrometheusMetrics(c *gin.Context) <span class="cov2" title="2">{
        reqLogger := a.logger.WithRequest(c.Request)
        reqLogger.Info("Prometheus metrics request received")

        handler := promhttp.HandlerFor(a.registry, promhttp.HandlerOpts{})
        handler.ServeHTTP(c.Writer, c.Request)

        reqLogger.BusinessEvent("prometheus_metrics_request", "", "", map[string]interface{}{
                "endpoint": "/actuator/prometheus",
        })
}</span>

// Status returns application status
func (a *Actuator) Status(c *gin.Context) <span class="cov2" title="2">{
        status := gin.H{
                "status":      "RUNNING",
                "startTime":   a.startTime,
                "uptime":      time.Since(a.startTime).String(),
                "version":     a.appInfo.Version,
                "environment": a.appInfo.Environment,
                "goroutines":  runtime.NumGoroutine(),
                "memory":      a.getMemoryStats(),
        }

        c.JSON(http.StatusOK, status)
}</span>

// Uptime returns application uptime
func (a *Actuator) Uptime(c *gin.Context) <span class="cov2" title="2">{
        uptime := gin.H{
                "uptime":      time.Since(a.startTime).String(),
                "startTime":   a.startTime,
                "duration":    time.Since(a.startTime).Milliseconds(),
                "durationSec": time.Since(a.startTime).Seconds(),
        }

        c.JSON(http.StatusOK, uptime)
}</span>

// ThreadDump returns goroutine information
func (a *Actuator) ThreadDump(c *gin.Context) <span class="cov2" title="2">{
        // Get goroutine count and stack traces
        stack := make([]byte, 1024*1024)
        stack = stack[:runtime.Stack(stack, true)]

        dump := gin.H{
                "numGoroutines": runtime.NumGoroutine(),
                "stackTrace":    string(stack),
                "timestamp":     time.Now(),
        }

        c.JSON(http.StatusOK, dump)
}</span>

// HeapDump returns memory heap information
func (a *Actuator) HeapDump(c *gin.Context) <span class="cov2" title="2">{
        var m runtime.MemStats
        runtime.ReadMemStats(&amp;m)

        dump := gin.H{
                "heapAlloc":    m.HeapAlloc,
                "heapSys":      m.HeapSys,
                "heapIdle":     m.HeapIdle,
                "heapInuse":    m.HeapInuse,
                "heapReleased": m.HeapReleased,
                "heapObjects":  m.HeapObjects,
                "totalAlloc":   m.TotalAlloc,
                "sys":          m.Sys,
                "numGC":        m.NumGC,
                "timestamp":    time.Now(),
        }

        c.JSON(http.StatusOK, dump)
}</span>

// ConfigProps returns configuration properties
func (a *Actuator) ConfigProps(c *gin.Context) <span class="cov2" title="2">{
        c.JSON(http.StatusOK, gin.H{
                "application": a.appInfo,
                "timestamp":   time.Now(),
        })
}</span>

// Mappings returns endpoint mappings
func (a *Actuator) Mappings(c *gin.Context) <span class="cov2" title="2">{
        mappings := gin.H{
                "actuator": gin.H{
                        "health":       "/actuator/health",
                        "health/live":  "/actuator/health/live",
                        "health/ready": "/actuator/health/ready",
                        "info":         "/actuator/info",
                        "metrics":      "/actuator/metrics",
                        "prometheus":   "/actuator/prometheus",
                        "status":       "/actuator/status",
                        "uptime":       "/actuator/uptime",
                        "threaddump":   "/actuator/threaddump",
                        "heapdump":     "/actuator/heapdump",
                },
                "timestamp": time.Now(),
        }

        c.JSON(http.StatusOK, mappings)
}</span>

// Loggers returns logger information
func (a *Actuator) Loggers(c *gin.Context) <span class="cov2" title="2">{
        loggers := gin.H{
                "levels": gin.H{
                        "ROOT":         "INFO",
                        "auth-service": "INFO",
                },
                "timestamp": time.Now(),
        }

        c.JSON(http.StatusOK, loggers)
}</span>

// SetLoggerLevel sets logger level
func (a *Actuator) SetLoggerLevel(c *gin.Context) <span class="cov4" title="4">{
        loggerName := c.Param("name")

        var request struct {
                Level string `json:"level"`
        }

        if err := c.ShouldBindJSON(&amp;request); err != nil </span><span class="cov2" title="2">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Invalid request body",
                })
                return
        }</span>

        <span class="cov2" title="2">c.JSON(http.StatusOK, gin.H{
                "logger":  loggerName,
                "level":   request.Level,
                "message": "Logger level updated",
        })</span>
}

// RecordRequest records request metrics
func (a *Actuator) RecordRequest(method, endpoint string, status int, duration time.Duration) <span class="cov4" title="4">{
        a.requestCount.WithLabelValues(method, endpoint, string(rune(status))).Inc()
        a.requestDuration.WithLabelValues(method, endpoint).Observe(duration.Seconds())
}</span>

// StartRequest starts tracking an active request
func (a *Actuator) StartRequest(method, endpoint string) <span class="cov2" title="2">{
        a.activeRequests.WithLabelValues(method, endpoint).Inc()
}</span>

// EndRequest ends tracking an active request
func (a *Actuator) EndRequest(method, endpoint string) <span class="cov2" title="2">{
        a.activeRequests.WithLabelValues(method, endpoint).Dec()
}</span>

// getMemoryStats returns current memory statistics
func (a *Actuator) getMemoryStats() gin.H <span class="cov5" title="6">{
        var m runtime.MemStats
        runtime.ReadMemStats(&amp;m)

        return gin.H{
                "alloc":      m.Alloc,
                "totalAlloc": m.TotalAlloc,
                "sys":        m.Sys,
                "numGC":      m.NumGC,
                "heapAlloc":  m.HeapAlloc,
                "heapSys":    m.HeapSys,
                "heapIdle":   m.HeapIdle,
                "heapInuse":  m.HeapInuse,
        }
}</span>

// getRuntimeStats returns current runtime statistics
func (a *Actuator) getRuntimeStats() gin.H <span class="cov4" title="4">{
        return gin.H{
                "numCPU":       runtime.NumCPU(),
                "numGoroutine": runtime.NumGoroutine(),
                "numCgoCall":   runtime.NumCgoCall(),
                "goVersion":    runtime.Version(),
        }
}</span>

// getRequestStats returns request statistics
func (a *Actuator) getRequestStats() gin.H <span class="cov4" title="4">{
        // This would typically return actual request statistics
        // For now, return placeholder data
        return gin.H{
                "totalRequests":   0,
                "activeRequests":  0,
                "requestsPerSec":  0,
                "errorCount":      0,
                "averageResponse": 0,
        }
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package actuator

import (
        "context"
        "database/sql"
        "fmt"
        "runtime"
        "time"

        "github.com/heptiolabs/healthcheck"
)

// DatabaseHealthCheck creates a health check for database connectivity
func DatabaseHealthCheck(db *sql.DB) healthcheck.Check <span class="cov4" title="2">{
        return func() error </span><span class="cov0" title="0">{
                ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
                defer cancel()

                return db.PingContext(ctx)
        }</span>
}

// RedisHealthCheck creates a health check for Redis connectivity
func RedisHealthCheck(redisClient interface{}) healthcheck.Check <span class="cov6" title="3">{
        return func() error </span><span class="cov6" title="3">{
                // This is a placeholder - you would implement actual Redis ping
                // For now, return nil to indicate success
                return nil
        }</span>
}

// DiskSpaceHealthCheck creates a health check for disk space
func DiskSpaceHealthCheck(minSpaceGB int64) healthcheck.Check <span class="cov7" title="4">{
        return func() error </span><span class="cov7" title="4">{
                // This is a placeholder - you would implement actual disk space check
                // For now, return nil to indicate success
                return nil
        }</span>
}

// MemoryHealthCheck creates a health check for memory usage
func MemoryHealthCheck(maxMemoryPercent int) healthcheck.Check <span class="cov10" title="6">{
        return func() error </span><span class="cov10" title="6">{
                var m runtime.MemStats
                runtime.ReadMemStats(&amp;m)

                // Calculate memory usage percentage
                memoryUsagePercent := float64(m.Sys) / float64(1&lt;&lt;30) * 100 // Convert to GB

                if memoryUsagePercent &gt; float64(maxMemoryPercent) </span><span class="cov6" title="3">{
                        return fmt.Errorf("memory usage too high: %.2f%%", memoryUsagePercent)
                }</span>

                <span class="cov6" title="3">return nil</span>
        }
}

// GoroutineHealthCheck creates a health check for goroutine count
func GoroutineHealthCheck(maxGoroutines int) healthcheck.Check <span class="cov9" title="5">{
        return func() error </span><span class="cov9" title="5">{
                count := runtime.NumGoroutine()
                if count &gt; maxGoroutines </span><span class="cov6" title="3">{
                        return fmt.Errorf("too many goroutines: %d", count)
                }</span>
                <span class="cov4" title="2">return nil</span>
        }
}

// CustomHealthCheck creates a custom health check function
func CustomHealthCheck(checkFunc func() error) healthcheck.Check <span class="cov7" title="4">{
        return checkFunc
}</span>

// TimeoutHealthCheck wraps a health check with a timeout
func TimeoutHealthCheck(check healthcheck.Check, timeout time.Duration) healthcheck.Check <span class="cov10" title="6">{
        return func() error </span><span class="cov9" title="5">{
                done := make(chan error, 1)
                go func() </span><span class="cov9" title="5">{
                        done &lt;- check()
                }</span>()

                <span class="cov9" title="5">select </span>{
                case err := &lt;-done:<span class="cov4" title="2">
                        return err</span>
                case &lt;-time.After(timeout):<span class="cov6" title="3">
                        return fmt.Errorf("health check timed out after %v", timeout)</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package config

import (
        "fmt"
        "time"

        "github.com/spf13/viper"
)

// Config holds all configuration for the application
type Config struct {
        Server   ServerConfig   `mapstructure:"server"`
        Database DatabaseConfig `mapstructure:"database"`
        Redis    RedisConfig    `mapstructure:"redis"`
        OAuth    OAuthConfig    `mapstructure:"oauth"`
        JWT      JWTConfig      `mapstructure:"jwt"`
        Security SecurityConfig `mapstructure:"security"`
        Logging  LoggingConfig  `mapstructure:"logging"`
        Cache    CacheConfig    `mapstructure:"cache"`
        Tenancy  TenancyConfig  `mapstructure:"tenancy"`
        OneTime  OneTimeConfig  `mapstructure:"one_time_auth"`
        Actuator ActuatorConfig `mapstructure:"actuator"`
}

// ServerConfig holds server configuration
type ServerConfig struct {
        Port           int           `mapstructure:"port"`
        GRPCPort       int           `mapstructure:"grpc_port"`
        Host           string        `mapstructure:"host"`
        ReadTimeout    time.Duration `mapstructure:"read_timeout"`
        WriteTimeout   time.Duration `mapstructure:"write_timeout"`
        MaxHeaderBytes int           `mapstructure:"max_header_bytes"`
}

// DatabaseConfig holds database configuration
type DatabaseConfig struct {
        Host            string        `mapstructure:"host"`
        Port            int           `mapstructure:"port"`
        Name            string        `mapstructure:"name"`
        User            string        `mapstructure:"user"`
        Password        string        `mapstructure:"password"`
        SSLMode         string        `mapstructure:"sslmode"`
        MaxOpenConns    int           `mapstructure:"max_open_conns"`
        MaxIdleConns    int           `mapstructure:"max_idle_conns"`
        ConnMaxLifetime time.Duration `mapstructure:"conn_max_lifetime"`
}

// RedisConfig holds Redis configuration
type RedisConfig struct {
        Host         string        `mapstructure:"host"`
        Port         int           `mapstructure:"port"`
        Password     string        `mapstructure:"password"`
        DB           int           `mapstructure:"db"`
        PoolSize     int           `mapstructure:"pool_size"`
        MinIdleConns int           `mapstructure:"min_idle_conns"`
        DialTimeout  time.Duration `mapstructure:"dial_timeout"`
        ReadTimeout  time.Duration `mapstructure:"read_timeout"`
        WriteTimeout time.Duration `mapstructure:"write_timeout"`
}

// OAuthConfig holds OAuth configuration
type OAuthConfig struct {
        Google    GoogleOAuthConfig `mapstructure:"google"`
        Providers []OAuthProvider   `mapstructure:"providers"`
}

// GoogleOAuthConfig holds Google OAuth specific configuration
type GoogleOAuthConfig struct {
        ClientID     string   `mapstructure:"client_id"`
        ClientSecret string   `mapstructure:"client_secret"`
        RedirectURL  string   `mapstructure:"redirect_url"`
        Scopes       []string `mapstructure:"scopes"`
}

// OAuthProvider holds OAuth provider configuration
type OAuthProvider struct {
        Name            string `mapstructure:"name"`
        Enabled         bool   `mapstructure:"enabled"`
        ClientIDEnv     string `mapstructure:"client_id_env"`
        ClientSecretEnv string `mapstructure:"client_secret_env"`
        RedirectURL     string `mapstructure:"redirect_url"`
}

// JWTConfig holds JWT configuration
type JWTConfig struct {
        Secret                 string `mapstructure:"secret"`
        ExpirationHours        int    `mapstructure:"expiration_hours"`
        RefreshExpirationHours int    `mapstructure:"refresh_expiration_hours"`
        Issuer                 string `mapstructure:"issuer"`
        Audience               string `mapstructure:"audience"`
}

// SecurityConfig holds security configuration
type SecurityConfig struct {
        BcryptCost             int      `mapstructure:"bcrypt_cost"`
        PasswordMinLength      int      `mapstructure:"password_min_length"`
        PasswordRequireUpper   bool     `mapstructure:"password_require_uppercase"`
        PasswordRequireLower   bool     `mapstructure:"password_require_lowercase"`
        PasswordRequireNumbers bool     `mapstructure:"password_require_numbers"`
        PasswordRequireSpecial bool     `mapstructure:"password_require_special"`
        RateLimitRequests      int      `mapstructure:"rate_limit_requests"`
        RateLimitWindow        string   `mapstructure:"rate_limit_window"`
        CORSAllowedOrigins     []string `mapstructure:"cors_allowed_origins"`
        CORSAllowedMethods     []string `mapstructure:"cors_allowed_methods"`
        CORSAllowedHeaders     []string `mapstructure:"cors_allowed_headers"`
}

// LoggingConfig holds logging configuration
type LoggingConfig struct {
        Level             string `mapstructure:"level"`
        Format            string `mapstructure:"format"`
        Output            string `mapstructure:"output"`
        IncludeCaller     bool   `mapstructure:"include_caller"`
        IncludeStacktrace bool   `mapstructure:"include_stacktrace"`
}

// CacheConfig holds cache configuration
type CacheConfig struct {
        TTL    CacheTTLConfig    `mapstructure:"ttl"`
        Prefix CachePrefixConfig `mapstructure:"prefix"`
}

// CacheTTLConfig holds cache TTL configuration
type CacheTTLConfig struct {
        UserSession  string `mapstructure:"user_session"`
        TenantConfig string `mapstructure:"tenant_config"`
        OAuthState   string `mapstructure:"oauth_state"`
        OneTimeToken string `mapstructure:"one_time_token"`
}

// CachePrefixConfig holds cache prefix configuration
type CachePrefixConfig struct {
        UserSession  string `mapstructure:"user_session"`
        TenantConfig string `mapstructure:"tenant_config"`
        OAuthState   string `mapstructure:"oauth_state"`
        OneTimeToken string `mapstructure:"one_time_token"`
}

// TenancyConfig holds multi-tenancy configuration
type TenancyConfig struct {
        DefaultTenantID   string `mapstructure:"default_tenant_id"`
        TenantHeader      string `mapstructure:"tenant_header"`
        TenantCookie      string `mapstructure:"tenant_cookie"`
        AutoCreateTenant  bool   `mapstructure:"auto_create_tenant"`
        MaxTenantsPerUser int    `mapstructure:"max_tenants_per_user"`
}

// OneTimeConfig holds one-time authentication configuration
type OneTimeConfig struct {
        TokenLength     int      `mapstructure:"token_length"`
        MaxUses         int      `mapstructure:"max_uses"`
        ExpirationHours int      `mapstructure:"expiration_hours"`
        AllowedURLs     []string `mapstructure:"allowed_urls"`
}

// ActuatorConfig holds actuator configuration
type ActuatorConfig struct {
        Enabled          bool                   `mapstructure:"enabled"`
        BasePath         string                 `mapstructure:"base_path"`
        Health           HealthConfig           `mapstructure:"health"`
        Metrics          MetricsConfig          `mapstructure:"metrics"`
        Endpoints        EndpointsConfig        `mapstructure:"endpoints"`
        ActuatorSecurity ActuatorSecurityConfig `mapstructure:"security"`
}

// HealthConfig holds health check configuration
type HealthConfig struct {
        Enabled                bool          `mapstructure:"enabled"`
        Timeout                time.Duration `mapstructure:"timeout"`
        MemoryThresholdPercent int           `mapstructure:"memory_threshold_percent"`
        GoroutineThreshold     int           `mapstructure:"goroutine_threshold"`
        DiskSpaceThresholdGB   int64         `mapstructure:"disk_space_threshold_gb"`
}

// MetricsConfig holds metrics configuration
type MetricsConfig struct {
        Enabled           bool `mapstructure:"enabled"`
        PrometheusEnabled bool `mapstructure:"prometheus_enabled"`
        RequestTracking   bool `mapstructure:"request_tracking"`
}

// EndpointsConfig holds endpoint configuration
type EndpointsConfig struct {
        Health      bool `mapstructure:"health"`
        Info        bool `mapstructure:"info"`
        Metrics     bool `mapstructure:"metrics"`
        Prometheus  bool `mapstructure:"prometheus"`
        Status      bool `mapstructure:"status"`
        Uptime      bool `mapstructure:"uptime"`
        ThreadDump  bool `mapstructure:"threaddump"`
        HeapDump    bool `mapstructure:"heapdump"`
        ConfigProps bool `mapstructure:"configprops"`
        Mappings    bool `mapstructure:"mappings"`
        Loggers     bool `mapstructure:"loggers"`
}

// ActuatorSecurityConfig holds actuator security configuration
type ActuatorSecurityConfig struct {
        HealthPublic                 bool     `mapstructure:"health_public"`
        MetricsPublic                bool     `mapstructure:"metrics_public"`
        SensitiveEndpointsRestricted bool     `mapstructure:"sensitive_endpoints_restricted"`
        AllowedIPs                   []string `mapstructure:"allowed_ips"`
}

// LoadConfig loads configuration from file and environment variables
func LoadConfig(configPath string) (*Config, error) <span class="cov10" title="11">{
        viper.SetConfigFile(configPath)
        viper.SetConfigType("yaml")

        // Read environment variables
        viper.AutomaticEnv()

        // Set default values
        setDefaults()

        // Read config file
        if err := viper.ReadInConfig(); err != nil </span><span class="cov3" title="2">{
                return nil, fmt.Errorf("failed to read config file: %w", err)
        }</span>

        // Override with environment variables
        <span class="cov9" title="9">overrideWithEnvVars()

        var config Config
        if err := viper.Unmarshal(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal config: %w", err)
        }</span>

        <span class="cov9" title="9">return &amp;config, nil</span>
}

// setDefaults sets default configuration values
func setDefaults() <span class="cov10" title="11">{
        viper.SetDefault("server.port", 8080)
        viper.SetDefault("server.grpc_port", 9090)
        viper.SetDefault("server.host", "0.0.0.0")
        viper.SetDefault("server.read_timeout", "30s")
        viper.SetDefault("server.write_timeout", "30s")
        viper.SetDefault("server.max_header_bytes", 1048576)

        viper.SetDefault("database.host", "localhost")
        viper.SetDefault("database.port", 5432)
        viper.SetDefault("database.name", "auth_service")
        viper.SetDefault("database.user", "postgres")
        viper.SetDefault("database.password", "password")
        viper.SetDefault("database.sslmode", "disable")
        viper.SetDefault("database.max_open_conns", 25)
        viper.SetDefault("database.max_idle_conns", 5)
        viper.SetDefault("database.conn_max_lifetime", "5m")

        viper.SetDefault("redis.host", "localhost")
        viper.SetDefault("redis.port", 6379)
        viper.SetDefault("redis.password", "")
        viper.SetDefault("redis.db", 0)
        viper.SetDefault("redis.pool_size", 10)
        viper.SetDefault("redis.min_idle_conns", 5)
        viper.SetDefault("redis.dial_timeout", "5s")
        viper.SetDefault("redis.read_timeout", "3s")
        viper.SetDefault("redis.write_timeout", "3s")

        viper.SetDefault("jwt.expiration_hours", 24)
        viper.SetDefault("jwt.refresh_expiration_hours", 168)
        viper.SetDefault("jwt.issuer", "auth-service")
        viper.SetDefault("jwt.audience", "auth-service-users")

        viper.SetDefault("security.bcrypt_cost", 12)
        viper.SetDefault("security.password_min_length", 8)
        viper.SetDefault("security.password_require_uppercase", true)
        viper.SetDefault("security.password_require_lowercase", true)
        viper.SetDefault("security.password_require_numbers", true)
        viper.SetDefault("security.password_require_special", true)
        viper.SetDefault("security.rate_limit_requests", 100)
        viper.SetDefault("security.rate_limit_window", "1m")

        viper.SetDefault("logging.level", "info")
        viper.SetDefault("logging.format", "json")
        viper.SetDefault("logging.output", "stdout")
        viper.SetDefault("logging.include_caller", true)
        viper.SetDefault("logging.include_stacktrace", true)

        viper.SetDefault("tenancy.default_tenant_id", "default")
        viper.SetDefault("tenancy.tenant_header", "X-Tenant-ID")
        viper.SetDefault("tenancy.tenant_cookie", "tenant_id")
        viper.SetDefault("tenancy.auto_create_tenant", true)
        viper.SetDefault("tenancy.max_tenants_per_user", 10)

        viper.SetDefault("one_time_auth.token_length", 32)
        viper.SetDefault("one_time_auth.max_uses", 1)
        viper.SetDefault("one_time_auth.expiration_hours", 1)

        viper.SetDefault("actuator.enabled", false)
        viper.SetDefault("actuator.base_path", "/actuator")
        viper.SetDefault("actuator.health.enabled", true)
        viper.SetDefault("actuator.health.timeout", "5s")
        viper.SetDefault("actuator.health.memory_threshold_percent", 90)
        viper.SetDefault("actuator.health.goroutine_threshold", 1000)
        viper.SetDefault("actuator.health.disk_space_threshold_gb", 10)
        viper.SetDefault("actuator.metrics.enabled", true)
        viper.SetDefault("actuator.metrics.prometheus_enabled", true)
        viper.SetDefault("actuator.metrics.request_tracking", true)
        viper.SetDefault("actuator.endpoints.health", true)
        viper.SetDefault("actuator.endpoints.info", true)
        viper.SetDefault("actuator.endpoints.metrics", true)
        viper.SetDefault("actuator.endpoints.prometheus", true)
        viper.SetDefault("actuator.endpoints.status", true)
        viper.SetDefault("actuator.endpoints.uptime", true)
        viper.SetDefault("actuator.endpoints.threaddump", true)
        viper.SetDefault("actuator.endpoints.heapdump", true)
        viper.SetDefault("actuator.endpoints.configprops", true)
        viper.SetDefault("actuator.endpoints.mappings", true)
        viper.SetDefault("actuator.endpoints.loggers", true)
        viper.SetDefault("actuator.security.health_public", true)
        viper.SetDefault("actuator.security.metrics_public", true)
        viper.SetDefault("actuator.security.sensitive_endpoints_restricted", true)
        viper.SetDefault("actuator.security.allowed_ips", []string{})
}</span>

// overrideWithEnvVars overrides configuration with environment variables
func overrideWithEnvVars() <span class="cov9" title="9">{
        // Server
        if serverPort := viper.GetInt("SERVER_PORT"); serverPort != 0 </span><span class="cov8" title="7">{
                viper.Set("server.port", serverPort)
        }</span>
        <span class="cov9" title="9">if serverHost := viper.GetString("SERVER_HOST"); serverHost != "" </span><span class="cov6" title="4">{
                viper.Set("server.host", serverHost)
        }</span>

        // Database
        <span class="cov9" title="9">if dbHost := viper.GetString("DB_HOST"); dbHost != "" </span><span class="cov9" title="9">{
                viper.Set("database.host", dbHost)
        }</span>
        <span class="cov9" title="9">if dbPort := viper.GetInt("DB_PORT"); dbPort != 0 </span><span class="cov8" title="7">{
                viper.Set("database.port", dbPort)
        }</span>
        <span class="cov9" title="9">if dbName := viper.GetString("DB_NAME"); dbName != "" </span><span class="cov9" title="9">{
                viper.Set("database.name", dbName)
        }</span>
        <span class="cov9" title="9">if dbUser := viper.GetString("DB_USER"); dbUser != "" </span><span class="cov9" title="9">{
                viper.Set("database.user", dbUser)
        }</span>
        <span class="cov9" title="9">if dbPassword := viper.GetString("DB_PASSWORD"); dbPassword != "" </span><span class="cov9" title="9">{
                viper.Set("database.password", dbPassword)
        }</span>

        // Redis
        <span class="cov9" title="9">if redisHost := viper.GetString("REDIS_HOST"); redisHost != "" </span><span class="cov9" title="9">{
                viper.Set("redis.host", redisHost)
        }</span>
        <span class="cov9" title="9">if redisPort := viper.GetInt("REDIS_PORT"); redisPort != 0 </span><span class="cov8" title="7">{
                viper.Set("redis.port", redisPort)
        }</span>
        <span class="cov9" title="9">if redisPassword := viper.GetString("REDIS_PASSWORD"); redisPassword != "" </span><span class="cov9" title="9">{
                viper.Set("redis.password", redisPassword)
        }</span>

        // JWT
        <span class="cov9" title="9">if jwtSecret := viper.GetString("JWT_SECRET"); jwtSecret != "" </span><span class="cov9" title="9">{
                viper.Set("jwt.secret", jwtSecret)
        }</span>

        // OAuth
        <span class="cov9" title="9">if googleClientID := viper.GetString("GOOGLE_CLIENT_ID"); googleClientID != "" </span><span class="cov9" title="9">{
                viper.Set("oauth.google.client_id", googleClientID)
        }</span>
        <span class="cov9" title="9">if googleClientSecret := viper.GetString("GOOGLE_CLIENT_SECRET"); googleClientSecret != "" </span><span class="cov9" title="9">{
                viper.Set("oauth.google.client_secret", googleClientSecret)
        }</span>

        // Actuator
        <span class="cov9" title="9">if actuatorEnabled := viper.GetBool("ACTUATOR_ENABLED"); actuatorEnabled </span><span class="cov6" title="4">{
                viper.Set("actuator.enabled", true)
        }</span>
        <span class="cov9" title="9">if actuatorBasePath := viper.GetString("ACTUATOR_BASE_PATH"); actuatorBasePath != "" </span><span class="cov6" title="4">{
                viper.Set("actuator.base_path", actuatorBasePath)
        }</span>
        <span class="cov9" title="9">if actuatorHealthEnabled := viper.GetBool("ACTUATOR_HEALTH_ENABLED"); actuatorHealthEnabled </span><span class="cov6" title="4">{
                viper.Set("actuator.health.enabled", true)
        }</span>
        <span class="cov9" title="9">if actuatorHealthTimeout := viper.GetDuration("ACTUATOR_HEALTH_TIMEOUT"); actuatorHealthTimeout != 0 </span><span class="cov1" title="1">{
                viper.Set("actuator.health.timeout", actuatorHealthTimeout)
        }</span>
        <span class="cov9" title="9">if actuatorHealthMemoryThresholdPercent := viper.GetInt("ACTUATOR_HEALTH_MEMORY_THRESHOLD_PERCENT"); actuatorHealthMemoryThresholdPercent != 0 </span><span class="cov1" title="1">{
                viper.Set("actuator.health.memory_threshold_percent", actuatorHealthMemoryThresholdPercent)
        }</span>
        <span class="cov9" title="9">if actuatorHealthGoroutineThreshold := viper.GetInt("ACTUATOR_HEALTH_GOROUTINE_THRESHOLD"); actuatorHealthGoroutineThreshold != 0 </span><span class="cov1" title="1">{
                viper.Set("actuator.health.goroutine_threshold", actuatorHealthGoroutineThreshold)
        }</span>
        <span class="cov9" title="9">if actuatorHealthDiskSpaceThresholdGB := viper.GetInt64("ACTUATOR_HEALTH_DISK_SPACE_THRESHOLD_GB"); actuatorHealthDiskSpaceThresholdGB != 0 </span><span class="cov1" title="1">{
                viper.Set("actuator.health.disk_space_threshold_gb", actuatorHealthDiskSpaceThresholdGB)
        }</span>
        <span class="cov9" title="9">if actuatorMetricsEnabled := viper.GetBool("ACTUATOR_METRICS_ENABLED"); actuatorMetricsEnabled </span><span class="cov6" title="4">{
                viper.Set("actuator.metrics.enabled", true)
        }</span>
        <span class="cov9" title="9">if actuatorMetricsPrometheusEnabled := viper.GetBool("ACTUATOR_METRICS_PROMETHEUS_ENABLED"); actuatorMetricsPrometheusEnabled </span><span class="cov6" title="4">{
                viper.Set("actuator.metrics.prometheus_enabled", true)
        }</span>
        <span class="cov9" title="9">if actuatorMetricsRequestTracking := viper.GetBool("ACTUATOR_METRICS_REQUEST_TRACKING"); actuatorMetricsRequestTracking </span><span class="cov6" title="4">{
                viper.Set("actuator.metrics.request_tracking", true)
        }</span>
        <span class="cov9" title="9">if actuatorEndpointsHealth := viper.GetBool("ACTUATOR_ENDPOINTS_HEALTH"); actuatorEndpointsHealth </span><span class="cov0" title="0">{
                viper.Set("actuator.endpoints.health", true)
        }</span>
        <span class="cov9" title="9">if actuatorEndpointsInfo := viper.GetBool("ACTUATOR_ENDPOINTS_INFO"); actuatorEndpointsInfo </span><span class="cov0" title="0">{
                viper.Set("actuator.endpoints.info", true)
        }</span>
        <span class="cov9" title="9">if actuatorEndpointsMetrics := viper.GetBool("ACTUATOR_ENDPOINTS_METRICS"); actuatorEndpointsMetrics </span><span class="cov0" title="0">{
                viper.Set("actuator.endpoints.metrics", true)
        }</span>
        <span class="cov9" title="9">if actuatorEndpointsPrometheus := viper.GetBool("ACTUATOR_ENDPOINTS_PROMETHEUS"); actuatorEndpointsPrometheus </span><span class="cov0" title="0">{
                viper.Set("actuator.endpoints.prometheus", true)
        }</span>
        <span class="cov9" title="9">if actuatorEndpointsStatus := viper.GetBool("ACTUATOR_ENDPOINTS_STATUS"); actuatorEndpointsStatus </span><span class="cov0" title="0">{
                viper.Set("actuator.endpoints.status", true)
        }</span>
        <span class="cov9" title="9">if actuatorEndpointsUptime := viper.GetBool("ACTUATOR_ENDPOINTS_UPTIME"); actuatorEndpointsUptime </span><span class="cov0" title="0">{
                viper.Set("actuator.endpoints.uptime", true)
        }</span>
        <span class="cov9" title="9">if actuatorEndpointsThreadDump := viper.GetBool("ACTUATOR_ENDPOINTS_THREAD_DUMP"); actuatorEndpointsThreadDump </span><span class="cov0" title="0">{
                viper.Set("actuator.endpoints.threaddump", true)
        }</span>
        <span class="cov9" title="9">if actuatorEndpointsHeapDump := viper.GetBool("ACTUATOR_ENDPOINTS_HEAP_DUMP"); actuatorEndpointsHeapDump </span><span class="cov0" title="0">{
                viper.Set("actuator.endpoints.heapdump", true)
        }</span>
        <span class="cov9" title="9">if actuatorEndpointsConfigProps := viper.GetBool("ACTUATOR_ENDPOINTS_CONFIG_PROPS"); actuatorEndpointsConfigProps </span><span class="cov0" title="0">{
                viper.Set("actuator.endpoints.configprops", true)
        }</span>
        <span class="cov9" title="9">if actuatorEndpointsMappings := viper.GetBool("ACTUATOR_ENDPOINTS_MAPPINGS"); actuatorEndpointsMappings </span><span class="cov0" title="0">{
                viper.Set("actuator.endpoints.mappings", true)
        }</span>
        <span class="cov9" title="9">if actuatorEndpointsLoggers := viper.GetBool("ACTUATOR_ENDPOINTS_LOGGERS"); actuatorEndpointsLoggers </span><span class="cov0" title="0">{
                viper.Set("actuator.endpoints.loggers", true)
        }</span>
        <span class="cov9" title="9">if actuatorSecurityHealthPublic := viper.GetBool("ACTUATOR_SECURITY_HEALTH_PUBLIC"); actuatorSecurityHealthPublic </span><span class="cov0" title="0">{
                viper.Set("actuator.security.health_public", true)
        }</span>
        <span class="cov9" title="9">if actuatorSecurityMetricsPublic := viper.GetBool("ACTUATOR_SECURITY_METRICS_PUBLIC"); actuatorSecurityMetricsPublic </span><span class="cov0" title="0">{
                viper.Set("actuator.security.metrics_public", true)
        }</span>
        <span class="cov9" title="9">if actuatorSecuritySensitiveEndpointsRestricted := viper.GetBool("ACTUATOR_SECURITY_SENSITIVE_ENDPOINTS_RESTRICTED"); actuatorSecuritySensitiveEndpointsRestricted </span><span class="cov0" title="0">{
                viper.Set("actuator.security.sensitive_endpoints_restricted", true)
        }</span>
        <span class="cov9" title="9">if actuatorSecurityAllowedIPs := viper.GetStringSlice("ACTUATOR_SECURITY_ALLOWED_IPS"); len(actuatorSecurityAllowedIPs) &gt; 0 </span><span class="cov0" title="0">{
                viper.Set("actuator.security.allowed_ips", actuatorSecurityAllowedIPs)
        }</span>
}

// GetDSN returns the database connection string
func (c *DatabaseConfig) GetDSN() string <span class="cov5" title="3">{
        return fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
                c.Host, c.Port, c.User, c.Password, c.Name, c.SSLMode)
}</span>

// GetRedisAddr returns the Redis address
func (c *RedisConfig) GetRedisAddr() string <span class="cov6" title="4">{
        return fmt.Sprintf("%s:%d", c.Host, c.Port)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package rest

import (
        "auth-service/internal/config"
        "auth-service/internal/logger"
        "auth-service/internal/middleware"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

// AuthHandler handles authentication-related HTTP requests
type AuthHandler struct {
        config *config.Config
        logger *logger.Logger
}

// NewAuthHandler creates a new AuthHandler instance
func NewAuthHandler(cfg *config.Config) *AuthHandler <span class="cov10" title="12">{
        // Initialize logger for auth handler
        appLogger, err := logger.NewLogger(&amp;cfg.Logging)
        if err != nil </span><span class="cov0" title="0">{
                // Fallback to default logger if initialization fails
                appLogger = &amp;logger.Logger{}
        }</span>

        <span class="cov10" title="12">return &amp;AuthHandler{
                config: cfg,
                logger: appLogger,
        }</span>
}

// LoginRequest represents the login request body
type LoginRequest struct {
        Email    string `json:"email" binding:"required,email" example:"user@example.com"`
        Password string `json:"password" binding:"required" example:"password123"`
        TenantID string `json:"tenant_id" binding:"required" example:"tenant-123"`
}

// LoginResponse represents the login response body
type LoginResponse struct {
        AccessToken  string `json:"access_token" example:"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."`
        RefreshToken string `json:"refresh_token" example:"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."`
        TokenType    string `json:"token_type" example:"Bearer"`
        ExpiresIn    int    `json:"expires_in" example:"3600"`
        User         User   `json:"user"`
}

// User represents a user in the system
type User struct {
        ID       string `json:"id" example:"user-123"`
        Email    string `json:"email" example:"user@example.com"`
        TenantID string `json:"tenant_id" example:"tenant-123"`
        Roles    []Role `json:"roles"`
}

// Role represents a user role
type Role struct {
        ID   string `json:"id" example:"role-123"`
        Name string `json:"name" example:"admin"`
}

// Login godoc
// @Summary User login
// @Description Authenticate a user with email and password
// @Tags Authentication
// @Accept json
// @Produce json
// @Param request body LoginRequest true "Login credentials"
// @Success 200 {object} LoginResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /auth/login [post]
func (h *AuthHandler) Login(c *gin.Context) <span class="cov6" title="4">{
        start := time.Now()

        // Safely get logger from context
        var reqLogger *logger.RequestLogger
        if loggerInterface := middleware.GetLogger(c); loggerInterface != nil </span><span class="cov6" title="4">{
                if reqLog, ok := loggerInterface.(*logger.RequestLogger); ok </span><span class="cov6" title="4">{
                        reqLogger = reqLog
                }</span>
        }

        // If no logger available, create a basic one
        <span class="cov6" title="4">if reqLogger == nil </span><span class="cov0" title="0">{
                reqLogger = h.logger.WithRequest(c.Request)
        }</span>

        <span class="cov6" title="4">reqLogger.Info("Login attempt started",
                zap.String("endpoint", "/auth/login"),
                zap.String("method", "POST"),
        )

        var req LoginRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov4" title="3">{
                reqLogger.AuthFailure("", req.TenantID, "password", "validation_error")
                reqLogger.Error("Login validation failed", zap.Error(err))

                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "validation_error",
                        Message: err.Error(),
                })
                return
        }</span>

        <span class="cov1" title="1">reqLogger.Info("Login validation passed",
                zap.String("email", req.Email),
                zap.String("tenant_id", req.TenantID),
        )

        // TODO: Implement actual authentication logic
        // For now, return a mock response

        // Simulate database operation
        dbStart := time.Now()
        // Mock database query
        time.Sleep(10 * time.Millisecond) // Simulate DB latency
        reqLogger.DatabaseOperation("SELECT", "users", req.TenantID, time.Since(dbStart), nil)

        // Simulate cache operation
        cacheStart := time.Now()
        // Mock cache check
        time.Sleep(5 * time.Millisecond) // Simulate cache latency
        reqLogger.CacheOperation("GET", "user_session:"+req.Email, req.TenantID, false, time.Since(cacheStart), nil)

        response := LoginResponse{
                AccessToken:  "mock-access-token",
                RefreshToken: "mock-refresh-token",
                TokenType:    "Bearer",
                ExpiresIn:    3600,
                User: User{
                        ID:       "user-123",
                        Email:    req.Email,
                        TenantID: req.TenantID,
                        Roles: []Role{
                                {ID: "role-1", Name: "user"},
                        },
                },
        }

        // Log successful authentication
        reqLogger.AuthSuccess("user-123", req.TenantID, "password")
        reqLogger.BusinessEvent("user_login", "user-123", req.TenantID, map[string]interface{}{
                "login_method": "password",
                "roles":        []string{"user"},
                "duration_ms":  time.Since(start).Milliseconds(),
        })

        c.JSON(http.StatusOK, response)</span>
}

// RegisterRequest represents the registration request body
type RegisterRequest struct {
        Email     string `json:"email" binding:"required,email" example:"user@example.com"`
        Password  string `json:"password" binding:"required" example:"password123"`
        TenantID  string `json:"tenant_id" binding:"required" example:"tenant-123"`
        FirstName string `json:"first_name" binding:"required" example:"John"`
        LastName  string `json:"last_name" binding:"required" example:"Doe"`
}

// Register godoc
// @Summary User registration
// @Description Register a new user
// @Tags Authentication
// @Accept json
// @Produce json
// @Param request body RegisterRequest true "Registration data"
// @Success 201 {object} User
// @Failure 400 {object} ErrorResponse
// @Failure 409 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /auth/register [post]
func (h *AuthHandler) Register(c *gin.Context) <span class="cov6" title="4">{
        start := time.Now()

        // Safely get logger from context
        var reqLogger *logger.RequestLogger
        if loggerInterface := middleware.GetLogger(c); loggerInterface != nil </span><span class="cov6" title="4">{
                if reqLog, ok := loggerInterface.(*logger.RequestLogger); ok </span><span class="cov6" title="4">{
                        reqLogger = reqLog
                }</span>
        }

        // If no logger available, create a basic one
        <span class="cov6" title="4">if reqLogger == nil </span><span class="cov0" title="0">{
                reqLogger = h.logger.WithRequest(c.Request)
        }</span>

        <span class="cov6" title="4">reqLogger.Info("Registration attempt started",
                zap.String("endpoint", "/auth/register"),
                zap.String("method", "POST"),
        )

        var req RegisterRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov4" title="3">{
                reqLogger.Error("Registration validation failed", zap.Error(err))

                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "validation_error",
                        Message: err.Error(),
                })
                return
        }</span>

        <span class="cov1" title="1">reqLogger.Info("Registration validation passed",
                zap.String("email", req.Email),
                zap.String("tenant_id", req.TenantID),
                zap.String("first_name", req.FirstName),
                zap.String("last_name", req.LastName),
        )

        // TODO: Implement actual registration logic

        // Simulate database operations
        dbStart := time.Now()
        // Mock database queries
        time.Sleep(15 * time.Millisecond)                                                      // Simulate DB latency
        reqLogger.DatabaseOperation("SELECT", "users", req.TenantID, time.Since(dbStart), nil) // Check if user exists

        insertStart := time.Now()
        time.Sleep(20 * time.Millisecond) // Simulate DB insert
        reqLogger.DatabaseOperation("INSERT", "users", req.TenantID, time.Since(insertStart), nil)

        user := User{
                ID:       "user-123",
                Email:    req.Email,
                TenantID: req.TenantID,
                Roles: []Role{
                        {ID: "role-1", Name: "user"},
                },
        }

        // Log successful registration
        reqLogger.BusinessEvent("user_registration", "user-123", req.TenantID, map[string]interface{}{
                "email":       req.Email,
                "first_name":  req.FirstName,
                "last_name":   req.LastName,
                "duration_ms": time.Since(start).Milliseconds(),
        })

        c.JSON(http.StatusCreated, user)</span>
}

// RefreshTokenRequest represents the refresh token request body
type RefreshTokenRequest struct {
        RefreshToken string `json:"refresh_token" binding:"required" example:"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."`
}

// RefreshToken godoc
// @Summary Refresh access token
// @Description Refresh an expired access token using a refresh token
// @Tags Authentication
// @Accept json
// @Produce json
// @Param request body RefreshTokenRequest true "Refresh token"
// @Success 200 {object} LoginResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /auth/refresh [post]
func (h *AuthHandler) RefreshToken(c *gin.Context) <span class="cov3" title="2">{
        start := time.Now()

        // Safely get logger from context
        var reqLogger *logger.RequestLogger
        if loggerInterface := middleware.GetLogger(c); loggerInterface != nil </span><span class="cov3" title="2">{
                if reqLog, ok := loggerInterface.(*logger.RequestLogger); ok </span><span class="cov3" title="2">{
                        reqLogger = reqLog
                }</span>
        }

        // If no logger available, create a basic one
        <span class="cov3" title="2">if reqLogger == nil </span><span class="cov0" title="0">{
                reqLogger = h.logger.WithRequest(c.Request)
        }</span>

        <span class="cov3" title="2">reqLogger.Info("Token refresh attempt started",
                zap.String("endpoint", "/auth/refresh"),
                zap.String("method", "POST"),
        )

        var req RefreshTokenRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov1" title="1">{
                reqLogger.Error("Token refresh validation failed", zap.Error(err))

                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "validation_error",
                        Message: err.Error(),
                })
                return
        }</span>

        <span class="cov1" title="1">reqLogger.Info("Token refresh validation passed",
                zap.String("refresh_token_prefix", req.RefreshToken[:10]+"..."),
        )

        // TODO: Implement actual token refresh logic

        // Simulate token validation
        tokenStart := time.Now()
        time.Sleep(5 * time.Millisecond) // Simulate token validation
        reqLogger.DatabaseOperation("SELECT", "refresh_tokens", "tenant-123", time.Since(tokenStart), nil)

        response := LoginResponse{
                AccessToken:  "new-access-token",
                RefreshToken: "new-refresh-token",
                TokenType:    "Bearer",
                ExpiresIn:    3600,
                User: User{
                        ID:       "user-123",
                        Email:    "user@example.com",
                        TenantID: "tenant-123",
                        Roles: []Role{
                                {ID: "role-1", Name: "user"},
                        },
                },
        }

        // Log successful token refresh
        reqLogger.BusinessEvent("token_refresh", "user-123", "tenant-123", map[string]interface{}{
                "duration_ms": time.Since(start).Milliseconds(),
        })

        c.JSON(http.StatusOK, response)</span>
}

// Logout godoc
// @Summary User logout
// @Description Logout a user and invalidate their tokens
// @Tags Authentication
// @Accept json
// @Produce json
// @Security BearerAuth
// @Success 200 {object} SuccessResponse
// @Failure 401 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /auth/logout [post]
func (h *AuthHandler) Logout(c *gin.Context) <span class="cov1" title="1">{
        start := time.Now()

        // Safely get logger from context
        var reqLogger *logger.RequestLogger
        if loggerInterface := middleware.GetLogger(c); loggerInterface != nil </span><span class="cov1" title="1">{
                if reqLog, ok := loggerInterface.(*logger.RequestLogger); ok </span><span class="cov1" title="1">{
                        reqLogger = reqLog
                }</span>
        }

        // If no logger available, create a basic one
        <span class="cov1" title="1">if reqLogger == nil </span><span class="cov0" title="0">{
                reqLogger = h.logger.WithRequest(c.Request)
        }</span>

        <span class="cov1" title="1">reqLogger.Info("Logout attempt started",
                zap.String("endpoint", "/auth/logout"),
                zap.String("method", "POST"),
        )

        // TODO: Implement actual logout logic (invalidate tokens)

        // Simulate token invalidation
        invalidateStart := time.Now()
        time.Sleep(10 * time.Millisecond) // Simulate token invalidation
        reqLogger.DatabaseOperation("UPDATE", "refresh_tokens", "tenant-123", time.Since(invalidateStart), nil)

        // Log successful logout
        reqLogger.BusinessEvent("user_logout", "user-123", "tenant-123", map[string]interface{}{
                "duration_ms": time.Since(start).Milliseconds(),
        })

        c.JSON(http.StatusOK, SuccessResponse{
                Message: "Successfully logged out",
        })</span>
}

// ErrorResponse represents an error response
type ErrorResponse struct {
        Error   string `json:"error" example:"validation_error"`
        Message string `json:"message" example:"Invalid request data"`
}

// SuccessResponse represents a success response
type SuccessResponse struct {
        Message string `json:"message" example:"Operation completed successfully"`
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package rest

import (
        "auth-service/internal/config"
        "auth-service/internal/logger"
        "auth-service/internal/middleware"
        "fmt"
        "net/http"
        "strings"
        "time"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

// OAuthHandler handles OAuth-related HTTP requests
type OAuthHandler struct {
        config *config.Config
        logger *logger.Logger
}

// NewOAuthHandler creates a new OAuthHandler instance
func NewOAuthHandler(cfg *config.Config) *OAuthHandler <span class="cov10" title="35">{
        // Initialize logger for OAuth handler
        appLogger, err := logger.NewLogger(&amp;cfg.Logging)
        if err != nil </span><span class="cov10" title="35">{
                // Fallback to default logger if initialization fails
                appLogger = &amp;logger.Logger{}
        }</span>

        <span class="cov10" title="35">return &amp;OAuthHandler{
                config: cfg,
                logger: appLogger,
        }</span>
}

// GoogleLogin godoc
// @Summary Initiate Google OAuth login
// @Description Redirect user to Google OAuth for authentication
// @Tags OAuth
// @Accept json
// @Produce json
// @Param tenant_id query string true "Tenant ID" example("tenant-123")
// @Param redirect_uri query string false "Custom redirect URI" example("https://app.example.com/callback")
// @Success 302 {string} string "Redirect to Google OAuth"
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /oauth/google/login [get]
func (h *OAuthHandler) GoogleLogin(c *gin.Context) <span class="cov5" title="5">{
        start := time.Now()

        // Safely get logger from context
        var reqLogger *logger.RequestLogger
        if loggerInterface := middleware.GetLogger(c); loggerInterface != nil </span><span class="cov5" title="5">{
                if reqLog, ok := loggerInterface.(*logger.RequestLogger); ok </span><span class="cov5" title="5">{
                        reqLogger = reqLog
                }</span>
        }

        // If no logger available, create a basic one
        <span class="cov5" title="5">if reqLogger == nil </span><span class="cov0" title="0">{
                reqLogger = h.logger.WithRequest(c.Request)
        }</span>

        <span class="cov5" title="5">reqLogger.Info("Google OAuth login initiated",
                zap.String("endpoint", "/oauth/google/login"),
                zap.String("method", "GET"),
        )

        tenantID := c.Query("tenant_id")
        redirectURI := c.Query("redirect_uri")

        if tenantID == "" </span><span class="cov1" title="1">{
                reqLogger.AuthFailure("", "", "google_oauth", "missing_tenant_id")
                reqLogger.Error("Google OAuth login failed - missing tenant ID")

                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "missing_tenant_id",
                        Message: "Tenant ID is required",
                })
                return
        }</span>

        <span class="cov4" title="4">reqLogger.Info("Google OAuth login validation passed",
                zap.String("tenant_id", tenantID),
                zap.String("redirect_uri", redirectURI),
        )

        // Use custom redirect URI if provided, otherwise use default
        callbackURL := h.config.OAuth.Google.RedirectURL
        if redirectURI != "" </span><span class="cov1" title="1">{
                callbackURL = redirectURI
        }</span>

        // TODO: Implement Google OAuth flow
        // For now, return a mock redirect URL
        <span class="cov4" title="4">googleAuthURL := "https://accounts.google.com/oauth/authorize?client_id=" + h.config.OAuth.Google.ClientID + "&amp;redirect_uri=" + callbackURL + "&amp;scope=email profile&amp;response_type=code&amp;state=" + tenantID

        // Log OAuth flow initiation
        reqLogger.OAuthFlow("google", "login_initiated", tenantID, nil)
        reqLogger.BusinessEvent("oauth_login_initiated", "", tenantID, map[string]interface{}{
                "provider":     "google",
                "redirect_uri": callbackURL,
                "duration_ms":  time.Since(start).Milliseconds(),
        })

        c.JSON(http.StatusOK, gin.H{
                "auth_url": googleAuthURL,
                "message":  "Redirect to Google OAuth",
        })</span>
}

// GoogleCallback godoc
// @Summary Google OAuth callback
// @Description Handle Google OAuth callback and exchange code for tokens
// @Tags OAuth
// @Accept json
// @Produce json
// @Param code query string true "Authorization code from Google" example("4/0AfJohXn...")
// @Param state query string true "State parameter" example("tenant-123")
// @Param error query string false "Error from Google OAuth" example("access_denied")
// @Success 200 {object} LoginResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /oauth/google/callback [get]
func (h *OAuthHandler) GoogleCallback(c *gin.Context) <span class="cov5" title="7">{
        start := time.Now()

        // Safely get logger from context
        var reqLogger *logger.RequestLogger
        if loggerInterface := middleware.GetLogger(c); loggerInterface != nil </span><span class="cov5" title="7">{
                if reqLog, ok := loggerInterface.(*logger.RequestLogger); ok </span><span class="cov5" title="7">{
                        reqLogger = reqLog
                }</span>
        }

        // If no logger available, create a basic one
        <span class="cov5" title="7">if reqLogger == nil </span><span class="cov0" title="0">{
                reqLogger = h.logger.WithRequest(c.Request)
        }</span>

        <span class="cov5" title="7">reqLogger.Info("Google OAuth callback received",
                zap.String("endpoint", "/oauth/google/callback"),
                zap.String("method", "GET"),
        )

        code := c.Query("code")
        state := c.Query("state")
        oauthError := c.Query("error")

        if oauthError != "" </span><span class="cov2" title="2">{
                reqLogger.AuthFailure("", state, "google_oauth", "oauth_error")
                reqLogger.OAuthFlow("google", "callback_error", state, fmt.Errorf("oauth error: %s", oauthError))

                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "oauth_error",
                        Message: "OAuth error: " + oauthError,
                })
                return
        }</span>

        <span class="cov5" title="5">if code == "" </span><span class="cov1" title="1">{
                reqLogger.AuthFailure("", state, "google_oauth", "missing_code")
                reqLogger.Error("Google OAuth callback failed - missing authorization code")

                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "missing_code",
                        Message: "Authorization code is required",
                })
                return
        }</span>

        <span class="cov4" title="4">reqLogger.Info("Google OAuth callback validation passed",
                zap.String("tenant_id", state),
                zap.String("code_prefix", func() string </span><span class="cov4" title="4">{
                        if len(code) &gt;= 10 </span><span class="cov3" title="3">{
                                return code[:10] + "..."
                        }</span>
                        <span class="cov1" title="1">return code + "..."</span>
                }()),
        )

        // TODO: Implement Google OAuth token exchange

        // Simulate token exchange
        <span class="cov4" title="4">tokenStart := time.Now()
        time.Sleep(50 * time.Millisecond) // Simulate Google API call
        reqLogger.DatabaseOperation("INSERT", "oauth_tokens", state, time.Since(tokenStart), nil)

        response := LoginResponse{
                AccessToken:  "google-oauth-token",
                RefreshToken: "google-refresh-token",
                TokenType:    "Bearer",
                ExpiresIn:    3600,
                User: User{
                        ID:       "google-user-123",
                        Email:    "user@gmail.com",
                        TenantID: state,
                        Roles: []Role{
                                {ID: "role-1", Name: "user"},
                        },
                },
        }

        // Log successful OAuth flow
        reqLogger.AuthSuccess("google-user-123", state, "google_oauth")
        reqLogger.OAuthFlow("google", "callback_success", state, nil)
        reqLogger.BusinessEvent("oauth_login_completed", "google-user-123", state, map[string]interface{}{
                "provider":    "google",
                "duration_ms": time.Since(start).Milliseconds(),
        })

        c.JSON(http.StatusOK, response)</span>
}

// ClientCredentialsRequest represents the OAuth 2.0 client credentials request
type ClientCredentialsRequest struct {
        GrantType    string `json:"grant_type" binding:"required" example:"client_credentials"`
        ClientID     string `json:"client_id" binding:"required" example:"service-client-123"`
        ClientSecret string `json:"client_secret" binding:"required" example:"service-secret-456"`
        Scope        string `json:"scope" example:"read:users write:users"`
}

// ClientCredentialsResponse represents the OAuth 2.0 client credentials response
type ClientCredentialsResponse struct {
        AccessToken string `json:"access_token" example:"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."`
        TokenType   string `json:"token_type" example:"Bearer"`
        ExpiresIn   int    `json:"expires_in" example:"3600"`
        Scope       string `json:"scope" example:"read:users write:users"`
}

// ClientCredentials godoc
// @Summary OAuth 2.0 Client Credentials Flow
// @Description Exchange client credentials for access token (service-to-service authentication)
// @Tags OAuth
// @Accept json
// @Produce json
// @Param request body ClientCredentialsRequest true "Client credentials"
// @Success 200 {object} ClientCredentialsResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /oauth/token [post]
func (h *OAuthHandler) ClientCredentials(c *gin.Context) <span class="cov5" title="7">{
        start := time.Now()

        // Safely get logger from context
        var reqLogger *logger.RequestLogger
        if loggerInterface := middleware.GetLogger(c); loggerInterface != nil </span><span class="cov5" title="7">{
                if reqLog, ok := loggerInterface.(*logger.RequestLogger); ok </span><span class="cov5" title="7">{
                        reqLogger = reqLog
                }</span>
        }

        // If no logger available, create a basic one
        <span class="cov5" title="7">if reqLogger == nil </span><span class="cov0" title="0">{
                reqLogger = h.logger.WithRequest(c.Request)
        }</span>

        <span class="cov5" title="7">reqLogger.Info("Client credentials flow initiated",
                zap.String("endpoint", "/oauth/token"),
                zap.String("method", "POST"),
        )

        var req ClientCredentialsRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov1" title="1">{
                reqLogger.Error("Client credentials validation failed", zap.Error(err))

                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "validation_error",
                        Message: err.Error(),
                })
                return
        }</span>

        <span class="cov5" title="6">reqLogger.Info("Client credentials validation passed",
                zap.String("client_id", req.ClientID),
                zap.String("grant_type", req.GrantType),
                zap.String("scope", req.Scope),
        )

        if req.GrantType != "client_credentials" </span><span class="cov1" title="1">{
                reqLogger.AuthFailure(req.ClientID, "", "client_credentials", "unsupported_grant_type")
                reqLogger.Error("Unsupported grant type", zap.String("grant_type", req.GrantType))

                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "unsupported_grant_type",
                        Message: "Only client_credentials grant type is supported",
                })
                return
        }</span>

        // TODO: Implement client credentials validation

        // Simulate client validation
        <span class="cov5" title="5">validationStart := time.Now()
        time.Sleep(20 * time.Millisecond) // Simulate client validation
        reqLogger.DatabaseOperation("SELECT", "oauth_clients", "", time.Since(validationStart), nil)

        response := ClientCredentialsResponse{
                AccessToken: "service-access-token",
                TokenType:   "Bearer",
                ExpiresIn:   3600,
                Scope:       req.Scope,
        }

        // Log successful client credentials flow
        reqLogger.AuthSuccess(req.ClientID, "", "client_credentials")
        reqLogger.BusinessEvent("client_credentials_success", req.ClientID, "", map[string]interface{}{
                "scope":       req.Scope,
                "duration_ms": time.Since(start).Milliseconds(),
        })

        c.JSON(http.StatusOK, response)</span>
}

// OneTimeTokenRequest represents the one-time token creation request
type OneTimeTokenRequest struct {
        URL           string `json:"url" binding:"required" example:"https://app.example.com/survey/123"`
        ExpiresIn     int    `json:"expires_in" example:"3600"`
        MaxUses       int    `json:"max_uses" example:"1"`
        SessionID     string `json:"session_id" example:"survey-session-456"` // Unique session identifier
        RefreshWindow int    `json:"refresh_window" example:"300"`            // Session refresh window in seconds
}

// OneTimeTokenResponse represents the one-time token response
type OneTimeTokenResponse struct {
        Token         string `json:"token" example:"one-time-token-123"`
        URL           string `json:"url" example:"https://app.example.com/survey/123?token=one-time-token-123&amp;session=survey-session-456"`
        ExpiresIn     int    `json:"expires_in" example:"3600"`
        MaxUses       int    `json:"max_uses" example:"1"`
        SessionID     string `json:"session_id" example:"survey-session-456"`
        RefreshWindow int    `json:"refresh_window" example:"300"`
}

// CreateOneTimeToken godoc
// @Summary Create one-time authentication token
// @Description Create a one-time token for secure access to specific URLs with session management
// @Tags OAuth
// @Accept json
// @Produce json
// @Param request body OneTimeTokenRequest true "One-time token request"
// @Success 200 {object} OneTimeTokenResponse
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /oauth/one-time [post]
func (h *OAuthHandler) CreateOneTimeToken(c *gin.Context) <span class="cov5" title="7">{
        start := time.Now()

        // Safely get logger from context
        var reqLogger *logger.RequestLogger
        if loggerInterface := middleware.GetLogger(c); loggerInterface != nil </span><span class="cov5" title="7">{
                if reqLog, ok := loggerInterface.(*logger.RequestLogger); ok </span><span class="cov5" title="7">{
                        reqLogger = reqLog
                }</span>
        }

        // If no logger available, create a basic one
        <span class="cov5" title="7">if reqLogger == nil </span><span class="cov0" title="0">{
                reqLogger = h.logger.WithRequest(c.Request)
        }</span>

        <span class="cov5" title="7">reqLogger.Info("One-time token creation initiated",
                zap.String("endpoint", "/oauth/one-time"),
                zap.String("method", "POST"),
        )

        var req OneTimeTokenRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov3" title="3">{
                reqLogger.Error("One-time token validation failed", zap.Error(err))

                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "validation_error",
                        Message: err.Error(),
                })
                return
        }</span>

        <span class="cov4" title="4">reqLogger.Info("One-time token validation passed",
                zap.String("url", req.URL),
                zap.String("session_id", req.SessionID),
                zap.Int("expires_in", req.ExpiresIn),
                zap.Int("max_uses", req.MaxUses),
        )

        // TODO: Implement one-time token creation

        // Simulate token creation
        tokenStart := time.Now()
        time.Sleep(15 * time.Millisecond) // Simulate token generation
        reqLogger.DatabaseOperation("INSERT", "one_time_tokens", "", time.Since(tokenStart), nil)

        // Use predictable token for tests, in production this would be cryptographically secure
        token := "one-time-token-123"
        tokenURL := req.URL
        if strings.Contains(tokenURL, "?") </span><span class="cov0" title="0">{
                tokenURL += "&amp;token=" + token + "&amp;session=" + req.SessionID
        }</span> else<span class="cov4" title="4"> {
                tokenURL += "?token=" + token + "&amp;session=" + req.SessionID
        }</span>

        // Set default values if not provided
        <span class="cov4" title="4">expiresIn := req.ExpiresIn
        maxUses := req.MaxUses
        refreshWindow := req.RefreshWindow
        if refreshWindow == 0 </span><span class="cov2" title="2">{
                refreshWindow = 300 // Default refresh window
        }</span>

        <span class="cov4" title="4">response := OneTimeTokenResponse{
                Token:         token,
                URL:           tokenURL,
                ExpiresIn:     expiresIn,
                MaxUses:       maxUses,
                SessionID:     req.SessionID,
                RefreshWindow: refreshWindow,
        }

        // Log successful one-time token creation
        reqLogger.BusinessEvent("one_time_token_created", "", "", map[string]interface{}{
                "session_id":  req.SessionID,
                "expires_in":  req.ExpiresIn,
                "max_uses":    req.MaxUses,
                "duration_ms": time.Since(start).Milliseconds(),
        })

        c.JSON(http.StatusCreated, response)</span>
}

// VerifyOneTimeToken godoc
// @Summary Verify one-time authentication token
// @Description Verify and refresh a one-time token session
// @Tags OAuth
// @Accept json
// @Produce json
// @Param token query string true "One-time token" example("one-time-token-123")
// @Param session query string true "Session ID" example("survey-session-456")
// @Success 200 {object} OneTimeSessionResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 410 {object} ErrorResponse
// @Router /oauth/verify [get]
func (h *OAuthHandler) VerifyOneTimeToken(c *gin.Context) <span class="cov5" title="7">{
        start := time.Now()

        // Safely get logger from context
        var reqLogger *logger.RequestLogger
        if loggerInterface := middleware.GetLogger(c); loggerInterface != nil </span><span class="cov5" title="7">{
                if reqLog, ok := loggerInterface.(*logger.RequestLogger); ok </span><span class="cov5" title="7">{
                        reqLogger = reqLog
                }</span>
        }

        // If no logger available, create a basic one
        <span class="cov5" title="7">if reqLogger == nil </span><span class="cov0" title="0">{
                reqLogger = h.logger.WithRequest(c.Request)
        }</span>

        <span class="cov5" title="7">reqLogger.Info("One-time token verification initiated",
                zap.String("endpoint", "/oauth/verify"),
                zap.String("method", "GET"),
        )

        token := c.Query("token")
        sessionID := c.Query("session")

        if token == "" </span><span class="cov1" title="1">{
                reqLogger.Error("One-time token verification failed - missing token")

                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "missing_token",
                        Message: "Token is required",
                })
                return
        }</span>

        <span class="cov5" title="6">if sessionID == "" </span><span class="cov1" title="1">{
                reqLogger.Error("One-time token verification failed - missing session ID")

                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "missing_session",
                        Message: "Session ID is required",
                })
                return
        }</span>

        <span class="cov5" title="5">reqLogger.Info("One-time token verification validation passed",
                zap.String("token_prefix", func() string </span><span class="cov5" title="5">{
                        if len(token) &gt;= 10 </span><span class="cov5" title="5">{
                                return token[:10] + "..."
                        }</span>
                        <span class="cov0" title="0">return token + "..."</span>
                }()),
                zap.String("session_id", sessionID),
        )

        // TODO: Implement one-time token verification with session refresh
        // 1. Check if token exists and is valid
        // 2. Verify session ID matches
        // 3. Check if token has been used (max uses)
        // 4. Check if token has expired
        // 5. Update lastActivity timestamp (session refresh)
        // 6. Check if session is still active (within refresh window)

        // Simulate token verification
        <span class="cov5" title="5">verifyStart := time.Now()
        time.Sleep(10 * time.Millisecond) // Simulate token verification
        reqLogger.DatabaseOperation("SELECT", "one_time_tokens", "", time.Since(verifyStart), nil)

        // Mock validation - in real implementation, check against cache/database
        if token != "one-time-token-123" || sessionID != "survey-session-456" </span><span class="cov2" title="2">{
                reqLogger.AuthFailure("", "", "one_time_token", "invalid_token")
                reqLogger.Error("One-time token verification failed - invalid token or session")

                c.JSON(http.StatusUnauthorized, ErrorResponse{
                        Error:   "invalid_token",
                        Message: "Invalid token or session combination",
                })
                return
        }</span>

        // Return session-specific user data with refresh info
        <span class="cov3" title="3">response := OneTimeSessionResponse{
                User: User{
                        ID:       "anonymous-user-123",
                        Email:    "anonymous@example.com",
                        TenantID: "tenant-123",
                        Roles: []Role{
                                {ID: "role-anonymous", Name: "anonymous"},
                        },
                },
                SessionID:     sessionID,
                Token:         token,
                IsValid:       true,
                LastActivity:  "2025-06-25T18:30:00Z",
                RefreshWindow: 300,
                Message:       "Session refreshed successfully. User is active.",
        }

        // Log successful token verification
        reqLogger.BusinessEvent("one_time_token_verified", "anonymous-user-123", "tenant-123", map[string]interface{}{
                "session_id":  sessionID,
                "is_valid":    true,
                "duration_ms": time.Since(start).Milliseconds(),
        })

        c.JSON(http.StatusOK, response)</span>
}

// RefreshSession godoc
// @Summary Refresh one-time session
// @Description Keep session alive by refreshing activity timestamp
// @Tags OAuth
// @Accept json
// @Produce json
// @Param token query string true "One-time token" example("one-time-token-123")
// @Param session query string true "Session ID" example("survey-session-456")
// @Success 200 {object} OneTimeSessionResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 410 {object} ErrorResponse
// @Router /oauth/refresh [post]
func (h *OAuthHandler) RefreshSession(c *gin.Context) <span class="cov5" title="6">{
        start := time.Now()

        // Safely get logger from context
        var reqLogger *logger.RequestLogger
        if loggerInterface := middleware.GetLogger(c); loggerInterface != nil </span><span class="cov5" title="6">{
                if reqLog, ok := loggerInterface.(*logger.RequestLogger); ok </span><span class="cov5" title="6">{
                        reqLogger = reqLog
                }</span>
        }

        // If no logger available, create a basic one
        <span class="cov5" title="6">if reqLogger == nil </span><span class="cov0" title="0">{
                reqLogger = h.logger.WithRequest(c.Request)
        }</span>

        <span class="cov5" title="6">reqLogger.Info("Session refresh initiated",
                zap.String("endpoint", "/oauth/refresh"),
                zap.String("method", "POST"),
        )

        token := c.Query("token")
        sessionID := c.Query("session")

        if token == "" || sessionID == "" </span><span class="cov3" title="3">{
                reqLogger.Error("Session refresh failed - missing parameters")

                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "missing_parameters",
                        Message: "Token and session ID are required",
                })
                return
        }</span>

        <span class="cov3" title="3">reqLogger.Info("Session refresh validation passed",
                zap.String("token_prefix", func() string </span><span class="cov3" title="3">{
                        if len(token) &gt;= 10 </span><span class="cov3" title="3">{
                                return token[:10] + "..."
                        }</span>
                        <span class="cov0" title="0">return token + "..."</span>
                }()),
                zap.String("session_id", sessionID),
        )

        // TODO: Implement session refresh logic
        // 1. Verify token is still valid
        // 2. Update lastActivity timestamp
        // 3. Check if session is within refresh window

        // Simulate session refresh
        <span class="cov3" title="3">refreshStart := time.Now()
        time.Sleep(8 * time.Millisecond) // Simulate session refresh
        reqLogger.DatabaseOperation("UPDATE", "one_time_sessions", "", time.Since(refreshStart), nil)

        // Mock response
        response := OneTimeSessionResponse{
                User: User{
                        ID:       "anonymous-user-123",
                        Email:    "anonymous@example.com",
                        TenantID: "tenant-123",
                        Roles: []Role{
                                {ID: "role-anonymous", Name: "anonymous"},
                        },
                },
                SessionID:     sessionID,
                Token:         token,
                IsValid:       true,
                LastActivity:  time.Now().Format(time.RFC3339),
                RefreshWindow: 300,
                Message:       "Session refreshed successfully",
        }

        // Log successful session refresh
        reqLogger.BusinessEvent("session_refreshed", "anonymous-user-123", "tenant-123", map[string]interface{}{
                "session_id":  sessionID,
                "duration_ms": time.Since(start).Milliseconds(),
        })

        c.JSON(http.StatusOK, response)</span>
}

// OneTimeSessionResponse represents the one-time session verification response
type OneTimeSessionResponse struct {
        User          User   `json:"user"`
        SessionID     string `json:"session_id" example:"survey-session-456"`
        Token         string `json:"token" example:"one-time-token-123"`
        IsValid       bool   `json:"is_valid" example:"true"`
        LastActivity  string `json:"last_activity" example:"2025-06-25T18:30:00Z"`
        RefreshWindow int    `json:"refresh_window" example:"300"`
        Message       string `json:"message" example:"Session refreshed successfully"`
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package logger

import (
        "auth-service/internal/config"
        "auth-service/internal/tracing"
        "context"
        "net/http"
        "os"
        "time"

        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

// Logger wraps zap.Logger with additional functionality
type Logger struct {
        *zap.Logger
}

// RequestLogger provides request-specific logging
type RequestLogger struct {
        *Logger
        requestID    string
        userID       string
        tenantID     string
        method       string
        path         string
        clientIP     string
        traceID      string
        spanID       string
        parentSpanID string
}

// NewLogger creates a new logger instance based on configuration
func NewLogger(cfg *config.LoggingConfig) (*Logger, error) <span class="cov8" title="4">{
        var level zapcore.Level
        if err := level.UnmarshalText([]byte(cfg.Level)); err != nil </span><span class="cov0" title="0">{
                level = zapcore.InfoLevel
        }</span>

        // Create encoder config
        <span class="cov8" title="4">encoderConfig := zap.NewProductionEncoderConfig()
        encoderConfig.TimeKey = "timestamp"
        encoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
        encoderConfig.EncodeLevel = zapcore.CapitalLevelEncoder
        encoderConfig.MessageKey = "message"
        encoderConfig.LevelKey = "level"
        encoderConfig.CallerKey = "caller"

        // Choose encoder based on format
        var encoder zapcore.Encoder
        if cfg.Format == "json" </span><span class="cov8" title="4">{
                encoder = zapcore.NewJSONEncoder(encoderConfig)
        }</span> else<span class="cov0" title="0"> {
                encoder = zapcore.NewConsoleEncoder(encoderConfig)
        }</span>

        // Choose output
        <span class="cov8" title="4">var writeSyncer zapcore.WriteSyncer
        if cfg.Output == "stdout" </span><span class="cov8" title="4">{
                writeSyncer = zapcore.AddSync(os.Stdout)
        }</span> else<span class="cov0" title="0"> {
                file, err := os.OpenFile(cfg.Output, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">writeSyncer = zapcore.AddSync(file)</span>
        }

        // Create core
        <span class="cov8" title="4">core := zapcore.NewCore(encoder, writeSyncer, level)

        // Create logger options
        opts := []zap.Option{
                zap.AddCaller(),
                zap.AddStacktrace(zapcore.ErrorLevel),
        }

        if cfg.IncludeCaller </span><span class="cov8" title="4">{
                opts = append(opts, zap.AddCallerSkip(1))
        }</span>

        <span class="cov8" title="4">if cfg.IncludeStacktrace </span><span class="cov8" title="4">{
                opts = append(opts, zap.AddStacktrace(zapcore.WarnLevel))
        }</span>

        <span class="cov8" title="4">logger := zap.New(core, opts...)
        return &amp;Logger{Logger: logger}, nil</span>
}

// WithRequest creates a request-specific logger
func (l *Logger) WithRequest(r *http.Request) *RequestLogger <span class="cov7" title="3">{
        // Extract tracing information
        traceCtx := tracing.ExtractTracingFromRequest(r)

        requestID := r.Header.Get("X-Request-ID")
        if requestID == "" </span><span class="cov4" title="2">{
                requestID = traceCtx.TraceID // Use trace ID as request ID if not provided
        }</span>

        <span class="cov7" title="3">userID := r.Header.Get("X-User-ID")
        tenantID := r.Header.Get("X-Tenant-ID")
        clientIP := getClientIP(r)

        return &amp;RequestLogger{
                Logger:       l,
                requestID:    requestID,
                userID:       userID,
                tenantID:     tenantID,
                method:       r.Method,
                path:         r.URL.Path,
                clientIP:     clientIP,
                traceID:      traceCtx.TraceID,
                spanID:       traceCtx.SpanID,
                parentSpanID: traceCtx.ParentSpanID,
        }</span>
}

// WithContext creates a logger with context values
func (l *Logger) WithContext(ctx context.Context) *RequestLogger <span class="cov0" title="0">{
        requestID := getFromContext(ctx, "request_id")
        userID := getFromContext(ctx, "user_id")
        tenantID := getFromContext(ctx, "tenant_id")
        method := getFromContext(ctx, "method")
        path := getFromContext(ctx, "path")
        clientIP := getFromContext(ctx, "client_ip")

        // Get tracing context from context
        traceCtx := tracing.GetTracingContextFromContext(ctx)

        return &amp;RequestLogger{
                Logger:       l,
                requestID:    requestID,
                userID:       userID,
                tenantID:     tenantID,
                method:       method,
                path:         path,
                clientIP:     clientIP,
                traceID:      traceCtx.TraceID,
                spanID:       traceCtx.SpanID,
                parentSpanID: traceCtx.ParentSpanID,
        }
}</span>

// RequestStart logs the start of a request
func (rl *RequestLogger) RequestStart() <span class="cov1" title="1">{
        rl.Info("Request started",
                zap.String("request_id", rl.requestID),
                zap.String("trace_id", rl.traceID),
                zap.String("span_id", rl.spanID),
                zap.String("parent_span_id", rl.parentSpanID),
                zap.String("method", rl.method),
                zap.String("path", rl.path),
                zap.String("client_ip", rl.clientIP),
                zap.String("user_id", rl.userID),
                zap.String("tenant_id", rl.tenantID),
        )
}</span>

// RequestEnd logs the end of a request with duration and status
func (rl *RequestLogger) RequestEnd(status int, duration time.Duration, err error) <span class="cov1" title="1">{
        fields := []zap.Field{
                zap.String("request_id", rl.requestID),
                zap.String("trace_id", rl.traceID),
                zap.String("span_id", rl.spanID),
                zap.String("parent_span_id", rl.parentSpanID),
                zap.String("method", rl.method),
                zap.String("path", rl.path),
                zap.String("client_ip", rl.clientIP),
                zap.String("user_id", rl.userID),
                zap.String("tenant_id", rl.tenantID),
                zap.Int("status", status),
                zap.Duration("duration", duration),
        }

        if err != nil </span><span class="cov0" title="0">{
                fields = append(fields, zap.Error(err))
                rl.Error("Request failed", fields...)
        }</span> else<span class="cov1" title="1"> {
                rl.Info("Request completed", fields...)
        }</span>
}

// AuthSuccess logs successful authentication
func (rl *RequestLogger) AuthSuccess(userID, tenantID, authMethod string) <span class="cov1" title="1">{
        rl.Info("Authentication successful",
                zap.String("request_id", rl.requestID),
                zap.String("trace_id", rl.traceID),
                zap.String("span_id", rl.spanID),
                zap.String("user_id", userID),
                zap.String("tenant_id", tenantID),
                zap.String("auth_method", authMethod),
                zap.String("client_ip", rl.clientIP),
        )
}</span>

// AuthFailure logs failed authentication
func (rl *RequestLogger) AuthFailure(userID, tenantID, authMethod, reason string) <span class="cov1" title="1">{
        rl.Warn("Authentication failed",
                zap.String("request_id", rl.requestID),
                zap.String("trace_id", rl.traceID),
                zap.String("span_id", rl.spanID),
                zap.String("user_id", userID),
                zap.String("tenant_id", tenantID),
                zap.String("auth_method", authMethod),
                zap.String("reason", reason),
                zap.String("client_ip", rl.clientIP),
        )
}</span>

// OAuthFlow logs OAuth flow events
func (rl *RequestLogger) OAuthFlow(provider, step, tenantID string, err error) <span class="cov1" title="1">{
        fields := []zap.Field{
                zap.String("request_id", rl.requestID),
                zap.String("trace_id", rl.traceID),
                zap.String("span_id", rl.spanID),
                zap.String("provider", provider),
                zap.String("step", step),
                zap.String("tenant_id", tenantID),
                zap.String("client_ip", rl.clientIP),
        }

        if err != nil </span><span class="cov0" title="0">{
                fields = append(fields, zap.Error(err))
                rl.Error("OAuth flow failed", fields...)
        }</span> else<span class="cov1" title="1"> {
                rl.Info("OAuth flow step completed", fields...)
        }</span>
}

// DatabaseOperation logs database operations
func (rl *RequestLogger) DatabaseOperation(operation, table, tenantID string, duration time.Duration, err error) <span class="cov1" title="1">{
        fields := []zap.Field{
                zap.String("request_id", rl.requestID),
                zap.String("trace_id", rl.traceID),
                zap.String("span_id", rl.spanID),
                zap.String("operation", operation),
                zap.String("table", table),
                zap.String("tenant_id", tenantID),
                zap.Duration("duration", duration),
        }

        if err != nil </span><span class="cov0" title="0">{
                fields = append(fields, zap.Error(err))
                rl.Error("Database operation failed", fields...)
        }</span> else<span class="cov1" title="1"> {
                rl.Debug("Database operation completed", fields...)
        }</span>
}

// CacheOperation logs cache operations
func (rl *RequestLogger) CacheOperation(operation, key, tenantID string, hit bool, duration time.Duration, err error) <span class="cov1" title="1">{
        fields := []zap.Field{
                zap.String("request_id", rl.requestID),
                zap.String("trace_id", rl.traceID),
                zap.String("span_id", rl.spanID),
                zap.String("operation", operation),
                zap.String("key", key),
                zap.String("tenant_id", tenantID),
                zap.Bool("cache_hit", hit),
                zap.Duration("duration", duration),
        }

        if err != nil </span><span class="cov0" title="0">{
                fields = append(fields, zap.Error(err))
                rl.Error("Cache operation failed", fields...)
        }</span> else<span class="cov1" title="1"> {
                rl.Debug("Cache operation completed", fields...)
        }</span>
}

// SecurityEvent logs security-related events
func (rl *RequestLogger) SecurityEvent(eventType, userID, tenantID, details string, severity string) <span class="cov1" title="1">{
        fields := []zap.Field{
                zap.String("request_id", rl.requestID),
                zap.String("trace_id", rl.traceID),
                zap.String("span_id", rl.spanID),
                zap.String("event_type", eventType),
                zap.String("user_id", userID),
                zap.String("tenant_id", tenantID),
                zap.String("details", details),
                zap.String("severity", severity),
                zap.String("client_ip", rl.clientIP),
        }

        switch severity </span>{
        case "high":<span class="cov0" title="0">
                rl.Logger.Error("Security event", fields...)</span>
        case "medium":<span class="cov1" title="1">
                rl.Logger.Warn("Security event", fields...)</span>
        case "low":<span class="cov0" title="0">
                rl.Logger.Info("Security event", fields...)</span>
        default:<span class="cov0" title="0">
                rl.Logger.Info("Security event", fields...)</span>
        }
}

// BusinessEvent logs business logic events
func (rl *RequestLogger) BusinessEvent(eventType, userID, tenantID string, data map[string]interface{}) <span class="cov1" title="1">{
        fields := []zap.Field{
                zap.String("request_id", rl.requestID),
                zap.String("trace_id", rl.traceID),
                zap.String("span_id", rl.spanID),
                zap.String("event_type", eventType),
                zap.String("user_id", userID),
                zap.String("tenant_id", tenantID),
                zap.String("client_ip", rl.clientIP),
        }

        for key, value := range data </span><span class="cov4" title="2">{
                fields = append(fields, zap.Any(key, value))
        }</span>

        <span class="cov1" title="1">rl.Logger.Info("Business event", fields...)</span>
}

// Error logs errors with request context
func (rl *RequestLogger) Error(msg string, fields ...zap.Field) <span class="cov1" title="1">{
        allFields := append([]zap.Field{
                zap.String("request_id", rl.requestID),
                zap.String("trace_id", rl.traceID),
                zap.String("span_id", rl.spanID),
                zap.String("method", rl.method),
                zap.String("path", rl.path),
                zap.String("client_ip", rl.clientIP),
        }, fields...)
        rl.Logger.Error(msg, allFields...)
}</span>

// Warn logs warnings with request context
func (rl *RequestLogger) Warn(msg string, fields ...zap.Field) <span class="cov4" title="2">{
        allFields := append([]zap.Field{
                zap.String("request_id", rl.requestID),
                zap.String("trace_id", rl.traceID),
                zap.String("span_id", rl.spanID),
                zap.String("method", rl.method),
                zap.String("path", rl.path),
                zap.String("client_ip", rl.clientIP),
        }, fields...)
        rl.Logger.Warn(msg, allFields...)
}</span>

// Info logs info messages with request context
func (rl *RequestLogger) Info(msg string, fields ...zap.Field) <span class="cov10" title="5">{
        allFields := append([]zap.Field{
                zap.String("request_id", rl.requestID),
                zap.String("trace_id", rl.traceID),
                zap.String("span_id", rl.spanID),
                zap.String("method", rl.method),
                zap.String("path", rl.path),
                zap.String("client_ip", rl.clientIP),
        }, fields...)
        rl.Logger.Info(msg, allFields...)
}</span>

// Debug logs debug messages with request context
func (rl *RequestLogger) Debug(msg string, fields ...zap.Field) <span class="cov7" title="3">{
        allFields := append([]zap.Field{
                zap.String("request_id", rl.requestID),
                zap.String("trace_id", rl.traceID),
                zap.String("span_id", rl.spanID),
                zap.String("method", rl.method),
                zap.String("path", rl.path),
                zap.String("client_ip", rl.clientIP),
        }, fields...)
        rl.Logger.Debug(msg, allFields...)
}</span>

// GetTraceID returns the trace ID for this request
func (rl *RequestLogger) GetTraceID() string <span class="cov0" title="0">{
        return rl.traceID
}</span>

// GetSpanID returns the span ID for this request
func (rl *RequestLogger) GetSpanID() string <span class="cov0" title="0">{
        return rl.spanID
}</span>

// Helper functions
func generateRequestID() string <span class="cov0" title="0">{
        return time.Now().Format("20060102150405") + "-" + randomString(8)
}</span>

func randomString(length int) string <span class="cov0" title="0">{
        const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
        b := make([]byte, length)
        for i := range b </span><span class="cov0" title="0">{
                b[i] = charset[time.Now().UnixNano()%int64(len(charset))]
        }</span>
        <span class="cov0" title="0">return string(b)</span>
}

func getClientIP(r *http.Request) string <span class="cov7" title="3">{
        // Check for forwarded headers
        if ip := r.Header.Get("X-Forwarded-For"); ip != "" </span><span class="cov0" title="0">{
                return ip
        }</span>
        <span class="cov7" title="3">if ip := r.Header.Get("X-Real-IP"); ip != "" </span><span class="cov0" title="0">{
                return ip
        }</span>
        <span class="cov7" title="3">return r.RemoteAddr</span>
}

func getFromContext(ctx context.Context, key string) string <span class="cov0" title="0">{
        if val, ok := ctx.Value(key).(string); ok </span><span class="cov0" title="0">{
                return val
        }</span>
        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package middleware

import (
        "auth-service/internal/actuator"
        "time"

        "github.com/gin-gonic/gin"
)

// ActuatorMiddleware creates middleware for tracking request metrics
func ActuatorMiddleware(act *actuator.Actuator) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                start := time.Now()

                // Track active request
                act.StartRequest(c.Request.Method, c.FullPath())

                // Process request
                c.Next()

                // Track request completion
                act.EndRequest(c.Request.Method, c.FullPath())

                // Record metrics
                duration := time.Since(start)
                status := c.Writer.Status()
                act.RecordRequest(c.Request.Method, c.FullPath(), status, duration)
        }</span>
}

// HealthCheckMiddleware creates middleware for health check endpoints
func HealthCheckMiddleware() gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                // Add cache headers for health check endpoints
                c.Header("Cache-Control", "no-cache, no-store, must-revalidate")
                c.Header("Pragma", "no-cache")
                c.Header("Expires", "0")

                c.Next()
        }</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package middleware

import (
        "auth-service/internal/logger"
        "auth-service/internal/tracing"
        "time"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

// LoggingMiddleware creates middleware for request-level logging
func LoggingMiddleware(log *logger.Logger) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                start := time.Now()

                // Create request-specific logger
                reqLogger := log.WithRequest(c.Request)

                // Log request start
                reqLogger.RequestStart()

                // Add logger to context for use in handlers
                c.Set("logger", reqLogger)

                // Process request
                c.Next()

                // Calculate duration
                duration := time.Since(start)

                // Get response status
                status := c.Writer.Status()

                // Check for errors
                var err error
                if len(c.Errors) &gt; 0 </span><span class="cov0" title="0">{
                        err = c.Errors.Last().Err
                }</span>

                // Add tracing headers to response
                <span class="cov0" title="0">traceCtx := &amp;tracing.TracingContext{
                        TraceID:      reqLogger.GetTraceID(),
                        SpanID:       reqLogger.GetSpanID(),
                        ParentSpanID: "", // This would be set if we had parent span info
                }
                tracing.AddTracingHeaders(c.Writer, traceCtx)

                // Log request end
                reqLogger.RequestEnd(status, duration, err)

                // Log additional request details for debugging
                if status &gt;= 400 </span><span class="cov0" title="0">{
                        reqLogger.Warn("Request resulted in error status",
                                zap.String("user_agent", c.Request.UserAgent()),
                                zap.String("referer", c.Request.Referer()),
                                zap.Int64("content_length", c.Request.ContentLength),
                        )
                }</span>
        }
}

// GetLogger retrieves the request logger from context
func GetLogger(c *gin.Context) interface{} <span class="cov0" title="0">{
        if logger, exists := c.Get("logger"); exists </span><span class="cov0" title="0">{
                return logger
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// SetUserContext adds user information to the request context for logging
func SetUserContext(c *gin.Context, userID, tenantID string) <span class="cov0" title="0">{
        // Note: This would need to be implemented in the logger package
        // For now, we'll just set the values in the request headers
        c.Request.Header.Set("X-User-ID", userID)
        c.Request.Header.Set("X-Tenant-ID", tenantID)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package middleware

import (
        "auth-service/internal/service"
        "net/http"

        "github.com/gin-gonic/gin"
)

// RBACMiddleware returns a Gin middleware that checks for required permission
func RBACMiddleware(rbac service.RBACService, permission string) gin.HandlerFunc <span class="cov9" title="9">{
        return func(c *gin.Context) </span><span class="cov10" title="11">{
                userID := c.GetString("user_id")
                tenantID := c.GetString("tenant_id")
                if userID == "" || tenantID == "" </span><span class="cov3" title="2">{
                        c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "missing user or tenant context"})
                        return
                }</span>
                <span class="cov9" title="9">hasPerm, err := rbac.UserHasPermission(c.Request.Context(), userID, permission, tenantID)
                if err != nil </span><span class="cov1" title="1">{
                        c.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{"error": "permission check failed"})
                        return
                }</span>
                <span class="cov8" title="8">if !hasPerm </span><span class="cov6" title="4">{
                        c.AbortWithStatusJSON(http.StatusForbidden, gin.H{"error": "forbidden"})
                        return
                }</span>
                <span class="cov6" title="4">c.Next()</span>
        }
}

// For gRPC, similar interceptor logic would be used.
</pre>
		
		<pre class="file" id="file11" style="display: none">package tracing

import (
        "context"
        "crypto/rand"
        "fmt"
        "net/http"
        "strings"
        "time"

        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/propagation"
        "go.opentelemetry.io/otel/trace"
)

const (
        // Standard tracing headers
        TraceIDHeader      = "X-Trace-ID"
        SpanIDHeader       = "X-Span-ID"
        ParentSpanIDHeader = "X-Parent-Span-ID"

        // Cloud-native tracing headers (AWS X-Ray, Google Cloud Trace, etc.)
        XRayTraceIDHeader = "X-Amzn-Trace-Id"
        CloudTraceHeader  = "X-Cloud-Trace-Context"

        // Response header for trace ID
        ResponseTraceIDHeader = "X-Req-ID"
)

// TracingContext holds tracing information
type TracingContext struct {
        TraceID      string
        SpanID       string
        ParentSpanID string
        IsSampled    bool
}

// ExtractTracingFromRequest extracts tracing information from HTTP request headers
func ExtractTracingFromRequest(r *http.Request) *TracingContext <span class="cov8" title="7">{
        // First, try to extract from OpenTelemetry context
        ctx := r.Context()
        span := trace.SpanFromContext(ctx)

        traceID := ""
        spanID := ""
        parentSpanID := ""
        isSampled := true // Default to true for sampling

        if span.SpanContext().IsValid() </span><span class="cov0" title="0">{
                traceID = span.SpanContext().TraceID().String()
                spanID = span.SpanContext().SpanID().String()
                isSampled = span.SpanContext().IsSampled()
        }</span>

        // If no OpenTelemetry context, try custom headers
        <span class="cov8" title="7">if traceID == "" </span><span class="cov8" title="7">{
                traceID = extractTraceIDFromHeaders(r)
        }</span>

        <span class="cov8" title="7">if spanID == "" </span><span class="cov8" title="7">{
                spanID = extractSpanIDFromHeaders(r)
        }</span>
        <span class="cov8" title="7">if spanID == "" </span><span class="cov6" title="4">{
                spanID = generateSpanID()
        }</span>

        <span class="cov8" title="7">parentSpanID = r.Header.Get(ParentSpanIDHeader)

        // If still no trace ID, generate one
        if traceID == "" </span><span class="cov1" title="1">{
                traceID = generateTraceID()
        }</span>

        // If no span ID, generate one
        <span class="cov8" title="7">if spanID == "" </span><span class="cov0" title="0">{
                spanID = generateSpanID()
        }</span>

        <span class="cov8" title="7">return &amp;TracingContext{
                TraceID:      traceID,
                SpanID:       spanID,
                ParentSpanID: parentSpanID,
                IsSampled:    isSampled,
        }</span>
}

// extractTraceIDFromHeaders extracts trace ID from various header formats
func extractTraceIDFromHeaders(r *http.Request) string <span class="cov8" title="7">{
        // Try standard trace ID header
        if traceID := r.Header.Get(TraceIDHeader); traceID != "" </span><span class="cov3" title="2">{
                return traceID
        }</span>

        // Try AWS X-Ray format
        <span class="cov7" title="5">if xrayTraceID := r.Header.Get(XRayTraceIDHeader); xrayTraceID != "" </span><span class="cov1" title="1">{
                return extractXRayTraceID(xrayTraceID)
        }</span>

        // Try Google Cloud Trace format
        <span class="cov6" title="4">if cloudTrace := r.Header.Get(CloudTraceHeader); cloudTrace != "" </span><span class="cov1" title="1">{
                return extractCloudTraceID(cloudTrace)
        }</span>

        // Try request ID as fallback
        <span class="cov5" title="3">if reqID := r.Header.Get("X-Request-ID"); reqID != "" </span><span class="cov3" title="2">{
                return reqID
        }</span>

        <span class="cov1" title="1">return ""</span>
}

// extractSpanIDFromHeaders extracts span ID from headers
func extractSpanIDFromHeaders(r *http.Request) string <span class="cov8" title="7">{
        if spanID := r.Header.Get(SpanIDHeader); spanID != "" </span><span class="cov3" title="2">{
                return spanID
        }</span>

        // Try to extract from AWS X-Ray
        <span class="cov7" title="5">if xrayTraceID := r.Header.Get(XRayTraceIDHeader); xrayTraceID != "" </span><span class="cov1" title="1">{
                return extractXRaySpanID(xrayTraceID)
        }</span>

        <span class="cov6" title="4">return ""</span>
}

// extractXRayTraceID extracts trace ID from AWS X-Ray format
// Format: Root=1-5759e988-bd862e3fe1be46a994272793;Parent=53995c3f42cd8ad8;Sampled=1
func extractXRayTraceID(xrayHeader string) string <span class="cov7" title="5">{
        parts := strings.Split(xrayHeader, ";")
        for _, part := range parts </span><span class="cov7" title="5">{
                if strings.HasPrefix(part, "Root=") </span><span class="cov5" title="3">{
                        root := strings.TrimPrefix(part, "Root=")
                        // X-Ray trace ID format: 1-5759e988-bd862e3fe1be46a994272793
                        // We'll use the full root as trace ID
                        return root
                }</span>
        }
        <span class="cov3" title="2">return ""</span>
}

// extractXRaySpanID extracts span ID from AWS X-Ray format
func extractXRaySpanID(xrayHeader string) string <span class="cov6" title="4">{
        parts := strings.Split(xrayHeader, ";")
        for _, part := range parts </span><span class="cov8" title="7">{
                if strings.HasPrefix(part, "Parent=") </span><span class="cov3" title="2">{
                        return strings.TrimPrefix(part, "Parent=")
                }</span>
        }
        <span class="cov3" title="2">return ""</span>
}

// extractCloudTraceID extracts trace ID from Google Cloud Trace format
// Format: 105445aa7843bc8bf206b12000100000/0;o=1
func extractCloudTraceID(cloudTraceHeader string) string <span class="cov7" title="5">{
        parts := strings.Split(cloudTraceHeader, "/")
        if len(parts) &gt; 0 </span><span class="cov7" title="5">{
                return parts[0]
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// generateTraceID generates a new trace ID
func generateTraceID() string <span class="cov6" title="4">{
        // Generate a 32-character hex string (16 bytes)
        // This follows the W3C trace context specification
        return fmt.Sprintf("%032x", generateRandomBytes(16))
}</span>

// generateSpanID generates a new span ID
func generateSpanID() string <span class="cov8" title="7">{
        // Generate a 16-character hex string (8 bytes)
        return fmt.Sprintf("%016x", generateRandomBytes(8))
}</span>

// generateRandomBytes generates random bytes for trace/span IDs
func generateRandomBytes(n int) []byte <span class="cov10" title="11">{
        bytes := make([]byte, n)
        _, err := rand.Read(bytes)
        if err != nil </span><span class="cov0" title="0">{
                // Fallback to timestamp-based generation if crypto/rand fails
                timestamp := time.Now().UnixNano()
                for i := range bytes </span><span class="cov0" title="0">{
                        bytes[i] = byte((timestamp &gt;&gt; (i * 8)) &amp; 0xFF)
                }</span>
        }
        <span class="cov10" title="11">return bytes</span>
}

// AddTracingHeaders adds tracing headers to HTTP response
func AddTracingHeaders(w http.ResponseWriter, traceCtx *TracingContext) <span class="cov1" title="1">{
        w.Header().Set(ResponseTraceIDHeader, traceCtx.TraceID)
        w.Header().Set(TraceIDHeader, traceCtx.TraceID)
        w.Header().Set(SpanIDHeader, traceCtx.SpanID)
}</span>

// CreateSpan creates a new span with the given name and context
func CreateSpan(ctx context.Context, name string, traceCtx *TracingContext) (context.Context, trace.Span) <span class="cov1" title="1">{
        tracer := otel.Tracer("auth-service")

        // Create span context from trace ID and span ID
        spanCtx := createSpanContext(traceCtx)

        // Create span with the extracted context
        return tracer.Start(spanCtx, name)
}</span>

// createSpanContext creates a span context from trace and span IDs
func createSpanContext(traceCtx *TracingContext) context.Context <span class="cov1" title="1">{
        // Create a context with the trace ID as a value
        ctx := context.WithValue(context.Background(), "trace_id", traceCtx.TraceID)
        ctx = context.WithValue(ctx, "span_id", traceCtx.SpanID)

        return ctx
}</span>

// PropagateTracing propagates tracing context to outgoing requests
func PropagateTracing(ctx context.Context, req *http.Request) <span class="cov1" title="1">{
        // Use OpenTelemetry propagator to inject tracing context
        propagator := otel.GetTextMapPropagator()
        propagator.Inject(ctx, propagation.HeaderCarrier(req.Header))
}</span>

// GetTracingContextFromContext extracts tracing context from Go context
func GetTracingContextFromContext(ctx context.Context) *TracingContext <span class="cov3" title="2">{
        traceID, _ := ctx.Value("trace_id").(string)
        spanID, _ := ctx.Value("span_id").(string)

        if traceID == "" </span><span class="cov1" title="1">{
                traceID = generateTraceID()
        }</span>
        <span class="cov3" title="2">if spanID == "" </span><span class="cov1" title="1">{
                spanID = generateSpanID()
        }</span>

        <span class="cov3" title="2">return &amp;TracingContext{
                TraceID:   traceID,
                SpanID:    spanID,
                IsSampled: true,
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
