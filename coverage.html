
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>server: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">auth-service/cmd/server/main.go (12.7%)</option>
				
				<option value="file1">auth-service/docs/docs.go (100.0%)</option>
				
				<option value="file2">auth-service/internal/actuator/actuator.go (98.9%)</option>
				
				<option value="file3">auth-service/internal/actuator/health_checks.go (89.3%)</option>
				
				<option value="file4">auth-service/internal/config/config.go (90.2%)</option>
				
				<option value="file5">auth-service/internal/config/service_config.go (0.0%)</option>
				
				<option value="file6">auth-service/internal/handler/rest/auth_handler.go (85.3%)</option>
				
				<option value="file7">auth-service/internal/handler/rest/mfa_handler.go (0.0%)</option>
				
				<option value="file8">auth-service/internal/handler/rest/oauth_handler.go (94.8%)</option>
				
				<option value="file9">auth-service/internal/handler/rest/otp_handler.go (0.0%)</option>
				
				<option value="file10">auth-service/internal/handler/rest/tenant_auth_handler.go (0.0%)</option>
				
				<option value="file11">auth-service/internal/handler/rest/tenant_handler.go (0.0%)</option>
				
				<option value="file12">auth-service/internal/handler/rest/two_factor_handler.go (0.0%)</option>
				
				<option value="file13">auth-service/internal/logger/logger.go (62.7%)</option>
				
				<option value="file14">auth-service/internal/middleware/actuator_middleware.go (100.0%)</option>
				
				<option value="file15">auth-service/internal/middleware/logging_middleware.go (0.0%)</option>
				
				<option value="file16">auth-service/internal/middleware/rbac_middleware.go (100.0%)</option>
				
				<option value="file17">auth-service/internal/middleware/tenant_middleware.go (0.0%)</option>
				
				<option value="file18">auth-service/internal/models/errors.go (0.0%)</option>
				
				<option value="file19">auth-service/internal/service/mfa_service.go (0.0%)</option>
				
				<option value="file20">auth-service/internal/service/notification_client.go (6.9%)</option>
				
				<option value="file21">auth-service/internal/service/otp_service.go (57.3%)</option>
				
				<option value="file22">auth-service/internal/service/subscription_client.go (7.1%)</option>
				
				<option value="file23">auth-service/internal/service/tenant_service.go (0.0%)</option>
				
				<option value="file24">auth-service/internal/tracing/tracing.go (89.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"
        "log"
        "net/http"
        "strings"

        "auth-service/internal/actuator"
        "auth-service/internal/config"
        rest "auth-service/internal/handler/rest"
        "auth-service/internal/logger"
        "auth-service/internal/middleware"

        "github.com/gin-gonic/gin"
        swaggerFiles "github.com/swaggo/files"
        ginSwagger "github.com/swaggo/gin-swagger"
        "go.uber.org/zap"

        // Swagger documentation
        _ "auth-service/docs"
)

// @title           Multi-Tenant OAuth Service API
// @version         1.0
// @description     A comprehensive OAuth 2.0 service with multi-tenancy, Google OAuth, and service-to-service authentication.
// @termsOfService  http://swagger.io/terms/

// @contact.name   API Support
// @contact.url    http://www.swagger.io/support
// @contact.email  support@swagger.io

// @license.name  MIT
// @license.url   https://opensource.org/licenses/MIT

// @host      localhost:8080
// @BasePath  /api/v1

// @securityDefinitions.apikey BearerAuth
// @in header
// @name Authorization
// @description Type "Bearer" followed by a space and JWT token.

// @securityDefinitions.oauth2.application OAuth2ClientCredentials
// @tokenUrl /api/v1/oauth/token
// @scope.read "Read access"
// @scope.write "Write access"
// @scope.admin "Admin access"

// @tag.name Authentication
// @tag.description Authentication and authorization endpoints

// @tag.name OAuth
// @tag.description OAuth 2.0 flow endpoints

// @tag.name Tenants
// @tag.description Multi-tenant management endpoints

// @tag.name RBAC
// @tag.description Role-based access control endpoints

// @tag.name Services
// @tag.description Service-to-service authentication endpoints

// ipAllowlistMiddleware allows only requests from allowed IPs
func ipAllowlistMiddleware(allowedIPs []string) gin.HandlerFunc <span class="cov8" title="24">{
        return func(c *gin.Context) </span><span class="cov8" title="32">{
                clientIP := c.ClientIP()
                for _, ip := range allowedIPs </span><span class="cov10" title="55">{
                        if strings.HasPrefix(clientIP, ip) </span><span class="cov7" title="16">{
                                c.Next()
                                return
                        }</span>
                }
                <span class="cov7" title="16">c.AbortWithStatusJSON(http.StatusForbidden, gin.H{"error": "forbidden: internal access only"})</span>
        }
}

func main() <span class="cov0" title="0">{
        // Load configuration
        cfg, err := config.LoadConfig("configs/config.yaml")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to load config: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Loaded config: %+v\n", cfg.Server)

        // Initialize logger
        appLogger, err := logger.NewLogger(&amp;cfg.Logging)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to initialize logger: %v", err)
        }</span>

        // Log application startup
        <span class="cov0" title="0">appLogger.Info("Application starting",
                zap.String("version", "1.0.0"),
                zap.String("environment", "development"),
                zap.Int("port", cfg.Server.Port),
        )

        // Create actuator
        appInfo := &amp;actuator.AppInfo{
                Name:        "auth-service",
                Version:     "1.0.0",
                Description: "Multi-Tenant OAuth Service",
                BuildTime:   "2024-01-01T00:00:00Z",
                GitCommit:   "development",
                Environment: "development",
                Properties: map[string]string{
                        "server.port":   fmt.Sprintf("%d", cfg.Server.Port),
                        "database.host": cfg.Database.Host,
                        "redis.host":    cfg.Redis.Host,
                },
        }

        act := actuator.NewActuator(appInfo)

        // Register health checks
        act.RegisterHealthCheck("memory", actuator.MemoryHealthCheck(90))
        act.RegisterHealthCheck("goroutines", actuator.GoroutineHealthCheck(1000))
        act.RegisterHealthCheck("disk", actuator.DiskSpaceHealthCheck(1))

        // Register readiness checks (these would be added when DB/Redis are connected)
        // act.RegisterReadinessCheck("database", actuator.DatabaseHealthCheck(db))
        // act.RegisterReadinessCheck("redis", actuator.RedisHealthCheck(redisClient))

        // Set up Gin
        gin.SetMode(gin.ReleaseMode)
        r := gin.New()
        r.Use(gin.Recovery())

        // Add logging middleware
        r.Use(middleware.LoggingMiddleware(appLogger))

        // Register actuator routes
        act.RegisterRoutes(r)

        // Add actuator middleware for metrics tracking
        r.Use(middleware.ActuatorMiddleware(act))

        // Register REST handlers
        authHandler := rest.NewAuthHandler(cfg)
        oauthHandler := rest.NewOAuthHandler(cfg)

        api := r.Group("/api/v1")
        </span><span class="cov0" title="0">{
                auth := api.Group("/auth")
                auth.POST("/login", authHandler.Login)
                auth.POST("/register", authHandler.Register)
                auth.POST("/refresh", authHandler.RefreshToken)
                auth.POST("/logout", authHandler.Logout)

                oauth := api.Group("/oauth")
                oauth.GET("/google/login", oauthHandler.GoogleLogin)
                oauth.GET("/google/callback", oauthHandler.GoogleCallback)
                oauth.POST("/token", oauthHandler.ClientCredentials)
                oauth.POST("/one-time", oauthHandler.CreateOneTimeToken)
                oauth.GET("/verify", oauthHandler.VerifyOneTimeToken)
                oauth.POST("/refresh", oauthHandler.RefreshSession)
        }</span>

        // Swagger UI - internal only (localhost)
        <span class="cov0" title="0">allowedIPs := []string{"127.0.0.1", "::1"}
        r.GET("/swagger/*any", ipAllowlistMiddleware(allowedIPs), ginSwagger.WrapHandler(swaggerFiles.Handler))

        // Start server
        addr := fmt.Sprintf("%s:%d", cfg.Server.Host, cfg.Server.Port)
        fmt.Printf("Starting server on %s\n", addr)
        fmt.Printf("Actuator endpoints available at:\n")
        fmt.Printf("  Health: http://%s/actuator/health\n", addr)
        fmt.Printf("  Metrics: http://%s/actuator/metrics\n", addr)
        fmt.Printf("  Prometheus: http://%s/actuator/prometheus\n", addr)
        fmt.Printf("  Info: http://%s/actuator/info\n", addr)

        appLogger.Info("Server starting", zap.String("address", addr))

        if err := r.Run(addr); err != nil </span><span class="cov0" title="0">{
                appLogger.Error("Server failed to start", zap.Error(err))
                log.Fatalf("failed to start server: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "termsOfService": "http://swagger.io/terms/",
        "contact": {
            "name": "API Support",
            "url": "http://www.swagger.io/support",
            "email": "support@swagger.io"
        },
        "license": {
            "name": "MIT",
            "url": "https://opensource.org/licenses/MIT"
        },
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/auth/login": {
            "post": {
                "description": "Authenticate a user with email and password",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Authentication"
                ],
                "summary": "User login",
                "parameters": [
                    {
                        "description": "Login credentials",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/rest.LoginRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/rest.LoginResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/auth/logout": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Logout a user and invalidate their tokens",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Authentication"
                ],
                "summary": "User logout",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/rest.SuccessResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/auth/refresh": {
            "post": {
                "description": "Refresh an expired access token using a refresh token",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Authentication"
                ],
                "summary": "Refresh access token",
                "parameters": [
                    {
                        "description": "Refresh token",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/rest.RefreshTokenRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/rest.LoginResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/auth/register": {
            "post": {
                "description": "Register a new user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Authentication"
                ],
                "summary": "User registration",
                "parameters": [
                    {
                        "description": "Registration data",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/rest.RegisterRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/rest.User"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    },
                    "409": {
                        "description": "Conflict",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/oauth/complete": {
            "post": {
                "description": "Mark a one-time session as completed (e.g., survey submitted) and invalidate the token",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "OAuth"
                ],
                "summary": "Complete one-time session",
                "parameters": [
                    {
                        "type": "string",
                        "example": "\"one-time-token-123\"",
                        "description": "One-time token",
                        "name": "token",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "string",
                        "example": "\"survey-session-456\"",
                        "description": "Session ID",
                        "name": "session",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "string",
                        "example": "\"survey-submit-page\"",
                        "description": "Page ID",
                        "name": "page",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/rest.SuccessResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    },
                    "410": {
                        "description": "Gone",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/oauth/google/callback": {
            "get": {
                "description": "Handle Google OAuth callback and exchange code for tokens",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "OAuth"
                ],
                "summary": "Google OAuth callback",
                "parameters": [
                    {
                        "type": "string",
                        "example": "\"4/0AfJohXn...\"",
                        "description": "Authorization code from Google",
                        "name": "code",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "string",
                        "example": "\"tenant-123\"",
                        "description": "State parameter",
                        "name": "state",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "string",
                        "example": "\"access_denied\"",
                        "description": "Error from Google OAuth",
                        "name": "error",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/rest.LoginResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/oauth/google/login": {
            "get": {
                "description": "Redirect user to Google OAuth for authentication",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "OAuth"
                ],
                "summary": "Initiate Google OAuth login",
                "parameters": [
                    {
                        "type": "string",
                        "example": "\"tenant-123\"",
                        "description": "Tenant ID",
                        "name": "tenant_id",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "string",
                        "example": "\"https://app.example.com/callback\"",
                        "description": "Custom redirect URI",
                        "name": "redirect_uri",
                        "in": "query"
                    }
                ],
                "responses": {
                    "302": {
                        "description": "Redirect to Google OAuth",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/oauth/one-time": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Create a one-time token for secure access to specific URLs with session and page restrictions",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "OAuth"
                ],
                "summary": "Create one-time authentication token",
                "parameters": [
                    {
                        "description": "One-time token parameters",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/rest.OneTimeTokenRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/rest.OneTimeTokenResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/oauth/token": {
            "post": {
                "description": "Exchange client credentials for access token (service-to-service authentication)",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "OAuth"
                ],
                "summary": "OAuth 2.0 Client Credentials Flow",
                "parameters": [
                    {
                        "description": "Client credentials",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/rest.ClientCredentialsRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/rest.ClientCredentialsResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/oauth/verify": {
            "get": {
                "description": "Verify and consume a one-time token with session and page validation",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "OAuth"
                ],
                "summary": "Verify one-time authentication token",
                "parameters": [
                    {
                        "type": "string",
                        "example": "\"one-time-token-123\"",
                        "description": "One-time token",
                        "name": "token",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "string",
                        "example": "\"survey-session-456\"",
                        "description": "Session ID",
                        "name": "session",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "string",
                        "example": "\"survey-submit-page\"",
                        "description": "Page ID",
                        "name": "page",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/rest.OneTimeSessionResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    },
                    "410": {
                        "description": "Gone",
                        "schema": {
                            "$ref": "#/definitions/rest.ErrorResponse"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "rest.ClientCredentialsRequest": {
            "type": "object",
            "required": [
                "client_id",
                "client_secret",
                "grant_type"
            ],
            "properties": {
                "client_id": {
                    "type": "string",
                    "example": "service-client-123"
                },
                "client_secret": {
                    "type": "string",
                    "example": "service-secret-456"
                },
                "grant_type": {
                    "type": "string",
                    "example": "client_credentials"
                },
                "scope": {
                    "type": "string",
                    "example": "read:users write:users"
                }
            }
        },
        "rest.ClientCredentialsResponse": {
            "type": "object",
            "properties": {
                "access_token": {
                    "type": "string",
                    "example": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
                },
                "expires_in": {
                    "type": "integer",
                    "example": 3600
                },
                "scope": {
                    "type": "string",
                    "example": "read:users write:users"
                },
                "token_type": {
                    "type": "string",
                    "example": "Bearer"
                }
            }
        },
        "rest.ErrorResponse": {
            "type": "object",
            "properties": {
                "error": {
                    "type": "string",
                    "example": "validation_error"
                },
                "message": {
                    "type": "string",
                    "example": "Invalid request data"
                }
            }
        },
        "rest.LoginRequest": {
            "type": "object",
            "required": [
                "email",
                "password",
                "tenant_id"
            ],
            "properties": {
                "email": {
                    "type": "string",
                    "example": "user@example.com"
                },
                "password": {
                    "type": "string",
                    "example": "password123"
                },
                "tenant_id": {
                    "type": "string",
                    "example": "tenant-123"
                }
            }
        },
        "rest.LoginResponse": {
            "type": "object",
            "properties": {
                "access_token": {
                    "type": "string",
                    "example": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
                },
                "expires_in": {
                    "type": "integer",
                    "example": 3600
                },
                "refresh_token": {
                    "type": "string",
                    "example": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
                },
                "token_type": {
                    "type": "string",
                    "example": "Bearer"
                },
                "user": {
                    "$ref": "#/definitions/rest.User"
                }
            }
        },
        "rest.OneTimeSessionResponse": {
            "type": "object",
            "properties": {
                "is_valid": {
                    "type": "boolean",
                    "example": true
                },
                "message": {
                    "type": "string",
                    "example": "Token validated successfully"
                },
                "page_id": {
                    "type": "string",
                    "example": "survey-submit-page"
                },
                "session_id": {
                    "type": "string",
                    "example": "survey-session-456"
                },
                "token": {
                    "type": "string",
                    "example": "one-time-token-123"
                },
                "user": {
                    "$ref": "#/definitions/rest.User"
                }
            }
        },
        "rest.OneTimeTokenRequest": {
            "type": "object",
            "required": [
                "url"
            ],
            "properties": {
                "expires_in": {
                    "type": "integer",
                    "example": 3600
                },
                "max_uses": {
                    "type": "integer",
                    "example": 1
                },
                "page_id": {
                    "description": "Specific page/action identifier",
                    "type": "string",
                    "example": "survey-submit-page"
                },
                "session_id": {
                    "description": "Unique session identifier",
                    "type": "string",
                    "example": "survey-session-456"
                },
                "url": {
                    "type": "string",
                    "example": "https://app.example.com/survey/123"
                }
            }
        },
        "rest.OneTimeTokenResponse": {
            "type": "object",
            "properties": {
                "expires_in": {
                    "type": "integer",
                    "example": 3600
                },
                "max_uses": {
                    "type": "integer",
                    "example": 1
                },
                "page_id": {
                    "type": "string",
                    "example": "survey-submit-page"
                },
                "session_id": {
                    "type": "string",
                    "example": "survey-session-456"
                },
                "token": {
                    "type": "string",
                    "example": "one-time-token-123"
                },
                "url": {
                    "type": "string",
                    "example": "https://app.example.com/survey/123?token=one-time-token-123\u0026session=survey-session-456\u0026page=survey-submit-page"
                }
            }
        },
        "rest.RefreshTokenRequest": {
            "type": "object",
            "required": [
                "refresh_token"
            ],
            "properties": {
                "refresh_token": {
                    "type": "string",
                    "example": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
                }
            }
        },
        "rest.RegisterRequest": {
            "type": "object",
            "required": [
                "email",
                "first_name",
                "last_name",
                "password",
                "tenant_id"
            ],
            "properties": {
                "email": {
                    "type": "string",
                    "example": "user@example.com"
                },
                "first_name": {
                    "type": "string",
                    "example": "John"
                },
                "last_name": {
                    "type": "string",
                    "example": "Doe"
                },
                "password": {
                    "type": "string",
                    "example": "password123"
                },
                "tenant_id": {
                    "type": "string",
                    "example": "tenant-123"
                }
            }
        },
        "rest.Role": {
            "type": "object",
            "properties": {
                "id": {
                    "type": "string",
                    "example": "role-123"
                },
                "name": {
                    "type": "string",
                    "example": "admin"
                }
            }
        },
        "rest.SuccessResponse": {
            "type": "object",
            "properties": {
                "message": {
                    "type": "string",
                    "example": "Operation completed successfully"
                }
            }
        },
        "rest.User": {
            "type": "object",
            "properties": {
                "email": {
                    "type": "string",
                    "example": "user@example.com"
                },
                "id": {
                    "type": "string",
                    "example": "user-123"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/rest.Role"
                    }
                },
                "tenant_id": {
                    "type": "string",
                    "example": "tenant-123"
                }
            }
        }
    },
    "securityDefinitions": {
        "BearerAuth": {
            "description": "Type \"Bearer\" followed by a space and JWT token.",
            "type": "apiKey",
            "name": "Authorization",
            "in": "header"
        },
        "OAuth2ClientCredentials": {
            "type": "oauth2",
            "flow": "application",
            "tokenUrl": "/api/v1/oauth/token",
            "scopes": {
                "admin": "\"Admin access\"",
                "read": "\"Read access\"",
                "write": "\"Write access\""
            }
        }
    },
    "tags": [
        {
            "description": "Authentication and authorization endpoints",
            "name": "Authentication"
        },
        {
            "description": "OAuth 2.0 flow endpoints",
            "name": "OAuth"
        },
        {
            "description": "Multi-tenant management endpoints",
            "name": "Tenants"
        },
        {
            "description": "Role-based access control endpoints",
            "name": "RBAC"
        },
        {
            "description": "Service-to-service authentication endpoints",
            "name": "Services"
        }
    ]
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "localhost:8080",
        BasePath:         "/api/v1",
        Schemes:          []string{},
        Title:            "Multi-Tenant OAuth Service API",
        Description:      "A comprehensive OAuth 2.0 service with multi-tenancy, Google OAuth, and service-to-service authentication.",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov8" title="1">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package actuator

import (
        "auth-service/internal/config"
        "auth-service/internal/logger"
        "net/http"
        "runtime"
        "sync"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/heptiolabs/healthcheck"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promhttp"
        "go.uber.org/zap"
)

// Actuator provides health checks, metrics, and operational endpoints
type Actuator struct {
        appInfo         *AppInfo
        health          healthcheck.Handler
        registry        *prometheus.Registry
        startTime       time.Time
        requestCount    *prometheus.CounterVec
        requestDuration *prometheus.HistogramVec
        activeRequests  *prometheus.GaugeVec
        logger          *logger.Logger
        mu              sync.RWMutex
        healthChecks    map[string]healthcheck.Check
        readinessChecks map[string]healthcheck.Check
}

// AppInfo contains application metadata
type AppInfo struct {
        Name        string            `json:"name"`
        Version     string            `json:"version"`
        Description string            `json:"description"`
        BuildTime   string            `json:"buildTime"`
        GitCommit   string            `json:"gitCommit"`
        Environment string            `json:"environment"`
        Properties  map[string]string `json:"properties,omitempty"`
}

// NewActuator creates a new actuator instance
func NewActuator(appInfo *AppInfo) *Actuator <span class="cov10" title="33">{
        // Initialize logger for actuator
        appLogger, err := logger.NewLogger(&amp;config.LoggingConfig{
                Level:             "info",
                Format:            "json",
                Output:            "stdout",
                IncludeCaller:     true,
                IncludeStacktrace: true,
        })
        if err != nil </span><span class="cov0" title="0">{
                // Fallback to default logger if initialization fails
                appLogger = &amp;logger.Logger{}
        }</span>

        <span class="cov10" title="33">registry := prometheus.NewRegistry()

        // Create metrics
        requestCount := prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "http_requests_total",
                        Help: "Total number of HTTP requests",
                },
                []string{"method", "endpoint", "status"},
        )

        requestDuration := prometheus.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "http_request_duration_seconds",
                        Help:    "HTTP request duration in seconds",
                        Buckets: prometheus.DefBuckets,
                },
                []string{"method", "endpoint"},
        )

        activeRequests := prometheus.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "http_requests_active",
                        Help: "Number of active HTTP requests",
                },
                []string{"method", "endpoint"},
        )

        // Register metrics
        registry.MustRegister(requestCount, requestDuration, activeRequests)

        // Create health check handler
        health := healthcheck.NewHandler()

        return &amp;Actuator{
                appInfo:         appInfo,
                health:          health,
                registry:        registry,
                startTime:       time.Now(),
                requestCount:    requestCount,
                requestDuration: requestDuration,
                activeRequests:  activeRequests,
                logger:          appLogger,
                healthChecks:    make(map[string]healthcheck.Check),
                readinessChecks: make(map[string]healthcheck.Check),
        }</span>
}

// RegisterHealthCheck registers a health check with a name
func (a *Actuator) RegisterHealthCheck(name string, check healthcheck.Check) <span class="cov1" title="1">{
        a.health.AddLivenessCheck(name, check)
        a.logger.Info("Health check registered", zap.String("name", name))
}</span>

// RegisterReadinessCheck registers a readiness check with a name
func (a *Actuator) RegisterReadinessCheck(name string, check healthcheck.Check) <span class="cov1" title="1">{
        a.health.AddReadinessCheck(name, check)
        a.logger.Info("Readiness check registered", zap.String("name", name))
}</span>

// RegisterRoutes registers all actuator endpoints
func (a *Actuator) RegisterRoutes(router *gin.Engine) <span class="cov8" title="19">{
        actuator := router.Group("/actuator")
        </span><span class="cov8" title="19">{
                // Health endpoints
                actuator.GET("/health", a.Health)
                actuator.GET("/health/live", a.Liveness)
                actuator.GET("/health/ready", a.Readiness)

                // Info endpoints
                actuator.GET("/info", a.Info)
                actuator.GET("/env", a.Environment)

                // Metrics endpoints
                actuator.GET("/metrics", a.Metrics)
                actuator.GET("/prometheus", a.PrometheusMetrics)

                // Operational endpoints
                actuator.GET("/status", a.Status)
                actuator.GET("/uptime", a.Uptime)
                actuator.GET("/threaddump", a.ThreadDump)
                actuator.GET("/heapdump", a.HeapDump)

                // Configuration endpoints
                actuator.GET("/configprops", a.ConfigProps)
                actuator.GET("/mappings", a.Mappings)

                // Logging endpoints
                actuator.GET("/loggers", a.Loggers)
                actuator.POST("/loggers/:name", a.SetLoggerLevel)
        }</span>

        <span class="cov8" title="19">a.logger.Info("Actuator routes registered", zap.String("base_path", "/actuator"))</span>
}

// Health returns overall health status
func (a *Actuator) Health(c *gin.Context) <span class="cov2" title="2">{
        reqLogger := a.logger.WithRequest(c.Request)
        reqLogger.Info("Health check request received")

        // Use the healthcheck handler to get overall health
        a.health.LiveEndpoint(c.Writer, c.Request)

        reqLogger.BusinessEvent("health_check", "", "", map[string]interface{}{
                "endpoint": "/actuator/health",
        })
}</span>

// Liveness returns liveness check status
func (a *Actuator) Liveness(c *gin.Context) <span class="cov2" title="2">{
        reqLogger := a.logger.WithRequest(c.Request)
        reqLogger.Info("Liveness check request received")

        a.health.LiveEndpoint(c.Writer, c.Request)

        reqLogger.BusinessEvent("liveness_check", "", "", map[string]interface{}{
                "endpoint": "/actuator/health/live",
        })
}</span>

// Readiness returns readiness check status
func (a *Actuator) Readiness(c *gin.Context) <span class="cov2" title="2">{
        reqLogger := a.logger.WithRequest(c.Request)
        reqLogger.Info("Readiness check request received")

        a.health.ReadyEndpoint(c.Writer, c.Request)

        reqLogger.BusinessEvent("readiness_check", "", "", map[string]interface{}{
                "endpoint": "/actuator/health/ready",
        })
}</span>

// Info returns application information
func (a *Actuator) Info(c *gin.Context) <span class="cov2" title="2">{
        reqLogger := a.logger.WithRequest(c.Request)
        reqLogger.Info("Application info request received")

        c.JSON(http.StatusOK, a.appInfo)
}</span>

// Environment returns environment information
func (a *Actuator) Environment(c *gin.Context) <span class="cov2" title="2">{
        reqLogger := a.logger.WithRequest(c.Request)
        reqLogger.Info("Environment info request received")

        env := gin.H{
                "environment": a.appInfo.Environment,
                "properties":  a.appInfo.Properties,
                "goVersion":   runtime.Version(),
                "os":          runtime.GOOS,
                "arch":        runtime.GOARCH,
                "startTime":   a.startTime,
                "uptime":      time.Since(a.startTime).String(),
        }

        c.JSON(http.StatusOK, env)
}</span>

// Metrics returns application metrics
func (a *Actuator) Metrics(c *gin.Context) <span class="cov2" title="2">{
        reqLogger := a.logger.WithRequest(c.Request)
        reqLogger.Info("Metrics request received")

        metrics := gin.H{
                "uptime":    time.Since(a.startTime).String(),
                "memory":    a.getMemoryStats(),
                "runtime":   a.getRuntimeStats(),
                "requests":  a.getRequestStats(),
                "timestamp": time.Now(),
        }

        reqLogger.BusinessEvent("metrics_request", "", "", map[string]interface{}{
                "endpoint": "/actuator/metrics",
        })

        c.JSON(http.StatusOK, metrics)
}</span>

// PrometheusMetrics returns Prometheus-formatted metrics
func (a *Actuator) PrometheusMetrics(c *gin.Context) <span class="cov2" title="2">{
        reqLogger := a.logger.WithRequest(c.Request)
        reqLogger.Info("Prometheus metrics request received")

        handler := promhttp.HandlerFor(a.registry, promhttp.HandlerOpts{})
        handler.ServeHTTP(c.Writer, c.Request)

        reqLogger.BusinessEvent("prometheus_metrics_request", "", "", map[string]interface{}{
                "endpoint": "/actuator/prometheus",
        })
}</span>

// Status returns application status
func (a *Actuator) Status(c *gin.Context) <span class="cov2" title="2">{
        status := gin.H{
                "status":      "RUNNING",
                "startTime":   a.startTime,
                "uptime":      time.Since(a.startTime).String(),
                "version":     a.appInfo.Version,
                "environment": a.appInfo.Environment,
                "goroutines":  runtime.NumGoroutine(),
                "memory":      a.getMemoryStats(),
        }

        c.JSON(http.StatusOK, status)
}</span>

// Uptime returns application uptime
func (a *Actuator) Uptime(c *gin.Context) <span class="cov2" title="2">{
        uptime := gin.H{
                "uptime":      time.Since(a.startTime).String(),
                "startTime":   a.startTime,
                "duration":    time.Since(a.startTime).Milliseconds(),
                "durationSec": time.Since(a.startTime).Seconds(),
        }

        c.JSON(http.StatusOK, uptime)
}</span>

// ThreadDump returns goroutine information
func (a *Actuator) ThreadDump(c *gin.Context) <span class="cov2" title="2">{
        // Get goroutine count and stack traces
        stack := make([]byte, 1024*1024)
        stack = stack[:runtime.Stack(stack, true)]

        dump := gin.H{
                "numGoroutines": runtime.NumGoroutine(),
                "stackTrace":    string(stack),
                "timestamp":     time.Now(),
        }

        c.JSON(http.StatusOK, dump)
}</span>

// HeapDump returns memory heap information
func (a *Actuator) HeapDump(c *gin.Context) <span class="cov2" title="2">{
        var m runtime.MemStats
        runtime.ReadMemStats(&amp;m)

        dump := gin.H{
                "heapAlloc":    m.HeapAlloc,
                "heapSys":      m.HeapSys,
                "heapIdle":     m.HeapIdle,
                "heapInuse":    m.HeapInuse,
                "heapReleased": m.HeapReleased,
                "heapObjects":  m.HeapObjects,
                "totalAlloc":   m.TotalAlloc,
                "sys":          m.Sys,
                "numGC":        m.NumGC,
                "timestamp":    time.Now(),
        }

        c.JSON(http.StatusOK, dump)
}</span>

// ConfigProps returns configuration properties
func (a *Actuator) ConfigProps(c *gin.Context) <span class="cov2" title="2">{
        c.JSON(http.StatusOK, gin.H{
                "application": a.appInfo,
                "timestamp":   time.Now(),
        })
}</span>

// Mappings returns endpoint mappings
func (a *Actuator) Mappings(c *gin.Context) <span class="cov2" title="2">{
        mappings := gin.H{
                "actuator": gin.H{
                        "health":       "/actuator/health",
                        "health/live":  "/actuator/health/live",
                        "health/ready": "/actuator/health/ready",
                        "info":         "/actuator/info",
                        "metrics":      "/actuator/metrics",
                        "prometheus":   "/actuator/prometheus",
                        "status":       "/actuator/status",
                        "uptime":       "/actuator/uptime",
                        "threaddump":   "/actuator/threaddump",
                        "heapdump":     "/actuator/heapdump",
                },
                "timestamp": time.Now(),
        }

        c.JSON(http.StatusOK, mappings)
}</span>

// Loggers returns logger information
func (a *Actuator) Loggers(c *gin.Context) <span class="cov2" title="2">{
        loggers := gin.H{
                "levels": gin.H{
                        "ROOT":         "INFO",
                        "auth-service": "INFO",
                },
                "timestamp": time.Now(),
        }

        c.JSON(http.StatusOK, loggers)
}</span>

// SetLoggerLevel sets logger level
func (a *Actuator) SetLoggerLevel(c *gin.Context) <span class="cov4" title="4">{
        loggerName := c.Param("name")

        var request struct {
                Level string `json:"level"`
        }

        if err := c.ShouldBindJSON(&amp;request); err != nil </span><span class="cov2" title="2">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Invalid request body",
                })
                return
        }</span>

        <span class="cov2" title="2">c.JSON(http.StatusOK, gin.H{
                "logger":  loggerName,
                "level":   request.Level,
                "message": "Logger level updated",
        })</span>
}

// RecordRequest records request metrics
func (a *Actuator) RecordRequest(method, endpoint string, status int, duration time.Duration) <span class="cov4" title="4">{
        a.requestCount.WithLabelValues(method, endpoint, string(rune(status))).Inc()
        a.requestDuration.WithLabelValues(method, endpoint).Observe(duration.Seconds())
}</span>

// StartRequest starts tracking an active request
func (a *Actuator) StartRequest(method, endpoint string) <span class="cov2" title="2">{
        a.activeRequests.WithLabelValues(method, endpoint).Inc()
}</span>

// EndRequest ends tracking an active request
func (a *Actuator) EndRequest(method, endpoint string) <span class="cov2" title="2">{
        a.activeRequests.WithLabelValues(method, endpoint).Dec()
}</span>

// getMemoryStats returns current memory statistics
func (a *Actuator) getMemoryStats() gin.H <span class="cov5" title="6">{
        var m runtime.MemStats
        runtime.ReadMemStats(&amp;m)

        return gin.H{
                "alloc":      m.Alloc,
                "totalAlloc": m.TotalAlloc,
                "sys":        m.Sys,
                "numGC":      m.NumGC,
                "heapAlloc":  m.HeapAlloc,
                "heapSys":    m.HeapSys,
                "heapIdle":   m.HeapIdle,
                "heapInuse":  m.HeapInuse,
        }
}</span>

// getRuntimeStats returns current runtime statistics
func (a *Actuator) getRuntimeStats() gin.H <span class="cov4" title="4">{
        return gin.H{
                "numCPU":       runtime.NumCPU(),
                "numGoroutine": runtime.NumGoroutine(),
                "numCgoCall":   runtime.NumCgoCall(),
                "goVersion":    runtime.Version(),
        }
}</span>

// getRequestStats returns request statistics
func (a *Actuator) getRequestStats() gin.H <span class="cov4" title="4">{
        // This would typically return actual request statistics
        // For now, return placeholder data
        return gin.H{
                "totalRequests":   0,
                "activeRequests":  0,
                "requestsPerSec":  0,
                "errorCount":      0,
                "averageResponse": 0,
        }
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package actuator

import (
        "context"
        "database/sql"
        "fmt"
        "runtime"
        "time"

        "github.com/heptiolabs/healthcheck"
)

// DatabaseHealthCheck creates a health check for database connectivity
func DatabaseHealthCheck(db *sql.DB) healthcheck.Check <span class="cov4" title="2">{
        return func() error </span><span class="cov0" title="0">{
                ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
                defer cancel()

                return db.PingContext(ctx)
        }</span>
}

// RedisHealthCheck creates a health check for Redis connectivity
func RedisHealthCheck(redisClient interface{}) healthcheck.Check <span class="cov6" title="3">{
        return func() error </span><span class="cov6" title="3">{
                // This is a placeholder - you would implement actual Redis ping
                // For now, return nil to indicate success
                return nil
        }</span>
}

// DiskSpaceHealthCheck creates a health check for disk space
func DiskSpaceHealthCheck(minSpaceGB int64) healthcheck.Check <span class="cov7" title="4">{
        return func() error </span><span class="cov7" title="4">{
                // This is a placeholder - you would implement actual disk space check
                // For now, return nil to indicate success
                return nil
        }</span>
}

// MemoryHealthCheck creates a health check for memory usage
func MemoryHealthCheck(maxMemoryPercent int) healthcheck.Check <span class="cov10" title="6">{
        return func() error </span><span class="cov10" title="6">{
                var m runtime.MemStats
                runtime.ReadMemStats(&amp;m)

                // Calculate memory usage percentage
                memoryUsagePercent := float64(m.Sys) / float64(1&lt;&lt;30) * 100 // Convert to GB

                if memoryUsagePercent &gt; float64(maxMemoryPercent) </span><span class="cov6" title="3">{
                        return fmt.Errorf("memory usage too high: %.2f%%", memoryUsagePercent)
                }</span>

                <span class="cov6" title="3">return nil</span>
        }
}

// GoroutineHealthCheck creates a health check for goroutine count
func GoroutineHealthCheck(maxGoroutines int) healthcheck.Check <span class="cov9" title="5">{
        return func() error </span><span class="cov9" title="5">{
                count := runtime.NumGoroutine()
                if count &gt; maxGoroutines </span><span class="cov6" title="3">{
                        return fmt.Errorf("too many goroutines: %d", count)
                }</span>
                <span class="cov4" title="2">return nil</span>
        }
}

// CustomHealthCheck creates a custom health check function
func CustomHealthCheck(checkFunc func() error) healthcheck.Check <span class="cov7" title="4">{
        return checkFunc
}</span>

// TimeoutHealthCheck wraps a health check with a timeout
func TimeoutHealthCheck(check healthcheck.Check, timeout time.Duration) healthcheck.Check <span class="cov10" title="6">{
        return func() error </span><span class="cov9" title="5">{
                done := make(chan error, 1)
                go func() </span><span class="cov9" title="5">{
                        done &lt;- check()
                }</span>()

                <span class="cov9" title="5">select </span>{
                case err := &lt;-done:<span class="cov4" title="2">
                        return err</span>
                case &lt;-time.After(timeout):<span class="cov6" title="3">
                        return fmt.Errorf("health check timed out after %v", timeout)</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package config

import (
        "fmt"
        "time"

        "github.com/spf13/viper"
)

// Config holds all configuration for the application
type Config struct {
        Server   ServerConfig   `mapstructure:"server"`
        Database DatabaseConfig `mapstructure:"database"`
        Redis    RedisConfig    `mapstructure:"redis"`
        OAuth    OAuthConfig    `mapstructure:"oauth"`
        JWT      JWTConfig      `mapstructure:"jwt"`
        Security SecurityConfig `mapstructure:"security"`
        Logging  LoggingConfig  `mapstructure:"logging"`
        Cache    CacheConfig    `mapstructure:"cache"`
        Tenancy  TenancyConfig  `mapstructure:"tenancy"`
        OneTime  OneTimeConfig  `mapstructure:"one_time_auth"`
        Actuator ActuatorConfig `mapstructure:"actuator"`
        Services ServiceConfig  `mapstructure:"services"`
        OTP      OTPConfig      `mapstructure:"otp"`
}

// ServerConfig holds server configuration
type ServerConfig struct {
        Port           int           `mapstructure:"port"`
        GRPCPort       int           `mapstructure:"grpc_port"`
        Host           string        `mapstructure:"host"`
        ReadTimeout    time.Duration `mapstructure:"read_timeout"`
        WriteTimeout   time.Duration `mapstructure:"write_timeout"`
        MaxHeaderBytes int           `mapstructure:"max_header_bytes"`
}

// DatabaseConfig holds database configuration
type DatabaseConfig struct {
        Host            string        `mapstructure:"host"`
        Port            int           `mapstructure:"port"`
        Name            string        `mapstructure:"name"`
        User            string        `mapstructure:"user"`
        Password        string        `mapstructure:"password"`
        SSLMode         string        `mapstructure:"sslmode"`
        MaxOpenConns    int           `mapstructure:"max_open_conns"`
        MaxIdleConns    int           `mapstructure:"max_idle_conns"`
        ConnMaxLifetime time.Duration `mapstructure:"conn_max_lifetime"`
}

// RedisConfig holds Redis configuration
type RedisConfig struct {
        Host         string        `mapstructure:"host"`
        Port         int           `mapstructure:"port"`
        Password     string        `mapstructure:"password"`
        DB           int           `mapstructure:"db"`
        PoolSize     int           `mapstructure:"pool_size"`
        MinIdleConns int           `mapstructure:"min_idle_conns"`
        DialTimeout  time.Duration `mapstructure:"dial_timeout"`
        ReadTimeout  time.Duration `mapstructure:"read_timeout"`
        WriteTimeout time.Duration `mapstructure:"write_timeout"`
}

// OAuthConfig holds OAuth configuration
type OAuthConfig struct {
        Google    GoogleOAuthConfig `mapstructure:"google"`
        Providers []OAuthProvider   `mapstructure:"providers"`
}

// GoogleOAuthConfig holds Google OAuth specific configuration
type GoogleOAuthConfig struct {
        ClientID     string   `mapstructure:"client_id"`
        ClientSecret string   `mapstructure:"client_secret"`
        RedirectURL  string   `mapstructure:"redirect_url"`
        Scopes       []string `mapstructure:"scopes"`
}

// OAuthProvider holds OAuth provider configuration
type OAuthProvider struct {
        Name            string `mapstructure:"name"`
        Enabled         bool   `mapstructure:"enabled"`
        ClientIDEnv     string `mapstructure:"client_id_env"`
        ClientSecretEnv string `mapstructure:"client_secret_env"`
        RedirectURL     string `mapstructure:"redirect_url"`
}

// JWTConfig holds JWT configuration
type JWTConfig struct {
        Secret                 string `mapstructure:"secret"`
        ExpirationHours        int    `mapstructure:"expiration_hours"`
        RefreshExpirationHours int    `mapstructure:"refresh_expiration_hours"`
        Issuer                 string `mapstructure:"issuer"`
        Audience               string `mapstructure:"audience"`
}

// SecurityConfig holds security configuration
type SecurityConfig struct {
        BcryptCost             int      `mapstructure:"bcrypt_cost"`
        PasswordMinLength      int      `mapstructure:"password_min_length"`
        PasswordRequireUpper   bool     `mapstructure:"password_require_uppercase"`
        PasswordRequireLower   bool     `mapstructure:"password_require_lowercase"`
        PasswordRequireNumbers bool     `mapstructure:"password_require_numbers"`
        PasswordRequireSpecial bool     `mapstructure:"password_require_special"`
        RateLimitRequests      int      `mapstructure:"rate_limit_requests"`
        RateLimitWindow        string   `mapstructure:"rate_limit_window"`
        CORSAllowedOrigins     []string `mapstructure:"cors_allowed_origins"`
        CORSAllowedMethods     []string `mapstructure:"cors_allowed_methods"`
        CORSAllowedHeaders     []string `mapstructure:"cors_allowed_headers"`
}

// LoggingConfig holds logging configuration
type LoggingConfig struct {
        Level             string `mapstructure:"level"`
        Format            string `mapstructure:"format"`
        Output            string `mapstructure:"output"`
        IncludeCaller     bool   `mapstructure:"include_caller"`
        IncludeStacktrace bool   `mapstructure:"include_stacktrace"`
}

// CacheConfig holds cache configuration
type CacheConfig struct {
        TTL    CacheTTLConfig    `mapstructure:"ttl"`
        Prefix CachePrefixConfig `mapstructure:"prefix"`
}

// CacheTTLConfig holds cache TTL configuration
type CacheTTLConfig struct {
        UserSession  string `mapstructure:"user_session"`
        TenantConfig string `mapstructure:"tenant_config"`
        OAuthState   string `mapstructure:"oauth_state"`
        OneTimeToken string `mapstructure:"one_time_token"`
}

// CachePrefixConfig holds cache prefix configuration
type CachePrefixConfig struct {
        UserSession  string `mapstructure:"user_session"`
        TenantConfig string `mapstructure:"tenant_config"`
        OAuthState   string `mapstructure:"oauth_state"`
        OneTimeToken string `mapstructure:"one_time_token"`
}

// TenancyConfig holds multi-tenancy configuration
type TenancyConfig struct {
        DefaultTenantID   string `mapstructure:"default_tenant_id"`
        TenantHeader      string `mapstructure:"tenant_header"`
        TenantCookie      string `mapstructure:"tenant_cookie"`
        AutoCreateTenant  bool   `mapstructure:"auto_create_tenant"`
        MaxTenantsPerUser int    `mapstructure:"max_tenants_per_user"`
}

// OneTimeConfig holds one-time authentication configuration
type OneTimeConfig struct {
        TokenLength     int      `mapstructure:"token_length"`
        MaxUses         int      `mapstructure:"max_uses"`
        ExpirationHours int      `mapstructure:"expiration_hours"`
        AllowedURLs     []string `mapstructure:"allowed_urls"`
}

// ActuatorConfig holds actuator configuration
type ActuatorConfig struct {
        Enabled   bool                   `mapstructure:"enabled"`
        BasePath  string                 `mapstructure:"base_path"`
        Health    HealthConfig           `mapstructure:"health"`
        Metrics   MetricsConfig          `mapstructure:"metrics"`
        Endpoints EndpointsConfig        `mapstructure:"endpoints"`
        Security  ActuatorSecurityConfig `mapstructure:"security"`
}

// ActuatorSecurityConfig holds actuator security configuration
type ActuatorSecurityConfig struct {
        HealthPublic                 bool     `mapstructure:"health_public"`
        MetricsPublic                bool     `mapstructure:"metrics_public"`
        SensitiveEndpointsRestricted bool     `mapstructure:"sensitive_endpoints_restricted"`
        AllowedIPs                   []string `mapstructure:"allowed_ips"`
}

// HealthConfig holds health check configuration
type HealthConfig struct {
        Enabled                bool          `mapstructure:"enabled"`
        Timeout                time.Duration `mapstructure:"timeout"`
        MemoryThresholdPercent int           `mapstructure:"memory_threshold_percent"`
        GoroutineThreshold     int           `mapstructure:"goroutine_threshold"`
        DiskSpaceThresholdGB   int64         `mapstructure:"disk_space_threshold_gb"`
}

// MetricsConfig holds metrics configuration
type MetricsConfig struct {
        Enabled           bool `mapstructure:"enabled"`
        PrometheusEnabled bool `mapstructure:"prometheus_enabled"`
        RequestTracking   bool `mapstructure:"request_tracking"`
}

// EndpointsConfig holds endpoint configuration
type EndpointsConfig struct {
        Health      bool `mapstructure:"health"`
        Info        bool `mapstructure:"info"`
        Metrics     bool `mapstructure:"metrics"`
        Prometheus  bool `mapstructure:"prometheus"`
        Status      bool `mapstructure:"status"`
        Uptime      bool `mapstructure:"uptime"`
        ThreadDump  bool `mapstructure:"threaddump"`
        HeapDump    bool `mapstructure:"heapdump"`
        ConfigProps bool `mapstructure:"configprops"`
        Mappings    bool `mapstructure:"mappings"`
        Loggers     bool `mapstructure:"loggers"`
}

// OTPConfig holds OTP configuration
type OTPConfig struct {
        DefaultDigitLength       int `yaml:"default_digit_length" json:"default_digit_length"`
        MinDigitLength           int `yaml:"min_digit_length" json:"min_digit_length"`
        MaxDigitLength           int `yaml:"max_digit_length" json:"max_digit_length"`
        DefaultExpirationMinutes int `yaml:"default_expiration_minutes" json:"default_expiration_minutes"`
        MaxAttempts              int `yaml:"max_attempts" json:"max_attempts"`
        RateLimitPerHour         int `yaml:"rate_limit_per_hour" json:"rate_limit_per_hour"`
}

// LoadConfig loads configuration from file and environment variables
func LoadConfig(configPath string) (*Config, error) <span class="cov10" title="11">{
        viper.SetConfigFile(configPath)
        viper.SetConfigType("yaml")

        // Read environment variables
        viper.AutomaticEnv()

        // Set default values
        setDefaults()

        // Read config file
        if err := viper.ReadInConfig(); err != nil </span><span class="cov3" title="2">{
                return nil, fmt.Errorf("failed to read config file: %w", err)
        }</span>

        // Override with environment variables
        <span class="cov9" title="9">overrideWithEnvVars()

        var config Config
        if err := viper.Unmarshal(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal config: %w", err)
        }</span>

        <span class="cov9" title="9">return &amp;config, nil</span>
}

// setDefaults sets default configuration values
func setDefaults() <span class="cov10" title="11">{
        viper.SetDefault("server.port", 8080)
        viper.SetDefault("server.grpc_port", 9090)
        viper.SetDefault("server.host", "0.0.0.0")
        viper.SetDefault("server.read_timeout", "30s")
        viper.SetDefault("server.write_timeout", "30s")
        viper.SetDefault("server.max_header_bytes", 1048576)

        viper.SetDefault("database.host", "localhost")
        viper.SetDefault("database.port", 5432)
        viper.SetDefault("database.name", "auth_service")
        viper.SetDefault("database.user", "postgres")
        viper.SetDefault("database.password", "password")
        viper.SetDefault("database.sslmode", "disable")
        viper.SetDefault("database.max_open_conns", 25)
        viper.SetDefault("database.max_idle_conns", 5)
        viper.SetDefault("database.conn_max_lifetime", "5m")

        viper.SetDefault("redis.host", "localhost")
        viper.SetDefault("redis.port", 6379)
        viper.SetDefault("redis.password", "")
        viper.SetDefault("redis.db", 0)
        viper.SetDefault("redis.pool_size", 10)
        viper.SetDefault("redis.min_idle_conns", 5)
        viper.SetDefault("redis.dial_timeout", "5s")
        viper.SetDefault("redis.read_timeout", "3s")
        viper.SetDefault("redis.write_timeout", "3s")

        viper.SetDefault("jwt.expiration_hours", 24)
        viper.SetDefault("jwt.refresh_expiration_hours", 168)
        viper.SetDefault("jwt.issuer", "auth-service")
        viper.SetDefault("jwt.audience", "auth-service-users")

        viper.SetDefault("security.bcrypt_cost", 12)
        viper.SetDefault("security.password_min_length", 8)
        viper.SetDefault("security.password_require_uppercase", true)
        viper.SetDefault("security.password_require_lowercase", true)
        viper.SetDefault("security.password_require_numbers", true)
        viper.SetDefault("security.password_require_special", true)
        viper.SetDefault("security.rate_limit_requests", 100)
        viper.SetDefault("security.rate_limit_window", "1m")

        viper.SetDefault("logging.level", "info")
        viper.SetDefault("logging.format", "json")
        viper.SetDefault("logging.output", "stdout")
        viper.SetDefault("logging.include_caller", true)
        viper.SetDefault("logging.include_stacktrace", true)

        viper.SetDefault("tenancy.default_tenant_id", "default")
        viper.SetDefault("tenancy.tenant_header", "X-Tenant-ID")
        viper.SetDefault("tenancy.tenant_cookie", "tenant_id")
        viper.SetDefault("tenancy.auto_create_tenant", true)
        viper.SetDefault("tenancy.max_tenants_per_user", 10)

        viper.SetDefault("one_time_auth.token_length", 32)
        viper.SetDefault("one_time_auth.max_uses", 1)
        viper.SetDefault("one_time_auth.expiration_hours", 1)

        viper.SetDefault("actuator.enabled", false)
        viper.SetDefault("actuator.base_path", "/actuator")
        viper.SetDefault("actuator.health.enabled", true)
        viper.SetDefault("actuator.health.timeout", "5s")
        viper.SetDefault("actuator.health.memory_threshold_percent", 90)
        viper.SetDefault("actuator.health.goroutine_threshold", 1000)
        viper.SetDefault("actuator.health.disk_space_threshold_gb", 10)
        viper.SetDefault("actuator.metrics.enabled", true)
        viper.SetDefault("actuator.metrics.prometheus_enabled", true)
        viper.SetDefault("actuator.metrics.request_tracking", true)
        viper.SetDefault("actuator.endpoints.health", true)
        viper.SetDefault("actuator.endpoints.info", true)
        viper.SetDefault("actuator.endpoints.metrics", true)
        viper.SetDefault("actuator.endpoints.prometheus", true)
        viper.SetDefault("actuator.endpoints.status", true)
        viper.SetDefault("actuator.endpoints.uptime", true)
        viper.SetDefault("actuator.endpoints.threaddump", true)
        viper.SetDefault("actuator.endpoints.heapdump", true)
        viper.SetDefault("actuator.endpoints.configprops", true)
        viper.SetDefault("actuator.endpoints.mappings", true)
        viper.SetDefault("actuator.endpoints.loggers", true)
        viper.SetDefault("actuator.security.health_public", true)
        viper.SetDefault("actuator.security.metrics_public", true)
        viper.SetDefault("actuator.security.sensitive_endpoints_restricted", true)
        viper.SetDefault("actuator.security.allowed_ips", []string{})
}</span>

// overrideWithEnvVars overrides configuration with environment variables
func overrideWithEnvVars() <span class="cov9" title="9">{
        // Server
        if serverPort := viper.GetInt("SERVER_PORT"); serverPort != 0 </span><span class="cov8" title="7">{
                viper.Set("server.port", serverPort)
        }</span>
        <span class="cov9" title="9">if serverHost := viper.GetString("SERVER_HOST"); serverHost != "" </span><span class="cov6" title="4">{
                viper.Set("server.host", serverHost)
        }</span>

        // Database
        <span class="cov9" title="9">if dbHost := viper.GetString("DB_HOST"); dbHost != "" </span><span class="cov9" title="9">{
                viper.Set("database.host", dbHost)
        }</span>
        <span class="cov9" title="9">if dbPort := viper.GetInt("DB_PORT"); dbPort != 0 </span><span class="cov8" title="7">{
                viper.Set("database.port", dbPort)
        }</span>
        <span class="cov9" title="9">if dbName := viper.GetString("DB_NAME"); dbName != "" </span><span class="cov9" title="9">{
                viper.Set("database.name", dbName)
        }</span>
        <span class="cov9" title="9">if dbUser := viper.GetString("DB_USER"); dbUser != "" </span><span class="cov9" title="9">{
                viper.Set("database.user", dbUser)
        }</span>
        <span class="cov9" title="9">if dbPassword := viper.GetString("DB_PASSWORD"); dbPassword != "" </span><span class="cov9" title="9">{
                viper.Set("database.password", dbPassword)
        }</span>

        // Redis
        <span class="cov9" title="9">if redisHost := viper.GetString("REDIS_HOST"); redisHost != "" </span><span class="cov9" title="9">{
                viper.Set("redis.host", redisHost)
        }</span>
        <span class="cov9" title="9">if redisPort := viper.GetInt("REDIS_PORT"); redisPort != 0 </span><span class="cov8" title="7">{
                viper.Set("redis.port", redisPort)
        }</span>
        <span class="cov9" title="9">if redisPassword := viper.GetString("REDIS_PASSWORD"); redisPassword != "" </span><span class="cov9" title="9">{
                viper.Set("redis.password", redisPassword)
        }</span>

        // JWT
        <span class="cov9" title="9">if jwtSecret := viper.GetString("JWT_SECRET"); jwtSecret != "" </span><span class="cov9" title="9">{
                viper.Set("jwt.secret", jwtSecret)
        }</span>

        // OAuth
        <span class="cov9" title="9">if googleClientID := viper.GetString("GOOGLE_CLIENT_ID"); googleClientID != "" </span><span class="cov9" title="9">{
                viper.Set("oauth.google.client_id", googleClientID)
        }</span>
        <span class="cov9" title="9">if googleClientSecret := viper.GetString("GOOGLE_CLIENT_SECRET"); googleClientSecret != "" </span><span class="cov9" title="9">{
                viper.Set("oauth.google.client_secret", googleClientSecret)
        }</span>

        // Actuator
        <span class="cov9" title="9">if actuatorEnabled := viper.GetBool("ACTUATOR_ENABLED"); actuatorEnabled </span><span class="cov6" title="4">{
                viper.Set("actuator.enabled", true)
        }</span>
        <span class="cov9" title="9">if actuatorBasePath := viper.GetString("ACTUATOR_BASE_PATH"); actuatorBasePath != "" </span><span class="cov6" title="4">{
                viper.Set("actuator.base_path", actuatorBasePath)
        }</span>
        <span class="cov9" title="9">if actuatorHealthEnabled := viper.GetBool("ACTUATOR_HEALTH_ENABLED"); actuatorHealthEnabled </span><span class="cov6" title="4">{
                viper.Set("actuator.health.enabled", true)
        }</span>
        <span class="cov9" title="9">if actuatorHealthTimeout := viper.GetDuration("ACTUATOR_HEALTH_TIMEOUT"); actuatorHealthTimeout != 0 </span><span class="cov1" title="1">{
                viper.Set("actuator.health.timeout", actuatorHealthTimeout)
        }</span>
        <span class="cov9" title="9">if actuatorHealthMemoryThresholdPercent := viper.GetInt("ACTUATOR_HEALTH_MEMORY_THRESHOLD_PERCENT"); actuatorHealthMemoryThresholdPercent != 0 </span><span class="cov1" title="1">{
                viper.Set("actuator.health.memory_threshold_percent", actuatorHealthMemoryThresholdPercent)
        }</span>
        <span class="cov9" title="9">if actuatorHealthGoroutineThreshold := viper.GetInt("ACTUATOR_HEALTH_GOROUTINE_THRESHOLD"); actuatorHealthGoroutineThreshold != 0 </span><span class="cov1" title="1">{
                viper.Set("actuator.health.goroutine_threshold", actuatorHealthGoroutineThreshold)
        }</span>
        <span class="cov9" title="9">if actuatorHealthDiskSpaceThresholdGB := viper.GetInt64("ACTUATOR_HEALTH_DISK_SPACE_THRESHOLD_GB"); actuatorHealthDiskSpaceThresholdGB != 0 </span><span class="cov1" title="1">{
                viper.Set("actuator.health.disk_space_threshold_gb", actuatorHealthDiskSpaceThresholdGB)
        }</span>
        <span class="cov9" title="9">if actuatorMetricsEnabled := viper.GetBool("ACTUATOR_METRICS_ENABLED"); actuatorMetricsEnabled </span><span class="cov6" title="4">{
                viper.Set("actuator.metrics.enabled", true)
        }</span>
        <span class="cov9" title="9">if actuatorMetricsPrometheusEnabled := viper.GetBool("ACTUATOR_METRICS_PROMETHEUS_ENABLED"); actuatorMetricsPrometheusEnabled </span><span class="cov6" title="4">{
                viper.Set("actuator.metrics.prometheus_enabled", true)
        }</span>
        <span class="cov9" title="9">if actuatorMetricsRequestTracking := viper.GetBool("ACTUATOR_METRICS_REQUEST_TRACKING"); actuatorMetricsRequestTracking </span><span class="cov6" title="4">{
                viper.Set("actuator.metrics.request_tracking", true)
        }</span>
        <span class="cov9" title="9">if actuatorEndpointsHealth := viper.GetBool("ACTUATOR_ENDPOINTS_HEALTH"); actuatorEndpointsHealth </span><span class="cov0" title="0">{
                viper.Set("actuator.endpoints.health", true)
        }</span>
        <span class="cov9" title="9">if actuatorEndpointsInfo := viper.GetBool("ACTUATOR_ENDPOINTS_INFO"); actuatorEndpointsInfo </span><span class="cov0" title="0">{
                viper.Set("actuator.endpoints.info", true)
        }</span>
        <span class="cov9" title="9">if actuatorEndpointsMetrics := viper.GetBool("ACTUATOR_ENDPOINTS_METRICS"); actuatorEndpointsMetrics </span><span class="cov0" title="0">{
                viper.Set("actuator.endpoints.metrics", true)
        }</span>
        <span class="cov9" title="9">if actuatorEndpointsPrometheus := viper.GetBool("ACTUATOR_ENDPOINTS_PROMETHEUS"); actuatorEndpointsPrometheus </span><span class="cov0" title="0">{
                viper.Set("actuator.endpoints.prometheus", true)
        }</span>
        <span class="cov9" title="9">if actuatorEndpointsStatus := viper.GetBool("ACTUATOR_ENDPOINTS_STATUS"); actuatorEndpointsStatus </span><span class="cov0" title="0">{
                viper.Set("actuator.endpoints.status", true)
        }</span>
        <span class="cov9" title="9">if actuatorEndpointsUptime := viper.GetBool("ACTUATOR_ENDPOINTS_UPTIME"); actuatorEndpointsUptime </span><span class="cov0" title="0">{
                viper.Set("actuator.endpoints.uptime", true)
        }</span>
        <span class="cov9" title="9">if actuatorEndpointsThreadDump := viper.GetBool("ACTUATOR_ENDPOINTS_THREAD_DUMP"); actuatorEndpointsThreadDump </span><span class="cov0" title="0">{
                viper.Set("actuator.endpoints.threaddump", true)
        }</span>
        <span class="cov9" title="9">if actuatorEndpointsHeapDump := viper.GetBool("ACTUATOR_ENDPOINTS_HEAP_DUMP"); actuatorEndpointsHeapDump </span><span class="cov0" title="0">{
                viper.Set("actuator.endpoints.heapdump", true)
        }</span>
        <span class="cov9" title="9">if actuatorEndpointsConfigProps := viper.GetBool("ACTUATOR_ENDPOINTS_CONFIG_PROPS"); actuatorEndpointsConfigProps </span><span class="cov0" title="0">{
                viper.Set("actuator.endpoints.configprops", true)
        }</span>
        <span class="cov9" title="9">if actuatorEndpointsMappings := viper.GetBool("ACTUATOR_ENDPOINTS_MAPPINGS"); actuatorEndpointsMappings </span><span class="cov0" title="0">{
                viper.Set("actuator.endpoints.mappings", true)
        }</span>
        <span class="cov9" title="9">if actuatorEndpointsLoggers := viper.GetBool("ACTUATOR_ENDPOINTS_LOGGERS"); actuatorEndpointsLoggers </span><span class="cov0" title="0">{
                viper.Set("actuator.endpoints.loggers", true)
        }</span>
        <span class="cov9" title="9">if actuatorSecurityHealthPublic := viper.GetBool("ACTUATOR_SECURITY_HEALTH_PUBLIC"); actuatorSecurityHealthPublic </span><span class="cov0" title="0">{
                viper.Set("actuator.security.health_public", true)
        }</span>
        <span class="cov9" title="9">if actuatorSecurityMetricsPublic := viper.GetBool("ACTUATOR_SECURITY_METRICS_PUBLIC"); actuatorSecurityMetricsPublic </span><span class="cov0" title="0">{
                viper.Set("actuator.security.metrics_public", true)
        }</span>
        <span class="cov9" title="9">if actuatorSecuritySensitiveEndpointsRestricted := viper.GetBool("ACTUATOR_SECURITY_SENSITIVE_ENDPOINTS_RESTRICTED"); actuatorSecuritySensitiveEndpointsRestricted </span><span class="cov0" title="0">{
                viper.Set("actuator.security.sensitive_endpoints_restricted", true)
        }</span>
        <span class="cov9" title="9">if actuatorSecurityAllowedIPs := viper.GetStringSlice("ACTUATOR_SECURITY_ALLOWED_IPS"); len(actuatorSecurityAllowedIPs) &gt; 0 </span><span class="cov0" title="0">{
                viper.Set("actuator.security.allowed_ips", actuatorSecurityAllowedIPs)
        }</span>
}

// GetDSN returns the database connection string
func (c *DatabaseConfig) GetDSN() string <span class="cov5" title="3">{
        return fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
                c.Host, c.Port, c.User, c.Password, c.Name, c.SSLMode)
}</span>

// GetRedisAddr returns the Redis address
func (c *RedisConfig) GetRedisAddr() string <span class="cov6" title="4">{
        return fmt.Sprintf("%s:%d", c.Host, c.Port)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package config

import (
        "time"

        "github.com/sony/gobreaker"
)

// ServiceConfig holds configuration for external services
type ServiceConfig struct {
        NotificationService NotificationServiceConfig `yaml:"notification_service" json:"notification_service"`
        SubscriptionService SubscriptionServiceConfig `yaml:"subscription_service" json:"subscription_service"`
}

// NotificationServiceConfig holds Notification Service configuration
type NotificationServiceConfig struct {
        BaseURL        string               `yaml:"base_url" json:"base_url"`
        Timeout        time.Duration        `yaml:"timeout" json:"timeout"`
        MaxRetries     int                  `yaml:"max_retries" json:"max_retries"`
        RetryDelay     time.Duration        `yaml:"retry_delay" json:"retry_delay"`
        CircuitBreaker CircuitBreakerConfig `yaml:"circuit_breaker" json:"circuit_breaker"`
}

// SubscriptionServiceConfig holds Subscription Service configuration
type SubscriptionServiceConfig struct {
        BaseURL        string               `yaml:"base_url" json:"base_url"`
        Timeout        time.Duration        `yaml:"timeout" json:"timeout"`
        MaxRetries     int                  `yaml:"max_retries" json:"max_retries"`
        RetryDelay     time.Duration        `yaml:"retry_delay" json:"retry_delay"`
        CircuitBreaker CircuitBreakerConfig `yaml:"circuit_breaker" json:"circuit_breaker"`
}

// CircuitBreakerConfig holds circuit breaker configuration
type CircuitBreakerConfig struct {
        MaxFailures   uint32        `yaml:"max_failures" json:"max_failures"`
        Timeout       time.Duration `yaml:"timeout" json:"timeout"`
        Interval      time.Duration `yaml:"interval" json:"interval"`
        ReadyToTrip   string        `yaml:"ready_to_trip" json:"ready_to_trip"` // "consecutive" or "count"
        OnStateChange bool          `yaml:"on_state_change" json:"on_state_change"`
}

// DefaultServiceConfig returns default service configuration
func DefaultServiceConfig() *ServiceConfig <span class="cov0" title="0">{
        return &amp;ServiceConfig{
                NotificationService: NotificationServiceConfig{
                        BaseURL:    "http://notification-service:8080",
                        Timeout:    10 * time.Second,
                        MaxRetries: 3,
                        RetryDelay: 1 * time.Second,
                        CircuitBreaker: CircuitBreakerConfig{
                                MaxFailures:   5,
                                Timeout:       30 * time.Second,
                                Interval:      60 * time.Second,
                                ReadyToTrip:   "consecutive",
                                OnStateChange: true,
                        },
                },
                SubscriptionService: SubscriptionServiceConfig{
                        BaseURL:    "http://subscription-service:8080",
                        Timeout:    5 * time.Second,
                        MaxRetries: 3,
                        RetryDelay: 1 * time.Second,
                        CircuitBreaker: CircuitBreakerConfig{
                                MaxFailures:   3,
                                Timeout:       30 * time.Second,
                                Interval:      60 * time.Second,
                                ReadyToTrip:   "consecutive",
                                OnStateChange: true,
                        },
                },
        }
}</span>

// CreateCircuitBreaker creates a gobreaker.CircuitBreaker from config
func (c *CircuitBreakerConfig) CreateCircuitBreaker(name string) *gobreaker.CircuitBreaker <span class="cov0" title="0">{
        settings := gobreaker.Settings{
                Name:        name,
                MaxRequests: 0, // Unlimited requests when closed
                Interval:    c.Interval,
                Timeout:     c.Timeout,
                ReadyToTrip: func(counts gobreaker.Counts) bool </span><span class="cov0" title="0">{
                        switch c.ReadyToTrip </span>{
                        case "consecutive":<span class="cov0" title="0">
                                return counts.ConsecutiveFailures &gt; c.MaxFailures</span>
                        case "count":<span class="cov0" title="0">
                                return counts.TotalFailures &gt; c.MaxFailures</span>
                        default:<span class="cov0" title="0">
                                return counts.ConsecutiveFailures &gt; c.MaxFailures</span>
                        }
                },
        }

        <span class="cov0" title="0">if c.OnStateChange </span><span class="cov0" title="0">{
                settings.OnStateChange = func(name string, from gobreaker.State, to gobreaker.State) </span>{<span class="cov0" title="0">
                        // Log state changes
                        // In production, you might want to use a proper logger here
                }</span>
        }

        <span class="cov0" title="0">return gobreaker.NewCircuitBreaker(settings)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package rest

import (
        "auth-service/internal/config"
        "auth-service/internal/logger"
        "auth-service/internal/middleware"
        "auth-service/internal/models"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

// AuthHandler handles authentication-related HTTP requests
type AuthHandler struct {
        config *config.Config
        logger *logger.Logger
}

// NewAuthHandler creates a new AuthHandler instance
func NewAuthHandler(cfg *config.Config) *AuthHandler <span class="cov10" title="12">{
        // Initialize logger for auth handler
        appLogger, err := logger.NewLogger(&amp;cfg.Logging)
        if err != nil </span><span class="cov0" title="0">{
                // Fallback to default logger if initialization fails
                appLogger = &amp;logger.Logger{}
        }</span>

        <span class="cov10" title="12">return &amp;AuthHandler{
                config: cfg,
                logger: appLogger,
        }</span>
}

// LoginRequest represents the login request body
type LoginRequest struct {
        Email    string `json:"email" binding:"required,email" example:"user@example.com"`
        Password string `json:"password" binding:"required" example:"password123"`
        TenantID string `json:"tenant_id" example:"tenant-123"` // Optional, can be extracted from context
}

// LoginResponse represents the login response body
type LoginResponse struct {
        AccessToken  string `json:"access_token" example:"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."`
        RefreshToken string `json:"refresh_token" example:"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."`
        TokenType    string `json:"token_type" example:"Bearer"`
        ExpiresIn    int    `json:"expires_in" example:"3600"`
        User         User   `json:"user"`
}

// User represents a user in the system
type User struct {
        ID       string `json:"id" example:"user-123"`
        Email    string `json:"email" example:"user@example.com"`
        TenantID string `json:"tenant_id" example:"tenant-123"`
        Roles    []Role `json:"roles"`
}

// Role represents a user role
type Role struct {
        ID   string `json:"id" example:"role-123"`
        Name string `json:"name" example:"admin"`
}

// Login godoc
// @Summary User login
// @Description Authenticate a user with email and password within a tenant
// @Tags Authentication
// @Accept json
// @Produce json
// @Param request body LoginRequest true "Login credentials"
// @Success 200 {object} LoginResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 403 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /auth/login [post]
func (h *AuthHandler) Login(c *gin.Context) <span class="cov6" title="4">{
        start := time.Now()

        // Safely get logger from context
        var reqLogger *logger.RequestLogger
        if loggerInterface := middleware.GetLogger(c); loggerInterface != nil </span><span class="cov6" title="4">{
                if reqLog, ok := loggerInterface.(*logger.RequestLogger); ok </span><span class="cov6" title="4">{
                        reqLogger = reqLog
                }</span>
        }

        // If no logger available, create a basic one
        <span class="cov6" title="4">if reqLogger == nil </span><span class="cov0" title="0">{
                reqLogger = h.logger.WithRequest(c.Request)
        }</span>

        <span class="cov6" title="4">reqLogger.Info("Login attempt started",
                zap.String("endpoint", "/auth/login"),
                zap.String("method", "POST"),
        )

        var req LoginRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov4" title="3">{
                reqLogger.AuthFailure("", "", "password", "validation_error")
                reqLogger.Error("Login validation failed", zap.Error(err))

                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "validation_error",
                        Message: err.Error(),
                })
                return
        }</span>

        // Get tenant information from context (set by middleware)
        <span class="cov1" title="1">tenantInterface := middleware.GetTenant(c)
        if tenantInterface == nil </span><span class="cov0" title="0">{
                reqLogger.Error("Tenant context missing")
                c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "tenant_context_missing",
                        Message: "Tenant context is missing",
                })
                return
        }</span>

        <span class="cov1" title="1">tenant, ok := tenantInterface.(*models.Tenant)
        if !ok </span><span class="cov0" title="0">{
                reqLogger.Error("Invalid tenant type in context")
                c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "invalid_tenant_type",
                        Message: "Invalid tenant type in context",
                })
                return
        }</span>

        // Use tenant ID from context if not provided in request
        <span class="cov1" title="1">tenantID := req.TenantID
        if tenantID == "" </span><span class="cov0" title="0">{
                tenantID = tenant.ID
        }</span>

        // Verify tenant ID matches
        <span class="cov1" title="1">if tenantID != tenant.ID </span><span class="cov0" title="0">{
                reqLogger.AuthFailure(req.Email, tenantID, "password", "tenant_mismatch")
                c.JSON(http.StatusForbidden, ErrorResponse{
                        Error:   "tenant_mismatch",
                        Message: "Tenant ID in request does not match authenticated tenant",
                })
                return
        }</span>

        <span class="cov1" title="1">reqLogger.Info("Login validation passed",
                zap.String("email", req.Email),
                zap.String("tenant_id", tenantID),
                zap.String("tenant_name", tenant.Name),
        )

        // TODO: Implement actual authentication logic
        // For now, return a mock response

        // Simulate database operation
        dbStart := time.Now()
        // Mock database query
        time.Sleep(10 * time.Millisecond) // Simulate DB latency
        reqLogger.DatabaseOperation("SELECT", "users", tenantID, time.Since(dbStart), nil)

        // Simulate cache operation
        cacheStart := time.Now()
        // Mock cache check
        time.Sleep(5 * time.Millisecond) // Simulate cache latency
        reqLogger.CacheOperation("GET", "user_session:"+req.Email, tenantID, false, time.Since(cacheStart), nil)

        response := LoginResponse{
                AccessToken:  "mock-access-token",
                RefreshToken: "mock-refresh-token",
                TokenType:    "Bearer",
                ExpiresIn:    3600,
                User: User{
                        ID:       "user-123",
                        Email:    req.Email,
                        TenantID: tenantID,
                        Roles: []Role{
                                {ID: "role-1", Name: "user"},
                        },
                },
        }

        // Log successful authentication
        reqLogger.AuthSuccess("user-123", tenantID, "password")
        reqLogger.BusinessEvent("user_login", "user-123", tenantID, map[string]interface{}{
                "login_method": "password",
                "roles":        []string{"user"},
                "duration_ms":  time.Since(start).Milliseconds(),
                "tenant_name":  tenant.Name,
                "tenant_plan":  tenant.Plan,
        })

        c.JSON(http.StatusOK, response)</span>
}

// RegisterRequest represents the registration request body
type RegisterRequest struct {
        Email     string `json:"email" binding:"required,email" example:"user@example.com"`
        Password  string `json:"password" binding:"required" example:"password123"`
        TenantID  string `json:"tenant_id" binding:"required" example:"tenant-123"`
        FirstName string `json:"first_name" binding:"required" example:"John"`
        LastName  string `json:"last_name" binding:"required" example:"Doe"`
}

// Register godoc
// @Summary User registration
// @Description Register a new user
// @Tags Authentication
// @Accept json
// @Produce json
// @Param request body RegisterRequest true "Registration data"
// @Success 201 {object} User
// @Failure 400 {object} ErrorResponse
// @Failure 409 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /auth/register [post]
func (h *AuthHandler) Register(c *gin.Context) <span class="cov6" title="4">{
        start := time.Now()

        // Safely get logger from context
        var reqLogger *logger.RequestLogger
        if loggerInterface := middleware.GetLogger(c); loggerInterface != nil </span><span class="cov6" title="4">{
                if reqLog, ok := loggerInterface.(*logger.RequestLogger); ok </span><span class="cov6" title="4">{
                        reqLogger = reqLog
                }</span>
        }

        // If no logger available, create a basic one
        <span class="cov6" title="4">if reqLogger == nil </span><span class="cov0" title="0">{
                reqLogger = h.logger.WithRequest(c.Request)
        }</span>

        <span class="cov6" title="4">reqLogger.Info("Registration attempt started",
                zap.String("endpoint", "/auth/register"),
                zap.String("method", "POST"),
        )

        var req RegisterRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov4" title="3">{
                reqLogger.Error("Registration validation failed", zap.Error(err))

                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "validation_error",
                        Message: err.Error(),
                })
                return
        }</span>

        <span class="cov1" title="1">reqLogger.Info("Registration validation passed",
                zap.String("email", req.Email),
                zap.String("tenant_id", req.TenantID),
                zap.String("first_name", req.FirstName),
                zap.String("last_name", req.LastName),
        )

        // TODO: Implement actual registration logic

        // Simulate database operations
        dbStart := time.Now()
        // Mock database queries
        time.Sleep(15 * time.Millisecond)                                                      // Simulate DB latency
        reqLogger.DatabaseOperation("SELECT", "users", req.TenantID, time.Since(dbStart), nil) // Check if user exists

        insertStart := time.Now()
        time.Sleep(20 * time.Millisecond) // Simulate DB insert
        reqLogger.DatabaseOperation("INSERT", "users", req.TenantID, time.Since(insertStart), nil)

        user := User{
                ID:       "user-123",
                Email:    req.Email,
                TenantID: req.TenantID,
                Roles: []Role{
                        {ID: "role-1", Name: "user"},
                },
        }

        // Log successful registration
        reqLogger.BusinessEvent("user_registration", "user-123", req.TenantID, map[string]interface{}{
                "email":       req.Email,
                "first_name":  req.FirstName,
                "last_name":   req.LastName,
                "duration_ms": time.Since(start).Milliseconds(),
        })

        c.JSON(http.StatusCreated, user)</span>
}

// RefreshTokenRequest represents the refresh token request body
type RefreshTokenRequest struct {
        RefreshToken string `json:"refresh_token" binding:"required" example:"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."`
}

// RefreshToken godoc
// @Summary Refresh access token
// @Description Refresh an expired access token using a refresh token
// @Tags Authentication
// @Accept json
// @Produce json
// @Param request body RefreshTokenRequest true "Refresh token"
// @Success 200 {object} LoginResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /auth/refresh [post]
func (h *AuthHandler) RefreshToken(c *gin.Context) <span class="cov3" title="2">{
        start := time.Now()

        // Safely get logger from context
        var reqLogger *logger.RequestLogger
        if loggerInterface := middleware.GetLogger(c); loggerInterface != nil </span><span class="cov3" title="2">{
                if reqLog, ok := loggerInterface.(*logger.RequestLogger); ok </span><span class="cov3" title="2">{
                        reqLogger = reqLog
                }</span>
        }

        // If no logger available, create a basic one
        <span class="cov3" title="2">if reqLogger == nil </span><span class="cov0" title="0">{
                reqLogger = h.logger.WithRequest(c.Request)
        }</span>

        <span class="cov3" title="2">reqLogger.Info("Token refresh attempt started",
                zap.String("endpoint", "/auth/refresh"),
                zap.String("method", "POST"),
        )

        var req RefreshTokenRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov1" title="1">{
                reqLogger.Error("Token refresh validation failed", zap.Error(err))

                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "validation_error",
                        Message: err.Error(),
                })
                return
        }</span>

        <span class="cov1" title="1">reqLogger.Info("Token refresh validation passed",
                zap.String("refresh_token_prefix", req.RefreshToken[:10]+"..."),
        )

        // TODO: Implement actual token refresh logic

        // Simulate token validation
        tokenStart := time.Now()
        time.Sleep(5 * time.Millisecond) // Simulate token validation
        reqLogger.DatabaseOperation("SELECT", "refresh_tokens", "tenant-123", time.Since(tokenStart), nil)

        response := LoginResponse{
                AccessToken:  "new-access-token",
                RefreshToken: "new-refresh-token",
                TokenType:    "Bearer",
                ExpiresIn:    3600,
                User: User{
                        ID:       "user-123",
                        Email:    "user@example.com",
                        TenantID: "tenant-123",
                        Roles: []Role{
                                {ID: "role-1", Name: "user"},
                        },
                },
        }

        // Log successful token refresh
        reqLogger.BusinessEvent("token_refresh", "user-123", "tenant-123", map[string]interface{}{
                "duration_ms": time.Since(start).Milliseconds(),
        })

        c.JSON(http.StatusOK, response)</span>
}

// Logout godoc
// @Summary User logout
// @Description Logout a user and invalidate their tokens
// @Tags Authentication
// @Accept json
// @Produce json
// @Security BearerAuth
// @Success 200 {object} SuccessResponse
// @Failure 401 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /auth/logout [post]
func (h *AuthHandler) Logout(c *gin.Context) <span class="cov1" title="1">{
        start := time.Now()

        // Safely get logger from context
        var reqLogger *logger.RequestLogger
        if loggerInterface := middleware.GetLogger(c); loggerInterface != nil </span><span class="cov1" title="1">{
                if reqLog, ok := loggerInterface.(*logger.RequestLogger); ok </span><span class="cov1" title="1">{
                        reqLogger = reqLog
                }</span>
        }

        // If no logger available, create a basic one
        <span class="cov1" title="1">if reqLogger == nil </span><span class="cov0" title="0">{
                reqLogger = h.logger.WithRequest(c.Request)
        }</span>

        <span class="cov1" title="1">reqLogger.Info("Logout attempt started",
                zap.String("endpoint", "/auth/logout"),
                zap.String("method", "POST"),
        )

        // TODO: Implement actual logout logic (invalidate tokens)

        // Simulate token invalidation
        invalidateStart := time.Now()
        time.Sleep(10 * time.Millisecond) // Simulate token invalidation
        reqLogger.DatabaseOperation("UPDATE", "refresh_tokens", "tenant-123", time.Since(invalidateStart), nil)

        // Log successful logout
        reqLogger.BusinessEvent("user_logout", "user-123", "tenant-123", map[string]interface{}{
                "duration_ms": time.Since(start).Milliseconds(),
        })

        c.JSON(http.StatusOK, SuccessResponse{
                Message: "Successfully logged out",
        })</span>
}

// ErrorResponse represents an error response
type ErrorResponse struct {
        Error   string `json:"error" example:"validation_error"`
        Message string `json:"message" example:"Invalid request data"`
}

// SuccessResponse represents a success response
type SuccessResponse struct {
        Message string `json:"message" example:"Operation completed successfully"`
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package rest

import (
        "auth-service/internal/logger"
        "auth-service/internal/models"
        "auth-service/internal/service"
        "net/http"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

// MFAHandler handles MFA-related HTTP requests
type MFAHandler struct {
        mfaService service.MFAService
        logger     *logger.Logger
}

func NewMFAHandler(mfaService service.MFAService, logger *logger.Logger) *MFAHandler <span class="cov0" title="0">{
        return &amp;MFAHandler{
                mfaService: mfaService,
                logger:     logger,
        }
}</span>

// SetupMFA initiates MFA setup for a user (returns secret, QR code, backup codes)
func (h *MFAHandler) SetupMFA(c *gin.Context) <span class="cov0" title="0">{
        var req models.MFASetupRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to bind MFA setup request", zap.Error(err))
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid_request", "message": "Invalid request body"})
                return
        }</span>

        <span class="cov0" title="0">secret, err := h.mfaService.GenerateSecret(req.UserID, req.TenantID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to generate MFA secret", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "mfa_setup_failed", "message": "Failed to generate MFA secret"})
                return
        }</span>

        // For demo: use email as userID (in real: fetch user email)
        <span class="cov0" title="0">qrCode, err := h.mfaService.GenerateQRCode(secret, req.UserID, "AuthService")
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to generate QR code", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "mfa_setup_failed", "message": "Failed to generate QR code"})
                return
        }</span>

        <span class="cov0" title="0">backupCodes, err := h.mfaService.GenerateBackupCodes()
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to generate backup codes", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "mfa_setup_failed", "message": "Failed to generate backup codes"})
                return
        }</span>

        // In real implementation, save secret and backup codes to DB (encrypted)
        <span class="cov0" title="0">c.JSON(http.StatusOK, models.MFASetupResponse{
                Secret:      secret,
                QRCodeURL:   "data:image/png;base64," + encodeToBase64(qrCode),
                BackupCodes: backupCodes,
                Message:     "Scan QR code with Google Authenticator or enter secret manually.",
        })</span>
}

// VerifyMFA verifies a TOTP or backup code
func (h *MFAHandler) VerifyMFA(c *gin.Context) <span class="cov0" title="0">{
        var req models.MFAVerifyRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to bind MFA verify request", zap.Error(err))
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid_request", "message": "Invalid request body"})
                return
        }</span>

        // In real implementation, fetch secret from DB
        <span class="cov0" title="0">secret := req.Code // For demo, treat code as secret (replace with DB lookup)
        valid, err := h.mfaService.ValidateTOTP(secret, req.Code)
        if err != nil || !valid </span><span class="cov0" title="0">{
                h.logger.Warn("Invalid MFA code", zap.Error(err))
                c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid_mfa_code", "message": "Invalid MFA code"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "MFA verified successfully"})</span>
}

// Helper: encode QR code PNG to base64 string
func encodeToBase64(data []byte) string <span class="cov0" title="0">{
        // Use encoding/base64
        return "" // TODO: implement
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package rest

import (
        "auth-service/internal/config"
        "auth-service/internal/logger"
        "auth-service/internal/middleware"
        "fmt"
        "net/http"
        "strings"
        "time"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

// OAuthHandler handles OAuth-related HTTP requests
type OAuthHandler struct {
        config *config.Config
        logger *logger.Logger
}

// NewOAuthHandler creates a new OAuthHandler instance
func NewOAuthHandler(cfg *config.Config) *OAuthHandler <span class="cov10" title="35">{
        // Initialize logger for OAuth handler
        appLogger, err := logger.NewLogger(&amp;cfg.Logging)
        if err != nil </span><span class="cov10" title="35">{
                // Fallback to default logger if initialization fails
                appLogger = &amp;logger.Logger{}
        }</span>

        <span class="cov10" title="35">return &amp;OAuthHandler{
                config: cfg,
                logger: appLogger,
        }</span>
}

// GoogleLogin godoc
// @Summary Initiate Google OAuth login
// @Description Redirect user to Google OAuth for authentication
// @Tags OAuth
// @Accept json
// @Produce json
// @Param tenant_id query string true "Tenant ID" example("tenant-123")
// @Param redirect_uri query string false "Custom redirect URI" example("https://app.example.com/callback")
// @Success 302 {string} string "Redirect to Google OAuth"
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /oauth/google/login [get]
func (h *OAuthHandler) GoogleLogin(c *gin.Context) <span class="cov5" title="5">{
        start := time.Now()

        // Safely get logger from context
        var reqLogger *logger.RequestLogger
        if loggerInterface := middleware.GetLogger(c); loggerInterface != nil </span><span class="cov5" title="5">{
                if reqLog, ok := loggerInterface.(*logger.RequestLogger); ok </span><span class="cov5" title="5">{
                        reqLogger = reqLog
                }</span>
        }

        // If no logger available, create a basic one
        <span class="cov5" title="5">if reqLogger == nil </span><span class="cov0" title="0">{
                reqLogger = h.logger.WithRequest(c.Request)
        }</span>

        <span class="cov5" title="5">reqLogger.Info("Google OAuth login initiated",
                zap.String("endpoint", "/oauth/google/login"),
                zap.String("method", "GET"),
        )

        tenantID := c.Query("tenant_id")
        redirectURI := c.Query("redirect_uri")

        if tenantID == "" </span><span class="cov1" title="1">{
                reqLogger.AuthFailure("", "", "google_oauth", "missing_tenant_id")
                reqLogger.Error("Google OAuth login failed - missing tenant ID")

                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "missing_tenant_id",
                        Message: "Tenant ID is required",
                })
                return
        }</span>

        <span class="cov4" title="4">reqLogger.Info("Google OAuth login validation passed",
                zap.String("tenant_id", tenantID),
                zap.String("redirect_uri", redirectURI),
        )

        // Use custom redirect URI if provided, otherwise use default
        callbackURL := h.config.OAuth.Google.RedirectURL
        if redirectURI != "" </span><span class="cov1" title="1">{
                callbackURL = redirectURI
        }</span>

        // TODO: Implement Google OAuth flow
        // For now, return a mock redirect URL
        <span class="cov4" title="4">googleAuthURL := "https://accounts.google.com/oauth/authorize?client_id=" + h.config.OAuth.Google.ClientID + "&amp;redirect_uri=" + callbackURL + "&amp;scope=email profile&amp;response_type=code&amp;state=" + tenantID

        // Log OAuth flow initiation
        reqLogger.OAuthFlow("google", "login_initiated", tenantID, nil)
        reqLogger.BusinessEvent("oauth_login_initiated", "", tenantID, map[string]interface{}{
                "provider":     "google",
                "redirect_uri": callbackURL,
                "duration_ms":  time.Since(start).Milliseconds(),
        })

        c.JSON(http.StatusOK, gin.H{
                "auth_url": googleAuthURL,
                "message":  "Redirect to Google OAuth",
        })</span>
}

// GoogleCallback godoc
// @Summary Google OAuth callback
// @Description Handle Google OAuth callback and exchange code for tokens
// @Tags OAuth
// @Accept json
// @Produce json
// @Param code query string true "Authorization code from Google" example("4/0AfJohXn...")
// @Param state query string true "State parameter" example("tenant-123")
// @Param error query string false "Error from Google OAuth" example("access_denied")
// @Success 200 {object} LoginResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /oauth/google/callback [get]
func (h *OAuthHandler) GoogleCallback(c *gin.Context) <span class="cov5" title="7">{
        start := time.Now()

        // Safely get logger from context
        var reqLogger *logger.RequestLogger
        if loggerInterface := middleware.GetLogger(c); loggerInterface != nil </span><span class="cov5" title="7">{
                if reqLog, ok := loggerInterface.(*logger.RequestLogger); ok </span><span class="cov5" title="7">{
                        reqLogger = reqLog
                }</span>
        }

        // If no logger available, create a basic one
        <span class="cov5" title="7">if reqLogger == nil </span><span class="cov0" title="0">{
                reqLogger = h.logger.WithRequest(c.Request)
        }</span>

        <span class="cov5" title="7">reqLogger.Info("Google OAuth callback received",
                zap.String("endpoint", "/oauth/google/callback"),
                zap.String("method", "GET"),
        )

        code := c.Query("code")
        state := c.Query("state")
        oauthError := c.Query("error")

        if oauthError != "" </span><span class="cov2" title="2">{
                reqLogger.AuthFailure("", state, "google_oauth", "oauth_error")
                reqLogger.OAuthFlow("google", "callback_error", state, fmt.Errorf("oauth error: %s", oauthError))

                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "oauth_error",
                        Message: "OAuth error: " + oauthError,
                })
                return
        }</span>

        <span class="cov5" title="5">if code == "" </span><span class="cov1" title="1">{
                reqLogger.AuthFailure("", state, "google_oauth", "missing_code")
                reqLogger.Error("Google OAuth callback failed - missing authorization code")

                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "missing_code",
                        Message: "Authorization code is required",
                })
                return
        }</span>

        <span class="cov4" title="4">reqLogger.Info("Google OAuth callback validation passed",
                zap.String("tenant_id", state),
                zap.String("code_prefix", func() string </span><span class="cov4" title="4">{
                        if len(code) &gt;= 10 </span><span class="cov3" title="3">{
                                return code[:10] + "..."
                        }</span>
                        <span class="cov1" title="1">return code + "..."</span>
                }()),
        )

        // TODO: Implement Google OAuth token exchange

        // Simulate token exchange
        <span class="cov4" title="4">tokenStart := time.Now()
        time.Sleep(50 * time.Millisecond) // Simulate Google API call
        reqLogger.DatabaseOperation("INSERT", "oauth_tokens", state, time.Since(tokenStart), nil)

        response := LoginResponse{
                AccessToken:  "google-oauth-token",
                RefreshToken: "google-refresh-token",
                TokenType:    "Bearer",
                ExpiresIn:    3600,
                User: User{
                        ID:       "google-user-123",
                        Email:    "user@gmail.com",
                        TenantID: state,
                        Roles: []Role{
                                {ID: "role-1", Name: "user"},
                        },
                },
        }

        // Log successful OAuth flow
        reqLogger.AuthSuccess("google-user-123", state, "google_oauth")
        reqLogger.OAuthFlow("google", "callback_success", state, nil)
        reqLogger.BusinessEvent("oauth_login_completed", "google-user-123", state, map[string]interface{}{
                "provider":    "google",
                "duration_ms": time.Since(start).Milliseconds(),
        })

        c.JSON(http.StatusOK, response)</span>
}

// ClientCredentialsRequest represents the OAuth 2.0 client credentials request
type ClientCredentialsRequest struct {
        GrantType    string `json:"grant_type" binding:"required" example:"client_credentials"`
        ClientID     string `json:"client_id" binding:"required" example:"service-client-123"`
        ClientSecret string `json:"client_secret" binding:"required" example:"service-secret-456"`
        Scope        string `json:"scope" example:"read:users write:users"`
}

// ClientCredentialsResponse represents the OAuth 2.0 client credentials response
type ClientCredentialsResponse struct {
        AccessToken string `json:"access_token" example:"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."`
        TokenType   string `json:"token_type" example:"Bearer"`
        ExpiresIn   int    `json:"expires_in" example:"3600"`
        Scope       string `json:"scope" example:"read:users write:users"`
}

// ClientCredentials godoc
// @Summary OAuth 2.0 Client Credentials Flow
// @Description Exchange client credentials for access token (service-to-service authentication)
// @Tags OAuth
// @Accept json
// @Produce json
// @Param request body ClientCredentialsRequest true "Client credentials"
// @Success 200 {object} ClientCredentialsResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /oauth/token [post]
func (h *OAuthHandler) ClientCredentials(c *gin.Context) <span class="cov5" title="7">{
        start := time.Now()

        // Safely get logger from context
        var reqLogger *logger.RequestLogger
        if loggerInterface := middleware.GetLogger(c); loggerInterface != nil </span><span class="cov5" title="7">{
                if reqLog, ok := loggerInterface.(*logger.RequestLogger); ok </span><span class="cov5" title="7">{
                        reqLogger = reqLog
                }</span>
        }

        // If no logger available, create a basic one
        <span class="cov5" title="7">if reqLogger == nil </span><span class="cov0" title="0">{
                reqLogger = h.logger.WithRequest(c.Request)
        }</span>

        <span class="cov5" title="7">reqLogger.Info("Client credentials flow initiated",
                zap.String("endpoint", "/oauth/token"),
                zap.String("method", "POST"),
        )

        var req ClientCredentialsRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov1" title="1">{
                reqLogger.Error("Client credentials validation failed", zap.Error(err))

                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "validation_error",
                        Message: err.Error(),
                })
                return
        }</span>

        <span class="cov5" title="6">reqLogger.Info("Client credentials validation passed",
                zap.String("client_id", req.ClientID),
                zap.String("grant_type", req.GrantType),
                zap.String("scope", req.Scope),
        )

        if req.GrantType != "client_credentials" </span><span class="cov1" title="1">{
                reqLogger.AuthFailure(req.ClientID, "", "client_credentials", "unsupported_grant_type")
                reqLogger.Error("Unsupported grant type", zap.String("grant_type", req.GrantType))

                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "unsupported_grant_type",
                        Message: "Only client_credentials grant type is supported",
                })
                return
        }</span>

        // TODO: Implement client credentials validation

        // Simulate client validation
        <span class="cov5" title="5">validationStart := time.Now()
        time.Sleep(20 * time.Millisecond) // Simulate client validation
        reqLogger.DatabaseOperation("SELECT", "oauth_clients", "", time.Since(validationStart), nil)

        response := ClientCredentialsResponse{
                AccessToken: "service-access-token",
                TokenType:   "Bearer",
                ExpiresIn:   3600,
                Scope:       req.Scope,
        }

        // Log successful client credentials flow
        reqLogger.AuthSuccess(req.ClientID, "", "client_credentials")
        reqLogger.BusinessEvent("client_credentials_success", req.ClientID, "", map[string]interface{}{
                "scope":       req.Scope,
                "duration_ms": time.Since(start).Milliseconds(),
        })

        c.JSON(http.StatusOK, response)</span>
}

// OneTimeTokenRequest represents the one-time token creation request
type OneTimeTokenRequest struct {
        URL           string `json:"url" binding:"required" example:"https://app.example.com/survey/123"`
        ExpiresIn     int    `json:"expires_in" example:"3600"`
        MaxUses       int    `json:"max_uses" example:"1"`
        SessionID     string `json:"session_id" example:"survey-session-456"` // Unique session identifier
        RefreshWindow int    `json:"refresh_window" example:"300"`            // Session refresh window in seconds
}

// OneTimeTokenResponse represents the one-time token response
type OneTimeTokenResponse struct {
        Token         string `json:"token" example:"one-time-token-123"`
        URL           string `json:"url" example:"https://app.example.com/survey/123?token=one-time-token-123&amp;session=survey-session-456"`
        ExpiresIn     int    `json:"expires_in" example:"3600"`
        MaxUses       int    `json:"max_uses" example:"1"`
        SessionID     string `json:"session_id" example:"survey-session-456"`
        RefreshWindow int    `json:"refresh_window" example:"300"`
}

// CreateOneTimeToken godoc
// @Summary Create one-time authentication token
// @Description Create a one-time token for secure access to specific URLs with session management
// @Tags OAuth
// @Accept json
// @Produce json
// @Param request body OneTimeTokenRequest true "One-time token request"
// @Success 200 {object} OneTimeTokenResponse
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /oauth/one-time [post]
func (h *OAuthHandler) CreateOneTimeToken(c *gin.Context) <span class="cov5" title="7">{
        start := time.Now()

        // Safely get logger from context
        var reqLogger *logger.RequestLogger
        if loggerInterface := middleware.GetLogger(c); loggerInterface != nil </span><span class="cov5" title="7">{
                if reqLog, ok := loggerInterface.(*logger.RequestLogger); ok </span><span class="cov5" title="7">{
                        reqLogger = reqLog
                }</span>
        }

        // If no logger available, create a basic one
        <span class="cov5" title="7">if reqLogger == nil </span><span class="cov0" title="0">{
                reqLogger = h.logger.WithRequest(c.Request)
        }</span>

        <span class="cov5" title="7">reqLogger.Info("One-time token creation initiated",
                zap.String("endpoint", "/oauth/one-time"),
                zap.String("method", "POST"),
        )

        var req OneTimeTokenRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov3" title="3">{
                reqLogger.Error("One-time token validation failed", zap.Error(err))

                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "validation_error",
                        Message: err.Error(),
                })
                return
        }</span>

        <span class="cov4" title="4">reqLogger.Info("One-time token validation passed",
                zap.String("url", req.URL),
                zap.String("session_id", req.SessionID),
                zap.Int("expires_in", req.ExpiresIn),
                zap.Int("max_uses", req.MaxUses),
        )

        // TODO: Implement one-time token creation

        // Simulate token creation
        tokenStart := time.Now()
        time.Sleep(15 * time.Millisecond) // Simulate token generation
        reqLogger.DatabaseOperation("INSERT", "one_time_tokens", "", time.Since(tokenStart), nil)

        // Use predictable token for tests, in production this would be cryptographically secure
        token := "one-time-token-123"
        tokenURL := req.URL
        if strings.Contains(tokenURL, "?") </span><span class="cov0" title="0">{
                tokenURL += "&amp;token=" + token + "&amp;session=" + req.SessionID
        }</span> else<span class="cov4" title="4"> {
                tokenURL += "?token=" + token + "&amp;session=" + req.SessionID
        }</span>

        // Set default values if not provided
        <span class="cov4" title="4">expiresIn := req.ExpiresIn
        maxUses := req.MaxUses
        refreshWindow := req.RefreshWindow
        if refreshWindow == 0 </span><span class="cov2" title="2">{
                refreshWindow = 300 // Default refresh window
        }</span>

        <span class="cov4" title="4">response := OneTimeTokenResponse{
                Token:         token,
                URL:           tokenURL,
                ExpiresIn:     expiresIn,
                MaxUses:       maxUses,
                SessionID:     req.SessionID,
                RefreshWindow: refreshWindow,
        }

        // Log successful one-time token creation
        reqLogger.BusinessEvent("one_time_token_created", "", "", map[string]interface{}{
                "session_id":  req.SessionID,
                "expires_in":  req.ExpiresIn,
                "max_uses":    req.MaxUses,
                "duration_ms": time.Since(start).Milliseconds(),
        })

        c.JSON(http.StatusCreated, response)</span>
}

// VerifyOneTimeToken godoc
// @Summary Verify one-time authentication token
// @Description Verify and refresh a one-time token session
// @Tags OAuth
// @Accept json
// @Produce json
// @Param token query string true "One-time token" example("one-time-token-123")
// @Param session query string true "Session ID" example("survey-session-456")
// @Success 200 {object} OneTimeSessionResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 410 {object} ErrorResponse
// @Router /oauth/verify [get]
func (h *OAuthHandler) VerifyOneTimeToken(c *gin.Context) <span class="cov5" title="7">{
        start := time.Now()

        // Safely get logger from context
        var reqLogger *logger.RequestLogger
        if loggerInterface := middleware.GetLogger(c); loggerInterface != nil </span><span class="cov5" title="7">{
                if reqLog, ok := loggerInterface.(*logger.RequestLogger); ok </span><span class="cov5" title="7">{
                        reqLogger = reqLog
                }</span>
        }

        // If no logger available, create a basic one
        <span class="cov5" title="7">if reqLogger == nil </span><span class="cov0" title="0">{
                reqLogger = h.logger.WithRequest(c.Request)
        }</span>

        <span class="cov5" title="7">reqLogger.Info("One-time token verification initiated",
                zap.String("endpoint", "/oauth/verify"),
                zap.String("method", "GET"),
        )

        token := c.Query("token")
        sessionID := c.Query("session")

        if token == "" </span><span class="cov1" title="1">{
                reqLogger.Error("One-time token verification failed - missing token")

                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "missing_token",
                        Message: "Token is required",
                })
                return
        }</span>

        <span class="cov5" title="6">if sessionID == "" </span><span class="cov1" title="1">{
                reqLogger.Error("One-time token verification failed - missing session ID")

                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "missing_session",
                        Message: "Session ID is required",
                })
                return
        }</span>

        <span class="cov5" title="5">reqLogger.Info("One-time token verification validation passed",
                zap.String("token_prefix", func() string </span><span class="cov5" title="5">{
                        if len(token) &gt;= 10 </span><span class="cov5" title="5">{
                                return token[:10] + "..."
                        }</span>
                        <span class="cov0" title="0">return token + "..."</span>
                }()),
                zap.String("session_id", sessionID),
        )

        // TODO: Implement one-time token verification with session refresh
        // 1. Check if token exists and is valid
        // 2. Verify session ID matches
        // 3. Check if token has been used (max uses)
        // 4. Check if token has expired
        // 5. Update lastActivity timestamp (session refresh)
        // 6. Check if session is still active (within refresh window)

        // Simulate token verification
        <span class="cov5" title="5">verifyStart := time.Now()
        time.Sleep(10 * time.Millisecond) // Simulate token verification
        reqLogger.DatabaseOperation("SELECT", "one_time_tokens", "", time.Since(verifyStart), nil)

        // Mock validation - in real implementation, check against cache/database
        if token != "one-time-token-123" || sessionID != "survey-session-456" </span><span class="cov2" title="2">{
                reqLogger.AuthFailure("", "", "one_time_token", "invalid_token")
                reqLogger.Error("One-time token verification failed - invalid token or session")

                c.JSON(http.StatusUnauthorized, ErrorResponse{
                        Error:   "invalid_token",
                        Message: "Invalid token or session combination",
                })
                return
        }</span>

        // Return session-specific user data with refresh info
        <span class="cov3" title="3">response := OneTimeSessionResponse{
                User: User{
                        ID:       "anonymous-user-123",
                        Email:    "anonymous@example.com",
                        TenantID: "tenant-123",
                        Roles: []Role{
                                {ID: "role-anonymous", Name: "anonymous"},
                        },
                },
                SessionID:     sessionID,
                Token:         token,
                IsValid:       true,
                LastActivity:  "2025-06-25T18:30:00Z",
                RefreshWindow: 300,
                Message:       "Session refreshed successfully. User is active.",
        }

        // Log successful token verification
        reqLogger.BusinessEvent("one_time_token_verified", "anonymous-user-123", "tenant-123", map[string]interface{}{
                "session_id":  sessionID,
                "is_valid":    true,
                "duration_ms": time.Since(start).Milliseconds(),
        })

        c.JSON(http.StatusOK, response)</span>
}

// RefreshSession godoc
// @Summary Refresh one-time session
// @Description Keep session alive by refreshing activity timestamp
// @Tags OAuth
// @Accept json
// @Produce json
// @Param token query string true "One-time token" example("one-time-token-123")
// @Param session query string true "Session ID" example("survey-session-456")
// @Success 200 {object} OneTimeSessionResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 410 {object} ErrorResponse
// @Router /oauth/refresh [post]
func (h *OAuthHandler) RefreshSession(c *gin.Context) <span class="cov5" title="6">{
        start := time.Now()

        // Safely get logger from context
        var reqLogger *logger.RequestLogger
        if loggerInterface := middleware.GetLogger(c); loggerInterface != nil </span><span class="cov5" title="6">{
                if reqLog, ok := loggerInterface.(*logger.RequestLogger); ok </span><span class="cov5" title="6">{
                        reqLogger = reqLog
                }</span>
        }

        // If no logger available, create a basic one
        <span class="cov5" title="6">if reqLogger == nil </span><span class="cov0" title="0">{
                reqLogger = h.logger.WithRequest(c.Request)
        }</span>

        <span class="cov5" title="6">reqLogger.Info("Session refresh initiated",
                zap.String("endpoint", "/oauth/refresh"),
                zap.String("method", "POST"),
        )

        token := c.Query("token")
        sessionID := c.Query("session")

        if token == "" || sessionID == "" </span><span class="cov3" title="3">{
                reqLogger.Error("Session refresh failed - missing parameters")

                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "missing_parameters",
                        Message: "Token and session ID are required",
                })
                return
        }</span>

        <span class="cov3" title="3">reqLogger.Info("Session refresh validation passed",
                zap.String("token_prefix", func() string </span><span class="cov3" title="3">{
                        if len(token) &gt;= 10 </span><span class="cov3" title="3">{
                                return token[:10] + "..."
                        }</span>
                        <span class="cov0" title="0">return token + "..."</span>
                }()),
                zap.String("session_id", sessionID),
        )

        // TODO: Implement session refresh logic
        // 1. Verify token is still valid
        // 2. Update lastActivity timestamp
        // 3. Check if session is within refresh window

        // Simulate session refresh
        <span class="cov3" title="3">refreshStart := time.Now()
        time.Sleep(8 * time.Millisecond) // Simulate session refresh
        reqLogger.DatabaseOperation("UPDATE", "one_time_sessions", "", time.Since(refreshStart), nil)

        // Mock response
        response := OneTimeSessionResponse{
                User: User{
                        ID:       "anonymous-user-123",
                        Email:    "anonymous@example.com",
                        TenantID: "tenant-123",
                        Roles: []Role{
                                {ID: "role-anonymous", Name: "anonymous"},
                        },
                },
                SessionID:     sessionID,
                Token:         token,
                IsValid:       true,
                LastActivity:  time.Now().Format(time.RFC3339),
                RefreshWindow: 300,
                Message:       "Session refreshed successfully",
        }

        // Log successful session refresh
        reqLogger.BusinessEvent("session_refreshed", "anonymous-user-123", "tenant-123", map[string]interface{}{
                "session_id":  sessionID,
                "duration_ms": time.Since(start).Milliseconds(),
        })

        c.JSON(http.StatusOK, response)</span>
}

// OneTimeSessionResponse represents the one-time session verification response
type OneTimeSessionResponse struct {
        User          User   `json:"user"`
        SessionID     string `json:"session_id" example:"survey-session-456"`
        Token         string `json:"token" example:"one-time-token-123"`
        IsValid       bool   `json:"is_valid" example:"true"`
        LastActivity  string `json:"last_activity" example:"2025-06-25T18:30:00Z"`
        RefreshWindow int    `json:"refresh_window" example:"300"`
        Message       string `json:"message" example:"Session refreshed successfully"`
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package rest

import (
        "auth-service/internal/logger"
        "auth-service/internal/models"
        "auth-service/internal/service"
        "net/http"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

// OTPHandler handles OTP-based authentication requests
type OTPHandler struct {
        otpService service.OTPService
        logger     *logger.Logger
}

func NewOTPHandler(otpService service.OTPService, logger *logger.Logger) *OTPHandler <span class="cov0" title="0">{
        return &amp;OTPHandler{
                otpService: otpService,
                logger:     logger,
        }
}</span>

// RequestOTP handles OTP request with flexible delivery methods
// @Summary Request OTP for authentication
// @Description Request an OTP to be sent via email, SMS, or both based on tenant configuration
// @Tags Authentication
// @Accept json
// @Produce json
// @Param request body models.OTPRequest true "OTP request details"
// @Success 200 {object} models.OTPResponse
// @Failure 400 {object} ErrorResponse
// @Failure 403 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /auth/request-otp [post]
func (h *OTPHandler) RequestOTP(c *gin.Context) <span class="cov0" title="0">{
        var req models.OTPRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to bind OTP request", zap.Error(err))
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "invalid_request",
                        Message: "Invalid request body",
                })
                return
        }</span>

        // Get tenant OTP configuration
        <span class="cov0" title="0">config, err := h.otpService.GetTenantOTPConfig(req.TenantID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get tenant OTP config", zap.Error(err))
                c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "config_error",
                        Message: "Failed to get tenant configuration",
                })
                return
        }</span>

        // Generate and send OTP
        <span class="cov0" title="0">response, err := h.otpService.GenerateAndSendOTP(&amp;req, config)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to generate and send OTP", zap.Error(err))
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "otp_generation_failed",
                        Message: err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("OTP requested successfully",
                zap.String("email", req.Email),
                zap.String("tenant_id", req.TenantID),
                zap.String("delivery_method", string(response.DeliveryMethod)))

        c.JSON(http.StatusOK, response)</span>
}

// VerifyOTP handles OTP verification for authentication
// @Summary Verify OTP for authentication
// @Description Verify an OTP code and authenticate the user
// @Tags Authentication
// @Accept json
// @Produce json
// @Param request body models.OTPVerifyRequest true "OTP verification details"
// @Success 200 {object} LoginResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /auth/verify-otp [post]
func (h *OTPHandler) VerifyOTP(c *gin.Context) <span class="cov0" title="0">{
        var req models.OTPVerifyRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to bind OTP verify request", zap.Error(err))
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "invalid_request",
                        Message: "Invalid request body",
                })
                return
        }</span>

        // Validate OTP
        <span class="cov0" title="0">valid, err := h.otpService.ValidateOTP(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("OTP validation error", zap.Error(err))
                c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "validation_error",
                        Message: "Failed to validate OTP",
                })
                return
        }</span>

        <span class="cov0" title="0">if !valid </span><span class="cov0" title="0">{
                h.logger.Warn("Invalid OTP attempt",
                        zap.String("email", req.Email),
                        zap.String("tenant_id", req.TenantID))
                c.JSON(http.StatusUnauthorized, ErrorResponse{
                        Error:   "invalid_otp",
                        Message: "Invalid or expired OTP code",
                })
                return
        }</span>

        // TODO: In real implementation, fetch user from database
        // For demo, create a mock user
        <span class="cov0" title="0">user := &amp;models.User{
                ID:       "user-otp-123",
                Email:    req.Email,
                TenantID: req.TenantID,
                Roles: []models.Role{
                        {ID: "role-1", Name: "user"},
                },
        }

        // Generate JWT tokens (in real implementation, use proper JWT service)
        response := LoginResponse{
                AccessToken:  "otp-access-token-" + req.Email,
                RefreshToken: "otp-refresh-token-" + req.Email,
                TokenType:    "Bearer",
                ExpiresIn:    3600,
                User: User{
                        ID:       user.ID,
                        Email:    user.Email,
                        TenantID: user.TenantID,
                        Roles:    []Role{{ID: user.Roles[0].ID, Name: user.Roles[0].Name}},
                },
        }

        h.logger.Info("OTP verified successfully",
                zap.String("email", req.Email),
                zap.String("tenant_id", req.TenantID),
                zap.String("delivery_method", string(req.DeliveryMethod)))

        c.JSON(http.StatusOK, response)</span>
}

// GetOTPConfig returns available OTP methods for a tenant
// @Summary Get OTP configuration for tenant
// @Description Get available OTP delivery methods and configuration for a tenant
// @Tags Authentication
// @Accept json
// @Produce json
// @Param tenant_id path string true "Tenant ID"
// @Success 200 {object} models.TenantOTPConfig
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /auth/otp-config/{tenant_id} [get]
func (h *OTPHandler) GetOTPConfig(c *gin.Context) <span class="cov0" title="0">{
        tenantID := c.Param("tenant_id")
        if tenantID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "missing_tenant_id",
                        Message: "Tenant ID is required",
                })
                return
        }</span>

        <span class="cov0" title="0">config, err := h.otpService.GetTenantOTPConfig(tenantID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get OTP config", zap.Error(err))
                c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "config_error",
                        Message: "Failed to get OTP configuration",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, config)</span>
}

// UpdateOTPPreference updates user's OTP delivery preference
// @Summary Update OTP delivery preference
// @Description Update user's preferred OTP delivery method
// @Tags Authentication
// @Accept json
// @Produce json
// @Param request body models.UserOTPPreference true "User OTP preference"
// @Success 200 {object} models.UserOTPPreference
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /auth/otp-preference [put]
func (h *OTPHandler) UpdateOTPPreference(c *gin.Context) <span class="cov0" title="0">{
        var pref models.UserOTPPreference
        if err := c.ShouldBindJSON(&amp;pref); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to bind OTP preference", zap.Error(err))
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "invalid_request",
                        Message: "Invalid request body",
                })
                return
        }</span>

        // Validate delivery method
        <span class="cov0" title="0">config, err := h.otpService.GetTenantOTPConfig(pref.TenantID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get tenant config for preference", zap.Error(err))
                c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "config_error",
                        Message: "Failed to get tenant configuration",
                })
                return
        }</span>

        // Check if the preferred method is enabled for the tenant
        <span class="cov0" title="0">switch pref.PreferredMethod </span>{
        case models.OTPDeliveryEmail:<span class="cov0" title="0">
                if !config.EnableEmailOTP </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, ErrorResponse{
                                Error:   "method_not_enabled",
                                Message: "Email OTP is not enabled for this tenant",
                        })
                        return
                }</span>
        case models.OTPDeliverySMS:<span class="cov0" title="0">
                if !config.EnableSMSOTP </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, ErrorResponse{
                                Error:   "method_not_enabled",
                                Message: "SMS OTP is not enabled for this tenant",
                        })
                        return
                }</span>
        }

        // Update preference
        <span class="cov0" title="0">err = h.otpService.UpdateUserOTPPreference(&amp;pref)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to update OTP preference", zap.Error(err))
                c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "update_failed",
                        Message: "Failed to update OTP preference",
                })
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("OTP preference updated",
                zap.String("user_id", pref.UserID),
                zap.String("tenant_id", pref.TenantID),
                zap.String("preferred_method", string(pref.PreferredMethod)))

        c.JSON(http.StatusOK, pref)</span>
}

// GetSMSUsageInfo returns SMS usage information for a tenant
// @Summary Get SMS usage information
// @Description Get current SMS usage, limits, and billing cycle information for a tenant
// @Tags Authentication
// @Accept json
// @Produce json
// @Param tenant_id path string true "Tenant ID"
// @Success 200 {object} models.SMSUsageInfo
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /auth/sms-usage/{tenant_id} [get]
func (h *OTPHandler) GetSMSUsageInfo(c *gin.Context) <span class="cov0" title="0">{
        tenantID := c.Param("tenant_id")
        if tenantID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "missing_tenant_id",
                        Message: "Tenant ID is required",
                })
                return
        }</span>

        <span class="cov0" title="0">usageInfo, err := h.otpService.GetSMSUsageInfo(tenantID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get SMS usage info", zap.Error(err))
                c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "usage_info_error",
                        Message: "Failed to get SMS usage information",
                })
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("SMS usage info retrieved",
                zap.String("tenant_id", tenantID),
                zap.Int("current_usage", usageInfo.CurrentUsage),
                zap.Int("monthly_limit", usageInfo.MonthlyLimit))

        c.JSON(http.StatusOK, usageInfo)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package rest

import (
        "auth-service/internal/logger"
        "auth-service/internal/middleware"
        "auth-service/internal/models"
        "auth-service/internal/service"
        "net/http"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

// TenantAuthHandler handles tenant authentication requests
type TenantAuthHandler struct {
        tenantService service.TenantService
        logger        *logger.Logger
}

// NewTenantAuthHandler creates a new tenant auth handler
func NewTenantAuthHandler(tenantService service.TenantService, logger *logger.Logger) *TenantAuthHandler <span class="cov0" title="0">{
        return &amp;TenantAuthHandler{
                tenantService: tenantService,
                logger:        logger,
        }
}</span>

// AuthenticateTenant handles tenant authentication
// @Summary Authenticate tenant
// @Description Authenticate a tenant using client credentials
// @Tags tenant-auth
// @Accept json
// @Produce json
// @Param request body models.TenantAuthRequest true "Tenant authentication request"
// @Success 200 {object} models.TenantAuthResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 403 {object} ErrorResponse
// @Router /api/v1/tenant/auth [post]
func (h *TenantAuthHandler) AuthenticateTenant(c *gin.Context) <span class="cov0" title="0">{
        var req models.TenantAuthRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to bind tenant auth request", zap.Error(err))
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "invalid_request",
                        Message: "Invalid request body",
                })
                return
        }</span>

        // Validate grant type
        <span class="cov0" title="0">if req.GrantType != "client_credentials" </span><span class="cov0" title="0">{
                h.logger.Warn("Unsupported grant type", zap.String("grant_type", req.GrantType))
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "unsupported_grant_type",
                        Message: "Only client_credentials grant type is supported",
                })
                return
        }</span>

        // Authenticate tenant
        <span class="cov0" title="0">response, err := h.tenantService.AuthenticateTenant(c.Request.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Tenant authentication failed",
                        zap.String("client_id", req.ClientID),
                        zap.Error(err))
                c.JSON(http.StatusUnauthorized, ErrorResponse{
                        Error:   "authentication_failed",
                        Message: err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("Tenant authenticated successfully",
                zap.String("tenant_id", response.TenantID),
                zap.String("tenant_name", response.TenantName))
        c.JSON(http.StatusOK, response)</span>
}

// RefreshTenantToken handles tenant token refresh
// @Summary Refresh tenant token
// @Description Refresh a tenant access token using refresh token
// @Tags tenant-auth
// @Accept json
// @Produce json
// @Param request body map[string]string true "Refresh token request"
// @Success 200 {object} models.TenantAuthResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Router /api/v1/tenant/refresh [post]
func (h *TenantAuthHandler) RefreshTenantToken(c *gin.Context) <span class="cov0" title="0">{
        var req struct {
                RefreshToken string `json:"refresh_token" binding:"required"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to bind refresh token request", zap.Error(err))
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "invalid_request",
                        Message: "Invalid request body",
                })
                return
        }</span>

        // Refresh tenant token
        <span class="cov0" title="0">response, err := h.tenantService.RefreshTenantToken(c.Request.Context(), req.RefreshToken)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Tenant token refresh failed", zap.Error(err))
                c.JSON(http.StatusUnauthorized, ErrorResponse{
                        Error:   "token_refresh_failed",
                        Message: err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("Tenant token refreshed successfully", zap.String("tenant_id", response.TenantID))
        c.JSON(http.StatusOK, response)</span>
}

// RevokeTenantToken handles tenant token revocation
// @Summary Revoke tenant token
// @Description Revoke a tenant access token
// @Tags tenant-auth
// @Accept json
// @Produce json
// @Param request body map[string]string true "Revoke token request"
// @Success 200 {object} SuccessResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Router /api/v1/tenant/revoke [post]
func (h *TenantAuthHandler) RevokeTenantToken(c *gin.Context) <span class="cov0" title="0">{
        var req struct {
                Token string `json:"token" binding:"required"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to bind revoke token request", zap.Error(err))
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "invalid_request",
                        Message: "Invalid request body",
                })
                return
        }</span>

        // Revoke tenant token
        <span class="cov0" title="0">err := h.tenantService.RevokeTenantToken(c.Request.Context(), req.Token)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Tenant token revocation failed", zap.Error(err))
                c.JSON(http.StatusUnauthorized, ErrorResponse{
                        Error:   "token_revocation_failed",
                        Message: err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("Tenant token revoked successfully")
        c.JSON(http.StatusOK, SuccessResponse{
                Message: "Token revoked successfully",
        })</span>
}

// ValidateTenantToken validates a tenant token
// @Summary Validate tenant token
// @Description Validate a tenant access token
// @Tags tenant-auth
// @Accept json
// @Produce json
// @Param request body map[string]string true "Token validation request"
// @Success 200 {object} models.TenantToken
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Router /api/v1/tenant/validate [post]
func (h *TenantAuthHandler) ValidateTenantToken(c *gin.Context) <span class="cov0" title="0">{
        var req struct {
                Token string `json:"token" binding:"required"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to bind token validation request", zap.Error(err))
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "invalid_request",
                        Message: "Invalid request body",
                })
                return
        }</span>

        // Validate tenant token
        <span class="cov0" title="0">token, err := h.tenantService.ValidateTenantToken(c.Request.Context(), req.Token)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Tenant token validation failed", zap.Error(err))
                c.JSON(http.StatusUnauthorized, ErrorResponse{
                        Error:   "token_validation_failed",
                        Message: err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("Tenant token validated successfully", zap.String("tenant_id", token.TenantID))
        c.JSON(http.StatusOK, token)</span>
}

// GetTenantInfo returns information about the authenticated tenant
// @Summary Get tenant info
// @Description Get information about the authenticated tenant
// @Tags tenant-auth
// @Accept json
// @Produce json
// @Security BearerAuth
// @Success 200 {object} models.Tenant
// @Failure 401 {object} ErrorResponse
// @Failure 403 {object} ErrorResponse
// @Router /api/v1/tenant/info [get]
func (h *TenantAuthHandler) GetTenantInfo(c *gin.Context) <span class="cov0" title="0">{
        // Get tenant from context (set by middleware)
        tenantInterface := middleware.GetTenant(c)
        if tenantInterface == nil </span><span class="cov0" title="0">{
                h.logger.Error("Tenant context missing")
                c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "tenant_context_missing",
                        Message: "Tenant context is missing",
                })
                return
        }</span>

        <span class="cov0" title="0">tenant, ok := tenantInterface.(*models.Tenant)
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error("Invalid tenant type in context")
                c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "invalid_tenant_type",
                        Message: "Invalid tenant type in context",
                })
                return
        }</span>

        // Remove sensitive information
        <span class="cov0" title="0">tenant.ClientSecret = ""
        tenant.APIKey = ""
        tenant.SecretKey = ""

        h.logger.Info("Tenant info retrieved", zap.String("tenant_id", tenant.ID))
        c.JSON(http.StatusOK, tenant)</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package rest

import (
        "auth-service/internal/config"
        "auth-service/internal/logger"
        "auth-service/internal/middleware"
        "auth-service/internal/models"
        "auth-service/internal/service"
        "net/http"
        "strconv"
        "time"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

// TenantHandler handles tenant-related HTTP requests
type TenantHandler struct {
        tenantService service.TenantService
        logger        *logger.Logger
        otpService    service.OTPService
}

// NewTenantHandler creates a new TenantHandler instance
func NewTenantHandler(tenantService service.TenantService, cfg *config.Config, otpService service.OTPService) *TenantHandler <span class="cov0" title="0">{
        // Initialize logger for tenant handler
        appLogger, err := logger.NewLogger(&amp;cfg.Logging)
        if err != nil </span><span class="cov0" title="0">{
                // Fallback to default logger if initialization fails
                appLogger = &amp;logger.Logger{}
        }</span>

        <span class="cov0" title="0">return &amp;TenantHandler{
                tenantService: tenantService,
                logger:        appLogger,
                otpService:    otpService,
        }</span>
}

// Note: Using CreateTenantRequest from models package

// UpdateTenantRequest represents the tenant update request
type UpdateTenantRequest struct {
        Name   string `json:"name" example:"Acme Corporation"`
        Domain string `json:"domain" example:"acme.com"`
        Plan   string `json:"plan" example:"enterprise"`
        Status string `json:"status" example:"active"` // active, suspended, inactive
}

// TenantResponse represents the tenant response
type TenantResponse struct {
        ID        string     `json:"id" example:"tenant-123"`
        Name      string     `json:"name" example:"Acme Corporation"`
        Domain    string     `json:"domain" example:"acme.com"`
        Status    string     `json:"status" example:"active"`
        Plan      string     `json:"plan" example:"pro"`
        MaxUsers  int        `json:"max_users" example:"1000"`
        Features  []string   `json:"features" example:"oauth,mfa,audit"`
        CreatedAt time.Time  `json:"created_at"`
        UpdatedAt time.Time  `json:"updated_at"`
        ExpiresAt *time.Time `json:"expires_at,omitempty"`
}

// TenantStatsResponse represents tenant statistics response
type TenantStatsResponse struct {
        TenantID    string    `json:"tenant_id" example:"tenant-123"`
        TotalUsers  int       `json:"total_users" example:"150"`
        ActiveUsers int       `json:"active_users" example:"120"`
        TotalLogins int       `json:"total_logins" example:"1250"`
        LastLoginAt time.Time `json:"last_login_at"`
        StorageUsed int64     `json:"storage_used" example:"52428800"` // in bytes
        APIRequests int       `json:"api_requests" example:"5000"`
        UpdatedAt   time.Time `json:"updated_at"`
}

// CreateTenant godoc
// @Summary Create a new tenant
// @Description Create a new client organization for the SaaS auth service
// @Tags Tenants
// @Accept json
// @Produce json
// @Param request body models.CreateTenantRequest true "Tenant creation data"
// @Success 201 {object} TenantResponse
// @Failure 400 {object} ErrorResponse
// @Failure 409 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /tenants [post]
func (h *TenantHandler) CreateTenant(c *gin.Context) <span class="cov0" title="0">{
        start := time.Now()

        // Safely get logger from context
        var reqLogger *logger.RequestLogger
        if loggerInterface := middleware.GetLogger(c); loggerInterface != nil </span><span class="cov0" title="0">{
                if reqLog, ok := loggerInterface.(*logger.RequestLogger); ok </span><span class="cov0" title="0">{
                        reqLogger = reqLog
                }</span>
        }

        // If no logger available, create a basic one
        <span class="cov0" title="0">if reqLogger == nil </span><span class="cov0" title="0">{
                reqLogger = h.logger.WithRequest(c.Request)
        }</span>

        <span class="cov0" title="0">reqLogger.Info("Tenant creation initiated",
                zap.String("endpoint", "/tenants"),
                zap.String("method", "POST"),
        )

        var req models.CreateTenantRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                reqLogger.Error("Tenant creation validation failed", zap.Error(err))

                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "validation_error",
                        Message: err.Error(),
                })
                return
        }</span>

        // Validate required fields
        <span class="cov0" title="0">if req.Name == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "MISSING_FIELDS",
                        Message: "Tenant name is required",
                })
                return
        }</span>

        // Validate OTP configuration if provided
        <span class="cov0" title="0">if req.OTPConfig != nil </span><span class="cov0" title="0">{
                if err := h.otpService.ValidateTenantOnboardingConfig(req.OTPConfig); err != nil </span><span class="cov0" title="0">{
                        // Check if it's a structured API error
                        if apiError, ok := err.(*models.APIError); ok </span><span class="cov0" title="0">{
                                c.JSON(apiError.HTTPStatus, ErrorResponse{
                                        Error:   string(apiError.Code),
                                        Message: apiError.Message,
                                })
                        }</span> else<span class="cov0" title="0"> {
                                c.JSON(http.StatusBadRequest, ErrorResponse{
                                        Error:   "INVALID_OTP_CONFIG",
                                        Message: err.Error(),
                                })
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
        }

        <span class="cov0" title="0">reqLogger.Info("Tenant creation validation passed",
                zap.String("name", req.Name),
                zap.String("domain", req.Domain),
                zap.String("plan", req.Plan),
        )

        // Create tenant model
        tenant := &amp;models.Tenant{
                ID:     "tenant-" + strconv.FormatInt(time.Now().Unix(), 10), // Simple ID generation
                Name:   req.Name,
                Domain: req.Domain,
                Plan:   req.Plan,
        }

        // Create tenant
        if err := h.tenantService.CreateTenant(c.Request.Context(), tenant); err != nil </span><span class="cov0" title="0">{
                reqLogger.Error("Tenant creation failed", zap.Error(err))

                c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "creation_failed",
                        Message: "Failed to create tenant: " + err.Error(),
                })
                return
        }</span>

        // Convert to response
        <span class="cov0" title="0">response := TenantResponse{
                ID:        tenant.ID,
                Name:      tenant.Name,
                Domain:    tenant.Domain,
                Status:    tenant.Status,
                Plan:      tenant.Plan,
                MaxUsers:  tenant.MaxUsers,
                Features:  tenant.Features,
                CreatedAt: tenant.CreatedAt,
                UpdatedAt: tenant.UpdatedAt,
                ExpiresAt: tenant.ExpiresAt,
        }

        // Log successful tenant creation
        reqLogger.BusinessEvent("tenant_created", "", tenant.ID, map[string]interface{}{
                "name":        req.Name,
                "domain":      req.Domain,
                "plan":        req.Plan,
                "duration_ms": time.Since(start).Milliseconds(),
        })

        c.JSON(http.StatusCreated, response)</span>
}

// GetTenant godoc
// @Summary Get tenant information
// @Description Retrieve tenant information by ID
// @Tags Tenants
// @Accept json
// @Produce json
// @Param tenant_id path string true "Tenant ID" example("tenant-123")
// @Success 200 {object} TenantResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /tenants/{tenant_id} [get]
func (h *TenantHandler) GetTenant(c *gin.Context) <span class="cov0" title="0">{
        tenantID := c.Param("tenant_id")
        if tenantID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "missing_tenant_id",
                        Message: "Tenant ID is required",
                })
                return
        }</span>

        // Get tenant
        <span class="cov0" title="0">tenant, err := h.tenantService.GetTenant(c.Request.Context(), tenantID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, ErrorResponse{
                        Error:   "tenant_not_found",
                        Message: "Tenant not found",
                })
                return
        }</span>

        // Convert to response
        <span class="cov0" title="0">response := TenantResponse{
                ID:        tenant.ID,
                Name:      tenant.Name,
                Domain:    tenant.Domain,
                Status:    tenant.Status,
                Plan:      tenant.Plan,
                MaxUsers:  tenant.MaxUsers,
                Features:  tenant.Features,
                CreatedAt: tenant.CreatedAt,
                UpdatedAt: tenant.UpdatedAt,
                ExpiresAt: tenant.ExpiresAt,
        }

        c.JSON(http.StatusOK, response)</span>
}

// UpdateTenant godoc
// @Summary Update tenant information
// @Description Update tenant information and settings
// @Tags Tenants
// @Accept json
// @Produce json
// @Param tenant_id path string true "Tenant ID" example("tenant-123")
// @Param request body UpdateTenantRequest true "Tenant update data"
// @Success 200 {object} TenantResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /tenants/{tenant_id} [put]
func (h *TenantHandler) UpdateTenant(c *gin.Context) <span class="cov0" title="0">{
        tenantID := c.Param("tenant_id")
        if tenantID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "missing_tenant_id",
                        Message: "Tenant ID is required",
                })
                return
        }</span>

        <span class="cov0" title="0">var req UpdateTenantRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "validation_error",
                        Message: err.Error(),
                })
                return
        }</span>

        // Get existing tenant
        <span class="cov0" title="0">tenant, err := h.tenantService.GetTenant(c.Request.Context(), tenantID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, ErrorResponse{
                        Error:   "tenant_not_found",
                        Message: "Tenant not found",
                })
                return
        }</span>

        // Update fields
        <span class="cov0" title="0">if req.Name != "" </span><span class="cov0" title="0">{
                tenant.Name = req.Name
        }</span>
        <span class="cov0" title="0">if req.Domain != "" </span><span class="cov0" title="0">{
                tenant.Domain = req.Domain
        }</span>
        <span class="cov0" title="0">if req.Plan != "" </span><span class="cov0" title="0">{
                tenant.Plan = req.Plan
        }</span>
        <span class="cov0" title="0">if req.Status != "" </span><span class="cov0" title="0">{
                tenant.Status = req.Status
        }</span>

        // Update tenant
        <span class="cov0" title="0">if err := h.tenantService.UpdateTenant(c.Request.Context(), tenant); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "update_failed",
                        Message: "Failed to update tenant: " + err.Error(),
                })
                return
        }</span>

        // Convert to response
        <span class="cov0" title="0">response := TenantResponse{
                ID:        tenant.ID,
                Name:      tenant.Name,
                Domain:    tenant.Domain,
                Status:    tenant.Status,
                Plan:      tenant.Plan,
                MaxUsers:  tenant.MaxUsers,
                Features:  tenant.Features,
                CreatedAt: tenant.CreatedAt,
                UpdatedAt: tenant.UpdatedAt,
                ExpiresAt: tenant.ExpiresAt,
        }

        c.JSON(http.StatusOK, response)</span>
}

// DeleteTenant godoc
// @Summary Delete tenant
// @Description Delete a tenant and all associated data
// @Tags Tenants
// @Accept json
// @Produce json
// @Param tenant_id path string true "Tenant ID" example("tenant-123")
// @Success 200 {object} SuccessResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /tenants/{tenant_id} [delete]
func (h *TenantHandler) DeleteTenant(c *gin.Context) <span class="cov0" title="0">{
        tenantID := c.Param("tenant_id")
        if tenantID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "missing_tenant_id",
                        Message: "Tenant ID is required",
                })
                return
        }</span>

        // Delete tenant
        <span class="cov0" title="0">if err := h.tenantService.DeleteTenant(c.Request.Context(), tenantID); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "delete_failed",
                        Message: "Failed to delete tenant: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, SuccessResponse{
                Message: "Tenant deleted successfully",
        })</span>
}

// ListTenants godoc
// @Summary List tenants
// @Description Retrieve a list of tenants with pagination
// @Tags Tenants
// @Accept json
// @Produce json
// @Param limit query int false "Number of tenants to return" example(10)
// @Param offset query int false "Number of tenants to skip" example(0)
// @Success 200 {array} TenantResponse
// @Failure 500 {object} ErrorResponse
// @Router /tenants [get]
func (h *TenantHandler) ListTenants(c *gin.Context) <span class="cov0" title="0">{
        limit, _ := strconv.Atoi(c.DefaultQuery("limit", "10"))
        offset, _ := strconv.Atoi(c.DefaultQuery("offset", "0"))

        // Validate pagination parameters
        if limit &lt; 1 || limit &gt; 100 </span><span class="cov0" title="0">{
                limit = 10
        }</span>
        <span class="cov0" title="0">if offset &lt; 0 </span><span class="cov0" title="0">{
                offset = 0
        }</span>

        // Get tenants
        <span class="cov0" title="0">tenants, err := h.tenantService.ListTenants(c.Request.Context(), limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "list_failed",
                        Message: "Failed to list tenants: " + err.Error(),
                })
                return
        }</span>

        // Convert to response
        <span class="cov0" title="0">var response []TenantResponse
        for _, tenant := range tenants </span><span class="cov0" title="0">{
                response = append(response, TenantResponse{
                        ID:        tenant.ID,
                        Name:      tenant.Name,
                        Domain:    tenant.Domain,
                        Status:    tenant.Status,
                        Plan:      tenant.Plan,
                        MaxUsers:  tenant.MaxUsers,
                        Features:  tenant.Features,
                        CreatedAt: tenant.CreatedAt,
                        UpdatedAt: tenant.UpdatedAt,
                        ExpiresAt: tenant.ExpiresAt,
                })
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, response)</span>
}

// GetTenantStats godoc
// @Summary Get tenant statistics
// @Description Retrieve usage statistics for a tenant
// @Tags Tenants
// @Accept json
// @Produce json
// @Param tenant_id path string true "Tenant ID" example("tenant-123")
// @Success 200 {object} TenantStatsResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /tenants/{tenant_id}/stats [get]
func (h *TenantHandler) GetTenantStats(c *gin.Context) <span class="cov0" title="0">{
        tenantID := c.Param("tenant_id")
        if tenantID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "missing_tenant_id",
                        Message: "Tenant ID is required",
                })
                return
        }</span>

        // Get tenant stats
        <span class="cov0" title="0">stats, err := h.tenantService.GetTenantStats(c.Request.Context(), tenantID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, ErrorResponse{
                        Error:   "stats_not_found",
                        Message: "Tenant statistics not found",
                })
                return
        }</span>

        // Convert to response
        <span class="cov0" title="0">response := TenantStatsResponse{
                TenantID:    stats.TenantID,
                TotalUsers:  stats.TotalUsers,
                ActiveUsers: stats.ActiveUsers,
                TotalLogins: stats.TotalLogins,
                LastLoginAt: stats.LastLoginAt,
                StorageUsed: stats.StorageUsed,
                APIRequests: stats.APIRequests,
                UpdatedAt:   stats.UpdatedAt,
        }

        c.JSON(http.StatusOK, response)</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package rest

import (
        "auth-service/internal/logger"
        "auth-service/internal/middleware"
        "auth-service/internal/models"
        "auth-service/internal/service"
        "net/http"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

// TwoFactorHandler handles 2FA-related requests
type TwoFactorHandler struct {
        otpService service.OTPService
        logger     *logger.Logger
}

// NewTwoFactorHandler creates a new 2FA handler
func NewTwoFactorHandler(otpService service.OTPService, logger *logger.Logger) *TwoFactorHandler <span class="cov0" title="0">{
        return &amp;TwoFactorHandler{
                otpService: otpService,
                logger:     logger,
        }
}</span>

// TriggerTwoFactorAuth handles POST /internal/2fa/send
func (h *TwoFactorHandler) TriggerTwoFactorAuth(c *gin.Context) <span class="cov0" title="0">{
        // Safely get logger from context
        var reqLogger *logger.RequestLogger
        if loggerInterface := middleware.GetLogger(c); loggerInterface != nil </span><span class="cov0" title="0">{
                if reqLog, ok := loggerInterface.(*logger.RequestLogger); ok </span><span class="cov0" title="0">{
                        reqLogger = reqLog
                }</span>
        }

        // If no logger available, create a basic one
        <span class="cov0" title="0">if reqLogger == nil </span><span class="cov0" title="0">{
                reqLogger = h.logger.WithRequest(c.Request)
        }</span>

        <span class="cov0" title="0">var req models.TwoFactorAuthRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                reqLogger.Error("Failed to bind 2FA request", zap.Error(err))
                apiError := models.CreateError(models.ErrorCodeInvalidRequest, err.Error())
                c.JSON(apiError.HTTPStatus, apiError)
                return
        }</span>

        // Validate required fields
        <span class="cov0" title="0">if req.UserID == "" || req.ClientID == "" || req.Channel == "" || req.Recipient == "" </span><span class="cov0" title="0">{
                reqLogger.Error("Missing required fields in 2FA request",
                        zap.String("user_id", req.UserID),
                        zap.String("client_id", req.ClientID),
                        zap.String("channel", req.Channel),
                        zap.String("recipient", req.Recipient))
                apiError := models.CreateError(models.ErrorCodeMissingFields, "user_id, client_id, channel, and recipient are required")
                c.JSON(apiError.HTTPStatus, apiError)
                return
        }</span>

        // Validate channel
        <span class="cov0" title="0">if req.Channel != "EMAIL" &amp;&amp; req.Channel != "SMS" </span><span class="cov0" title="0">{
                reqLogger.Error("Invalid channel in 2FA request", zap.String("channel", req.Channel))
                apiError := models.CreateError(models.ErrorCodeInvalidChannel, "channel must be EMAIL or SMS")
                c.JSON(apiError.HTTPStatus, apiError)
                return
        }</span>

        // Log the 2FA request
        <span class="cov0" title="0">reqLogger.Info("2FA request received",
                zap.String("user_id", req.UserID),
                zap.String("client_id", req.ClientID),
                zap.String("channel", req.Channel),
                zap.String("recipient", req.Recipient))

        // Trigger 2FA
        resp, err := h.otpService.TriggerTwoFactorAuth(c.Request.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                // Check if it's a structured API error
                if apiError, ok := err.(*models.APIError); ok </span><span class="cov0" title="0">{
                        reqLogger.Error("2FA request failed",
                                zap.String("error_code", string(apiError.Code)),
                                zap.String("error_type", string(apiError.Type)),
                                zap.String("message", apiError.Message),
                                zap.String("user_id", req.UserID),
                                zap.String("client_id", req.ClientID))
                        c.JSON(apiError.HTTPStatus, apiError)
                        return
                }</span>

                // Handle generic errors
                <span class="cov0" title="0">reqLogger.Error("Failed to trigger 2FA",
                        zap.Error(err),
                        zap.String("user_id", req.UserID),
                        zap.String("client_id", req.ClientID))
                apiError := models.CreateError(models.ErrorCodeInternalError, err.Error())
                c.JSON(apiError.HTTPStatus, apiError)
                return</span>
        }

        // Log successful 2FA trigger
        <span class="cov0" title="0">reqLogger.Info("2FA triggered successfully",
                zap.String("user_id", req.UserID),
                zap.String("client_id", req.ClientID),
                zap.String("message_id", resp.MessageID),
                zap.Int("digit_length", resp.OTPDigitLength))

        c.JSON(http.StatusOK, resp)</span>
}

// ValidateTwoFactorAuth handles POST /internal/2fa/validate
func (h *TwoFactorHandler) ValidateTwoFactorAuth(c *gin.Context) <span class="cov0" title="0">{
        // Safely get logger from context
        var reqLogger *logger.RequestLogger
        if loggerInterface := middleware.GetLogger(c); loggerInterface != nil </span><span class="cov0" title="0">{
                if reqLog, ok := loggerInterface.(*logger.RequestLogger); ok </span><span class="cov0" title="0">{
                        reqLogger = reqLog
                }</span>
        }

        // If no logger available, create a basic one
        <span class="cov0" title="0">if reqLogger == nil </span><span class="cov0" title="0">{
                reqLogger = h.logger.WithRequest(c.Request)
        }</span>

        <span class="cov0" title="0">var req models.OTPVerifyRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                reqLogger.Error("Failed to bind 2FA validation request", zap.Error(err))
                apiError := models.CreateError(models.ErrorCodeInvalidRequest, err.Error())
                c.JSON(apiError.HTTPStatus, apiError)
                return
        }</span>

        // Validate required fields
        <span class="cov0" title="0">if req.TenantID == "" || req.Code == "" </span><span class="cov0" title="0">{
                reqLogger.Error("Missing required fields in 2FA validation request",
                        zap.String("tenant_id", req.TenantID),
                        zap.Int("code_length", len(req.Code)))
                apiError := models.CreateError(models.ErrorCodeMissingFields, "tenant_id and code are required")
                c.JSON(apiError.HTTPStatus, apiError)
                return
        }</span>

        // Determine field type (email or mobile)
        <span class="cov0" title="0">if req.Email == "" &amp;&amp; req.Mobile == "" </span><span class="cov0" title="0">{
                reqLogger.Error("Missing recipient field in 2FA validation request")
                apiError := models.CreateError(models.ErrorCodeMissingFields, "either email or mobile is required")
                c.JSON(apiError.HTTPStatus, apiError)
                return
        }</span>

        // Log the validation request
        <span class="cov0" title="0">reqLogger.Info("2FA validation request received",
                zap.String("tenant_id", req.TenantID),
                zap.String("email", req.Email),
                zap.String("mobile", req.Mobile),
                zap.Int("code_length", len(req.Code)))

        // Validate OTP
        valid, err := h.otpService.ValidateOTP(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                reqLogger.Error("Failed to validate 2FA",
                        zap.Error(err),
                        zap.String("tenant_id", req.TenantID))
                apiError := models.CreateError(models.ErrorCodeInternalError, err.Error())
                c.JSON(apiError.HTTPStatus, apiError)
                return
        }</span>

        <span class="cov0" title="0">if valid </span><span class="cov0" title="0">{
                reqLogger.Info("2FA validation successful",
                        zap.String("tenant_id", req.TenantID),
                        zap.String("email", req.Email),
                        zap.String("mobile", req.Mobile))
                c.JSON(http.StatusOK, gin.H{
                        "success": true,
                        "message": "2FA validation successful",
                })
        }</span> else<span class="cov0" title="0"> {
                reqLogger.Warn("2FA validation failed",
                        zap.String("tenant_id", req.TenantID),
                        zap.String("email", req.Email),
                        zap.String("mobile", req.Mobile))
                apiError := models.CreateError(models.ErrorCodeInvalidOTP, "Invalid or expired OTP")
                c.JSON(apiError.HTTPStatus, apiError)
        }</span>
}

// GetTwoFactorStatus handles GET /internal/2fa/status/:client_id
func (h *TwoFactorHandler) GetTwoFactorStatus(c *gin.Context) <span class="cov0" title="0">{
        // Safely get logger from context
        var reqLogger *logger.RequestLogger
        if loggerInterface := middleware.GetLogger(c); loggerInterface != nil </span><span class="cov0" title="0">{
                if reqLog, ok := loggerInterface.(*logger.RequestLogger); ok </span><span class="cov0" title="0">{
                        reqLogger = reqLog
                }</span>
        }

        // If no logger available, create a basic one
        <span class="cov0" title="0">if reqLogger == nil </span><span class="cov0" title="0">{
                reqLogger = h.logger.WithRequest(c.Request)
        }</span>

        <span class="cov0" title="0">clientID := c.Param("client_id")
        if clientID == "" </span><span class="cov0" title="0">{
                reqLogger.Error("Missing client_id in 2FA status request")
                apiError := models.CreateError(models.ErrorCodeMissingFields, "client_id is required")
                c.JSON(apiError.HTTPStatus, apiError)
                return
        }</span>

        // Get tenant config
        <span class="cov0" title="0">config, err := h.otpService.GetTenantOTPConfig(clientID)
        if err != nil </span><span class="cov0" title="0">{
                reqLogger.Error("Failed to get tenant config for 2FA status",
                        zap.Error(err),
                        zap.String("client_id", clientID))
                apiError := models.CreateError(models.ErrorCodeInternalError, err.Error())
                c.JSON(apiError.HTTPStatus, apiError)
                return
        }</span>

        // Get SMS usage info if SMS is enabled
        <span class="cov0" title="0">var smsUsageInfo *models.SMSUsageInfo
        if config.EnableSMSOTP </span><span class="cov0" title="0">{
                smsUsageInfo, err = h.otpService.GetSMSUsageInfo(clientID)
                if err != nil </span><span class="cov0" title="0">{
                        reqLogger.Error("Failed to get SMS usage info",
                                zap.Error(err),
                                zap.String("client_id", clientID))
                }</span>
        }

        <span class="cov0" title="0">reqLogger.Info("2FA status retrieved",
                zap.String("client_id", clientID),
                zap.Bool("email_enabled", config.EnableEmailOTP),
                zap.Bool("sms_enabled", config.EnableSMSOTP))

        c.JSON(http.StatusOK, gin.H{
                "client_id":           clientID,
                "email_enabled":       config.EnableEmailOTP,
                "sms_enabled":         config.EnableSMSOTP,
                "otp_digit_length":    config.OTPDigitLength,
                "expiration_minutes":  config.OTPExpirationMinutes,
                "max_attempts":        config.MaxOTPAttempts,
                "rate_limit_per_hour": config.RateLimitPerHour,
                "sms_usage_info":      smsUsageInfo,
        })</span>
}

// RegisterTwoFactorRoutes registers 2FA routes
func (h *TwoFactorHandler) RegisterTwoFactorRoutes(router *gin.RouterGroup) <span class="cov0" title="0">{
        // Internal 2FA endpoints
        internal := router.Group("/internal/2fa")
        </span><span class="cov0" title="0">{
                internal.POST("/send", h.TriggerTwoFactorAuth)
                internal.POST("/validate", h.ValidateTwoFactorAuth)
                internal.GET("/status/:client_id", h.GetTwoFactorStatus)
        }</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package logger

import (
        "auth-service/internal/config"
        "auth-service/internal/tracing"
        "context"
        "net/http"
        "os"
        "time"

        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

// Logger wraps zap.Logger with additional functionality
type Logger struct {
        *zap.Logger
}

// RequestLogger provides request-specific logging
type RequestLogger struct {
        *Logger
        requestID    string
        userID       string
        tenantID     string
        method       string
        path         string
        clientIP     string
        traceID      string
        spanID       string
        parentSpanID string
}

// NewLogger creates a new logger instance based on configuration
func NewLogger(cfg *config.LoggingConfig) (*Logger, error) <span class="cov8" title="4">{
        var level zapcore.Level
        if err := level.UnmarshalText([]byte(cfg.Level)); err != nil </span><span class="cov0" title="0">{
                level = zapcore.InfoLevel
        }</span>

        // Create encoder config
        <span class="cov8" title="4">encoderConfig := zap.NewProductionEncoderConfig()
        encoderConfig.TimeKey = "timestamp"
        encoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
        encoderConfig.EncodeLevel = zapcore.CapitalLevelEncoder
        encoderConfig.MessageKey = "message"
        encoderConfig.LevelKey = "level"
        encoderConfig.CallerKey = "caller"

        // Choose encoder based on format
        var encoder zapcore.Encoder
        if cfg.Format == "json" </span><span class="cov8" title="4">{
                encoder = zapcore.NewJSONEncoder(encoderConfig)
        }</span> else<span class="cov0" title="0"> {
                encoder = zapcore.NewConsoleEncoder(encoderConfig)
        }</span>

        // Choose output
        <span class="cov8" title="4">var writeSyncer zapcore.WriteSyncer
        if cfg.Output == "stdout" </span><span class="cov8" title="4">{
                writeSyncer = zapcore.AddSync(os.Stdout)
        }</span> else<span class="cov0" title="0"> {
                file, err := os.OpenFile(cfg.Output, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">writeSyncer = zapcore.AddSync(file)</span>
        }

        // Create core
        <span class="cov8" title="4">core := zapcore.NewCore(encoder, writeSyncer, level)

        // Create logger options
        opts := []zap.Option{
                zap.AddCaller(),
                zap.AddStacktrace(zapcore.ErrorLevel),
        }

        if cfg.IncludeCaller </span><span class="cov8" title="4">{
                opts = append(opts, zap.AddCallerSkip(1))
        }</span>

        <span class="cov8" title="4">if cfg.IncludeStacktrace </span><span class="cov8" title="4">{
                opts = append(opts, zap.AddStacktrace(zapcore.WarnLevel))
        }</span>

        <span class="cov8" title="4">logger := zap.New(core, opts...)
        return &amp;Logger{Logger: logger}, nil</span>
}

// WithRequest creates a request-specific logger
func (l *Logger) WithRequest(r *http.Request) *RequestLogger <span class="cov7" title="3">{
        // Extract tracing information
        traceCtx := tracing.ExtractTracingFromRequest(r)

        requestID := r.Header.Get("X-Request-ID")
        if requestID == "" </span><span class="cov4" title="2">{
                requestID = traceCtx.TraceID // Use trace ID as request ID if not provided
        }</span>

        <span class="cov7" title="3">userID := r.Header.Get("X-User-ID")
        tenantID := r.Header.Get("X-Tenant-ID")
        clientIP := getClientIP(r)

        return &amp;RequestLogger{
                Logger:       l,
                requestID:    requestID,
                userID:       userID,
                tenantID:     tenantID,
                method:       r.Method,
                path:         r.URL.Path,
                clientIP:     clientIP,
                traceID:      traceCtx.TraceID,
                spanID:       traceCtx.SpanID,
                parentSpanID: traceCtx.ParentSpanID,
        }</span>
}

// WithContext creates a logger with context values
func (l *Logger) WithContext(ctx context.Context) *RequestLogger <span class="cov0" title="0">{
        requestID := getFromContext(ctx, "request_id")
        userID := getFromContext(ctx, "user_id")
        tenantID := getFromContext(ctx, "tenant_id")
        method := getFromContext(ctx, "method")
        path := getFromContext(ctx, "path")
        clientIP := getFromContext(ctx, "client_ip")

        // Get tracing context from context
        traceCtx := tracing.GetTracingContextFromContext(ctx)

        return &amp;RequestLogger{
                Logger:       l,
                requestID:    requestID,
                userID:       userID,
                tenantID:     tenantID,
                method:       method,
                path:         path,
                clientIP:     clientIP,
                traceID:      traceCtx.TraceID,
                spanID:       traceCtx.SpanID,
                parentSpanID: traceCtx.ParentSpanID,
        }
}</span>

// RequestStart logs the start of a request
func (rl *RequestLogger) RequestStart() <span class="cov1" title="1">{
        rl.Info("Request started",
                zap.String("request_id", rl.requestID),
                zap.String("trace_id", rl.traceID),
                zap.String("span_id", rl.spanID),
                zap.String("parent_span_id", rl.parentSpanID),
                zap.String("method", rl.method),
                zap.String("path", rl.path),
                zap.String("client_ip", rl.clientIP),
                zap.String("user_id", rl.userID),
                zap.String("tenant_id", rl.tenantID),
        )
}</span>

// RequestEnd logs the end of a request with duration and status
func (rl *RequestLogger) RequestEnd(status int, duration time.Duration, err error) <span class="cov1" title="1">{
        fields := []zap.Field{
                zap.String("request_id", rl.requestID),
                zap.String("trace_id", rl.traceID),
                zap.String("span_id", rl.spanID),
                zap.String("parent_span_id", rl.parentSpanID),
                zap.String("method", rl.method),
                zap.String("path", rl.path),
                zap.String("client_ip", rl.clientIP),
                zap.String("user_id", rl.userID),
                zap.String("tenant_id", rl.tenantID),
                zap.Int("status", status),
                zap.Duration("duration", duration),
        }

        if err != nil </span><span class="cov0" title="0">{
                fields = append(fields, zap.Error(err))
                rl.Error("Request failed", fields...)
        }</span> else<span class="cov1" title="1"> {
                rl.Info("Request completed", fields...)
        }</span>
}

// AuthSuccess logs successful authentication
func (rl *RequestLogger) AuthSuccess(userID, tenantID, authMethod string) <span class="cov1" title="1">{
        rl.Info("Authentication successful",
                zap.String("request_id", rl.requestID),
                zap.String("trace_id", rl.traceID),
                zap.String("span_id", rl.spanID),
                zap.String("user_id", userID),
                zap.String("tenant_id", tenantID),
                zap.String("auth_method", authMethod),
                zap.String("client_ip", rl.clientIP),
        )
}</span>

// AuthFailure logs failed authentication
func (rl *RequestLogger) AuthFailure(userID, tenantID, authMethod, reason string) <span class="cov1" title="1">{
        rl.Warn("Authentication failed",
                zap.String("request_id", rl.requestID),
                zap.String("trace_id", rl.traceID),
                zap.String("span_id", rl.spanID),
                zap.String("user_id", userID),
                zap.String("tenant_id", tenantID),
                zap.String("auth_method", authMethod),
                zap.String("reason", reason),
                zap.String("client_ip", rl.clientIP),
        )
}</span>

// OAuthFlow logs OAuth flow events
func (rl *RequestLogger) OAuthFlow(provider, step, tenantID string, err error) <span class="cov1" title="1">{
        fields := []zap.Field{
                zap.String("request_id", rl.requestID),
                zap.String("trace_id", rl.traceID),
                zap.String("span_id", rl.spanID),
                zap.String("provider", provider),
                zap.String("step", step),
                zap.String("tenant_id", tenantID),
                zap.String("client_ip", rl.clientIP),
        }

        if err != nil </span><span class="cov0" title="0">{
                fields = append(fields, zap.Error(err))
                rl.Error("OAuth flow failed", fields...)
        }</span> else<span class="cov1" title="1"> {
                rl.Info("OAuth flow step completed", fields...)
        }</span>
}

// DatabaseOperation logs database operations
func (rl *RequestLogger) DatabaseOperation(operation, table, tenantID string, duration time.Duration, err error) <span class="cov1" title="1">{
        fields := []zap.Field{
                zap.String("request_id", rl.requestID),
                zap.String("trace_id", rl.traceID),
                zap.String("span_id", rl.spanID),
                zap.String("operation", operation),
                zap.String("table", table),
                zap.String("tenant_id", tenantID),
                zap.Duration("duration", duration),
        }

        if err != nil </span><span class="cov0" title="0">{
                fields = append(fields, zap.Error(err))
                rl.Error("Database operation failed", fields...)
        }</span> else<span class="cov1" title="1"> {
                rl.Debug("Database operation completed", fields...)
        }</span>
}

// CacheOperation logs cache operations
func (rl *RequestLogger) CacheOperation(operation, key, tenantID string, hit bool, duration time.Duration, err error) <span class="cov1" title="1">{
        fields := []zap.Field{
                zap.String("request_id", rl.requestID),
                zap.String("trace_id", rl.traceID),
                zap.String("span_id", rl.spanID),
                zap.String("operation", operation),
                zap.String("key", key),
                zap.String("tenant_id", tenantID),
                zap.Bool("cache_hit", hit),
                zap.Duration("duration", duration),
        }

        if err != nil </span><span class="cov0" title="0">{
                fields = append(fields, zap.Error(err))
                rl.Error("Cache operation failed", fields...)
        }</span> else<span class="cov1" title="1"> {
                rl.Debug("Cache operation completed", fields...)
        }</span>
}

// SecurityEvent logs security-related events
func (rl *RequestLogger) SecurityEvent(eventType, userID, tenantID, details string, severity string) <span class="cov1" title="1">{
        fields := []zap.Field{
                zap.String("request_id", rl.requestID),
                zap.String("trace_id", rl.traceID),
                zap.String("span_id", rl.spanID),
                zap.String("event_type", eventType),
                zap.String("user_id", userID),
                zap.String("tenant_id", tenantID),
                zap.String("details", details),
                zap.String("severity", severity),
                zap.String("client_ip", rl.clientIP),
        }

        switch severity </span>{
        case "high":<span class="cov0" title="0">
                rl.Logger.Error("Security event", fields...)</span>
        case "medium":<span class="cov1" title="1">
                rl.Logger.Warn("Security event", fields...)</span>
        case "low":<span class="cov0" title="0">
                rl.Logger.Info("Security event", fields...)</span>
        default:<span class="cov0" title="0">
                rl.Logger.Info("Security event", fields...)</span>
        }
}

// BusinessEvent logs business logic events
func (rl *RequestLogger) BusinessEvent(eventType, userID, tenantID string, data map[string]interface{}) <span class="cov1" title="1">{
        fields := []zap.Field{
                zap.String("request_id", rl.requestID),
                zap.String("trace_id", rl.traceID),
                zap.String("span_id", rl.spanID),
                zap.String("event_type", eventType),
                zap.String("user_id", userID),
                zap.String("tenant_id", tenantID),
                zap.String("client_ip", rl.clientIP),
        }

        for key, value := range data </span><span class="cov4" title="2">{
                fields = append(fields, zap.Any(key, value))
        }</span>

        <span class="cov1" title="1">rl.Logger.Info("Business event", fields...)</span>
}

// Error logs errors with request context
func (rl *RequestLogger) Error(msg string, fields ...zap.Field) <span class="cov1" title="1">{
        allFields := append([]zap.Field{
                zap.String("request_id", rl.requestID),
                zap.String("trace_id", rl.traceID),
                zap.String("span_id", rl.spanID),
                zap.String("method", rl.method),
                zap.String("path", rl.path),
                zap.String("client_ip", rl.clientIP),
        }, fields...)
        rl.Logger.Error(msg, allFields...)
}</span>

// Warn logs warnings with request context
func (rl *RequestLogger) Warn(msg string, fields ...zap.Field) <span class="cov4" title="2">{
        allFields := append([]zap.Field{
                zap.String("request_id", rl.requestID),
                zap.String("trace_id", rl.traceID),
                zap.String("span_id", rl.spanID),
                zap.String("method", rl.method),
                zap.String("path", rl.path),
                zap.String("client_ip", rl.clientIP),
        }, fields...)
        rl.Logger.Warn(msg, allFields...)
}</span>

// Info logs info messages with request context
func (rl *RequestLogger) Info(msg string, fields ...zap.Field) <span class="cov10" title="5">{
        allFields := append([]zap.Field{
                zap.String("request_id", rl.requestID),
                zap.String("trace_id", rl.traceID),
                zap.String("span_id", rl.spanID),
                zap.String("method", rl.method),
                zap.String("path", rl.path),
                zap.String("client_ip", rl.clientIP),
        }, fields...)
        rl.Logger.Info(msg, allFields...)
}</span>

// Debug logs debug messages with request context
func (rl *RequestLogger) Debug(msg string, fields ...zap.Field) <span class="cov7" title="3">{
        allFields := append([]zap.Field{
                zap.String("request_id", rl.requestID),
                zap.String("trace_id", rl.traceID),
                zap.String("span_id", rl.spanID),
                zap.String("method", rl.method),
                zap.String("path", rl.path),
                zap.String("client_ip", rl.clientIP),
        }, fields...)
        rl.Logger.Debug(msg, allFields...)
}</span>

// GetTraceID returns the trace ID for this request
func (rl *RequestLogger) GetTraceID() string <span class="cov0" title="0">{
        return rl.traceID
}</span>

// GetSpanID returns the span ID for this request
func (rl *RequestLogger) GetSpanID() string <span class="cov0" title="0">{
        return rl.spanID
}</span>

// Helper functions
func generateRequestID() string <span class="cov0" title="0">{
        return time.Now().Format("20060102150405") + "-" + randomString(8)
}</span>

func randomString(length int) string <span class="cov0" title="0">{
        const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
        b := make([]byte, length)
        for i := range b </span><span class="cov0" title="0">{
                b[i] = charset[time.Now().UnixNano()%int64(len(charset))]
        }</span>
        <span class="cov0" title="0">return string(b)</span>
}

func getClientIP(r *http.Request) string <span class="cov7" title="3">{
        // Check for forwarded headers
        if ip := r.Header.Get("X-Forwarded-For"); ip != "" </span><span class="cov0" title="0">{
                return ip
        }</span>
        <span class="cov7" title="3">if ip := r.Header.Get("X-Real-IP"); ip != "" </span><span class="cov0" title="0">{
                return ip
        }</span>
        <span class="cov7" title="3">return r.RemoteAddr</span>
}

func getFromContext(ctx context.Context, key string) string <span class="cov0" title="0">{
        if val, ok := ctx.Value(key).(string); ok </span><span class="cov0" title="0">{
                return val
        }</span>
        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package middleware

import (
        "auth-service/internal/actuator"
        "time"

        "github.com/gin-gonic/gin"
)

// ActuatorMiddleware creates middleware for tracking request metrics
func ActuatorMiddleware(act *actuator.Actuator) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                start := time.Now()

                // Track active request
                act.StartRequest(c.Request.Method, c.FullPath())

                // Process request
                c.Next()

                // Track request completion
                act.EndRequest(c.Request.Method, c.FullPath())

                // Record metrics
                duration := time.Since(start)
                status := c.Writer.Status()
                act.RecordRequest(c.Request.Method, c.FullPath(), status, duration)
        }</span>
}

// HealthCheckMiddleware creates middleware for health check endpoints
func HealthCheckMiddleware() gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                // Add cache headers for health check endpoints
                c.Header("Cache-Control", "no-cache, no-store, must-revalidate")
                c.Header("Pragma", "no-cache")
                c.Header("Expires", "0")

                c.Next()
        }</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package middleware

import (
        "auth-service/internal/logger"
        "auth-service/internal/tracing"
        "time"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

// LoggingMiddleware creates middleware for request-level logging
func LoggingMiddleware(log *logger.Logger) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                start := time.Now()

                // Create request-specific logger
                reqLogger := log.WithRequest(c.Request)

                // Log request start
                reqLogger.RequestStart()

                // Add logger to context for use in handlers
                c.Set("logger", reqLogger)

                // Process request
                c.Next()

                // Calculate duration
                duration := time.Since(start)

                // Get response status
                status := c.Writer.Status()

                // Check for errors
                var err error
                if len(c.Errors) &gt; 0 </span><span class="cov0" title="0">{
                        err = c.Errors.Last().Err
                }</span>

                // Add tracing headers to response
                <span class="cov0" title="0">traceCtx := &amp;tracing.TracingContext{
                        TraceID:      reqLogger.GetTraceID(),
                        SpanID:       reqLogger.GetSpanID(),
                        ParentSpanID: "", // This would be set if we had parent span info
                }
                tracing.AddTracingHeaders(c.Writer, traceCtx)

                // Log request end
                reqLogger.RequestEnd(status, duration, err)

                // Log additional request details for debugging
                if status &gt;= 400 </span><span class="cov0" title="0">{
                        reqLogger.Warn("Request resulted in error status",
                                zap.String("user_agent", c.Request.UserAgent()),
                                zap.String("referer", c.Request.Referer()),
                                zap.Int64("content_length", c.Request.ContentLength),
                        )
                }</span>
        }
}

// GetLogger retrieves the request logger from context
func GetLogger(c *gin.Context) interface{} <span class="cov0" title="0">{
        if logger, exists := c.Get("logger"); exists </span><span class="cov0" title="0">{
                return logger
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// SetUserContext adds user information to the request context for logging
func SetUserContext(c *gin.Context, userID, tenantID string) <span class="cov0" title="0">{
        // Note: This would need to be implemented in the logger package
        // For now, we'll just set the values in the request headers
        c.Request.Header.Set("X-User-ID", userID)
        c.Request.Header.Set("X-Tenant-ID", tenantID)
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package middleware

import (
        "auth-service/internal/service"
        "net/http"

        "github.com/gin-gonic/gin"
)

// RBACMiddleware returns a Gin middleware that checks for required permission
func RBACMiddleware(rbac service.RBACService, permission string) gin.HandlerFunc <span class="cov9" title="9">{
        return func(c *gin.Context) </span><span class="cov10" title="11">{
                userID := c.GetString("user_id")
                tenantID := c.GetString("tenant_id")
                if userID == "" || tenantID == "" </span><span class="cov3" title="2">{
                        c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "missing user or tenant context"})
                        return
                }</span>
                <span class="cov9" title="9">hasPerm, err := rbac.UserHasPermission(c.Request.Context(), userID, permission, tenantID)
                if err != nil </span><span class="cov1" title="1">{
                        c.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{"error": "permission check failed"})
                        return
                }</span>
                <span class="cov8" title="8">if !hasPerm </span><span class="cov6" title="4">{
                        c.AbortWithStatusJSON(http.StatusForbidden, gin.H{"error": "forbidden"})
                        return
                }</span>
                <span class="cov6" title="4">c.Next()</span>
        }
}

// For gRPC, similar interceptor logic would be used.
</pre>
		
		<pre class="file" id="file17" style="display: none">package middleware

import (
        "auth-service/internal/service"
        "net/http"
        "strings"

        "github.com/gin-gonic/gin"
        "github.com/golang-jwt/jwt/v5"
)

// TenantMiddleware validates tenant access and extracts tenant information
func TenantMiddleware(tenantService service.TenantService) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // Extract tenant ID from various sources
                tenantID := extractTenantID(c)

                if tenantID == "" </span><span class="cov0" title="0">{
                        c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{
                                "error":   "missing_tenant_id",
                                "message": "Tenant ID is required",
                        })
                        return
                }</span>

                // Check if we have a tenant token in X-Tenant-Token header
                <span class="cov0" title="0">tenantToken := c.GetHeader("X-Tenant-Token")
                if tenantToken != "" </span><span class="cov0" title="0">{
                        // Validate the tenant token
                        token, err := tenantService.ValidateTenantToken(c.Request.Context(), tenantToken)
                        if err != nil </span><span class="cov0" title="0">{
                                c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{
                                        "error":   "invalid_tenant_token",
                                        "message": err.Error(),
                                })
                                return
                        }</span>

                        // Verify the tenant ID in the token matches the extracted tenant ID
                        <span class="cov0" title="0">if token.TenantID != tenantID </span><span class="cov0" title="0">{
                                c.AbortWithStatusJSON(http.StatusForbidden, gin.H{
                                        "error":   "tenant_token_mismatch",
                                        "message": "Tenant token does not match tenant ID",
                                })
                                return
                        }</span>

                        // Store the validated token in context
                        <span class="cov0" title="0">c.Set("tenant_token", token)</span>
                }

                // Validate tenant access
                <span class="cov0" title="0">if err := tenantService.ValidateTenantAccess(c.Request.Context(), tenantID); err != nil </span><span class="cov0" title="0">{
                        c.AbortWithStatusJSON(http.StatusForbidden, gin.H{
                                "error":   "tenant_access_denied",
                                "message": err.Error(),
                        })
                        return
                }</span>

                // Get tenant information
                <span class="cov0" title="0">tenant, err := tenantService.GetTenant(c.Request.Context(), tenantID)
                if err != nil </span><span class="cov0" title="0">{
                        c.AbortWithStatusJSON(http.StatusNotFound, gin.H{
                                "error":   "tenant_not_found",
                                "message": "Tenant not found",
                        })
                        return
                }</span>

                // Store tenant information in context
                <span class="cov0" title="0">c.Set("tenant_id", tenantID)
                c.Set("tenant", tenant)

                c.Next()</span>
        }
}

// extractTenantID extracts tenant ID from various sources
func extractTenantID(c *gin.Context) string <span class="cov0" title="0">{
        // 1. From X-Tenant-Token header (highest priority)
        if tenantToken := c.GetHeader("X-Tenant-Token"); tenantToken != "" </span><span class="cov0" title="0">{
                // Extract tenant ID from tenant JWT token
                tenantID := extractTenantFromJWT(tenantToken)
                if tenantID != "" </span><span class="cov0" title="0">{
                        return tenantID
                }</span>
        }

        // 2. From Authorization header (Bearer token) - Tenant Token
        <span class="cov0" title="0">if authHeader := c.GetHeader("Authorization"); authHeader != "" </span><span class="cov0" title="0">{
                if strings.HasPrefix(authHeader, "Bearer ") </span><span class="cov0" title="0">{
                        tokenString := authHeader[7:] // Remove "Bearer " prefix

                        // Try to extract tenant ID from JWT token
                        tenantID := extractTenantFromJWT(tokenString)
                        if tenantID != "" </span><span class="cov0" title="0">{
                                return tenantID
                        }</span>
                }
        }

        // 3. From X-Tenant-ID header
        <span class="cov0" title="0">if tenantID := c.GetHeader("X-Tenant-ID"); tenantID != "" </span><span class="cov0" title="0">{
                return tenantID
        }</span>

        // 4. From tenant_id cookie
        <span class="cov0" title="0">if tenantID, err := c.Cookie("tenant_id"); err == nil &amp;&amp; tenantID != "" </span><span class="cov0" title="0">{
                return tenantID
        }</span>

        // 5. From query parameter
        <span class="cov0" title="0">if tenantID := c.Query("tenant_id"); tenantID != "" </span><span class="cov0" title="0">{
                return tenantID
        }</span>

        // 6. From request body (for POST/PUT requests)
        <span class="cov0" title="0">if c.Request.Method == "POST" || c.Request.Method == "PUT" </span><span class="cov0" title="0">{
                // Try to get from JSON body
                var body map[string]interface{}
                if err := c.ShouldBindJSON(&amp;body); err == nil </span><span class="cov0" title="0">{
                        if tenantID, ok := body["tenant_id"].(string); ok &amp;&amp; tenantID != "" </span><span class="cov0" title="0">{
                                return tenantID
                        }</span>
                }
        }

        // 7. From URL path (e.g., /api/v1/tenants/{tenant_id}/users)
        // This would require custom routing setup
        // tenantID := c.Param("tenant_id")
        // if tenantID != "" {
        //     return tenantID
        // }

        <span class="cov0" title="0">return ""</span>
}

// extractTenantFromJWT extracts tenant ID from a JWT token
func extractTenantFromJWT(tokenString string) string <span class="cov0" title="0">{
        // Parse JWT token without validation (we just want to extract claims)
        token, _, err := new(jwt.Parser).ParseUnverified(tokenString, jwt.MapClaims{})
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Extract claims
        <span class="cov0" title="0">claims, ok := token.Claims.(jwt.MapClaims)
        if !ok </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Check if this is a tenant token
        <span class="cov0" title="0">if tokenType, ok := claims["type"].(string); ok &amp;&amp; tokenType == "tenant" </span><span class="cov0" title="0">{
                if tenantID, ok := claims["tenant_id"].(string); ok &amp;&amp; tenantID != "" </span><span class="cov0" title="0">{
                        return tenantID
                }</span>
        }

        // Check if this is a user token with tenant_id
        <span class="cov0" title="0">if tenantID, ok := claims["tenant_id"].(string); ok &amp;&amp; tenantID != "" </span><span class="cov0" title="0">{
                return tenantID
        }</span>

        <span class="cov0" title="0">return ""</span>
}

// GetTenant retrieves tenant information from context
func GetTenant(c *gin.Context) interface{} <span class="cov0" title="0">{
        if tenant, exists := c.Get("tenant"); exists </span><span class="cov0" title="0">{
                return tenant
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetTenantID retrieves tenant ID from context
func GetTenantID(c *gin.Context) string <span class="cov0" title="0">{
        if tenantID, exists := c.Get("tenant_id"); exists </span><span class="cov0" title="0">{
                if id, ok := tenantID.(string); ok </span><span class="cov0" title="0">{
                        return id
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// GetTenantToken retrieves tenant token from context
func GetTenantToken(c *gin.Context) interface{} <span class="cov0" title="0">{
        if token, exists := c.Get("tenant_token"); exists </span><span class="cov0" title="0">{
                return token
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// RequireTenantPlan middleware ensures tenant has required plan
func RequireTenantPlan(requiredPlan string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                tenantInterface := GetTenant(c)
                if tenantInterface == nil </span><span class="cov0" title="0">{
                        c.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{
                                "error":   "tenant_context_missing",
                                "message": "Tenant context is missing",
                        })
                        return
                }</span>

                // Type assertion would be needed here
                // tenant := tenantInterface.(*models.Tenant)
                // if tenant.Plan != requiredPlan {
                //     c.AbortWithStatusJSON(http.StatusForbidden, gin.H{
                //         "error":   "insufficient_plan",
                //         "message": fmt.Sprintf("Plan %s is required", requiredPlan),
                //     })
                //     return
                // }

                <span class="cov0" title="0">c.Next()</span>
        }
}

// RequireTenantFeature middleware ensures tenant has required feature
func RequireTenantFeature(requiredFeature string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                tenantInterface := GetTenant(c)
                if tenantInterface == nil </span><span class="cov0" title="0">{
                        c.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{
                                "error":   "tenant_context_missing",
                                "message": "Tenant context is missing",
                        })
                        return
                }</span>

                // Type assertion would be needed here
                // tenant := tenantInterface.(*models.Tenant)
                // hasFeature := false
                // for _, feature := range tenant.Features {
                //     if feature == requiredFeature {
                //         hasFeature = true
                //         break
                //     }
                // }
                // if !hasFeature {
                //     c.AbortWithStatusJSON(http.StatusForbidden, gin.H{
                //         "error":   "feature_not_available",
                //         "message": fmt.Sprintf("Feature %s is not available", requiredFeature),
                //     })
                //     return
                // }

                <span class="cov0" title="0">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package models

import (
        "fmt"
        "net/http"
)

// ErrorType represents the type of error
type ErrorType string

const (
        // ErrorTypeValidation represents validation errors
        ErrorTypeValidation ErrorType = "VALIDATION_ERROR"
        // ErrorTypeAuthentication represents authentication errors
        ErrorTypeAuthentication ErrorType = "AUTHENTICATION_ERROR"
        // ErrorTypeAuthorization represents authorization errors
        ErrorTypeAuthorization ErrorType = "AUTHORIZATION_ERROR"
        // ErrorTypeQuotaExceeded represents quota exceeded errors
        ErrorTypeQuotaExceeded ErrorType = "QUOTA_EXCEEDED"
        // ErrorTypeFeatureDisabled represents feature disabled errors
        ErrorTypeFeatureDisabled ErrorType = "FEATURE_DISABLED"
        // ErrorTypeSubscription represents subscription errors
        ErrorTypeSubscription ErrorType = "SUBSCRIPTION_ERROR"
        // ErrorTypeServiceUnavailable represents service unavailable errors
        ErrorTypeServiceUnavailable ErrorType = "SERVICE_UNAVAILABLE"
        // ErrorTypeRateLimit represents rate limit errors
        ErrorTypeRateLimit ErrorType = "RATE_LIMIT_EXCEEDED"
        // ErrorTypeInternal represents internal server errors
        ErrorTypeInternal ErrorType = "INTERNAL_ERROR"
        // ErrorTypeNotFound represents not found errors
        ErrorTypeNotFound ErrorType = "NOT_FOUND"
)

// ErrorCode represents specific error codes
type ErrorCode string

const (
        // ErrorCodeInvalidRequest represents invalid request
        ErrorCodeInvalidRequest ErrorCode = "INVALID_REQUEST"
        // ErrorCodeMissingFields represents missing required fields
        ErrorCodeMissingFields ErrorCode = "MISSING_FIELDS"
        // ErrorCodeInvalidChannel represents invalid channel
        ErrorCodeInvalidChannel ErrorCode = "INVALID_CHANNEL"
        // ErrorCodeInvalidOTP represents invalid OTP
        ErrorCodeInvalidOTP ErrorCode = "INVALID_OTP"
        // ErrorCodeOTPExpired represents expired OTP
        ErrorCodeOTPExpired ErrorCode = "OTP_EXPIRED"
        // ErrorCodeOTPAlreadyUsed represents already used OTP
        ErrorCodeOTPAlreadyUsed ErrorCode = "OTP_ALREADY_USED"
        // ErrorCode2FAQuotaExceeded represents 2FA quota exceeded
        ErrorCode2FAQuotaExceeded ErrorCode = "2FA_QUOTA_EXCEEDED"
        // ErrorCodeFeatureDisabled represents feature disabled
        ErrorCodeFeatureDisabled ErrorCode = "FEATURE_DISABLED"
        // ErrorCodeInvalidSubscription represents invalid subscription
        ErrorCodeInvalidSubscription ErrorCode = "INVALID_SUBSCRIPTION"
        // ErrorCodeSubscriptionExpired represents expired subscription
        ErrorCodeSubscriptionExpired ErrorCode = "SUBSCRIPTION_EXPIRED"
        // ErrorCodeRateLimitExceeded represents rate limit exceeded
        ErrorCodeRateLimitExceeded ErrorCode = "RATE_LIMIT_EXCEEDED"
        // ErrorCodeServiceUnavailable represents service unavailable
        ErrorCodeServiceUnavailable ErrorCode = "SERVICE_UNAVAILABLE"
        // ErrorCodeInternalError represents internal server error
        ErrorCodeInternalError ErrorCode = "INTERNAL_ERROR"
        // ErrorCodeNotFound represents resource not found
        ErrorCodeNotFound ErrorCode = "NOT_FOUND"
        // ErrorCodeAuthentication represents authentication error
        ErrorCodeAuthentication ErrorCode = "AUTHENTICATION_ERROR"
        // ErrorCodeAuthorization represents authorization error
        ErrorCodeAuthorization ErrorCode = "AUTHORIZATION_ERROR"
)

// APIError represents a structured API error response
type APIError struct {
        Type       ErrorType `json:"type"`
        Code       ErrorCode `json:"code"`
        Message    string    `json:"message"`
        Details    string    `json:"details,omitempty"`
        HTTPStatus int       `json:"-"`
        RequestID  string    `json:"request_id,omitempty"`
        Timestamp  string    `json:"timestamp,omitempty"`
}

// Error implements the error interface
func (e *APIError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("[%s] %s: %s", e.Code, e.Type, e.Message)
}</span>

// NewAPIError creates a new API error
func NewAPIError(errorType ErrorType, code ErrorCode, message string, httpStatus int) *APIError <span class="cov0" title="0">{
        return &amp;APIError{
                Type:       errorType,
                Code:       code,
                Message:    message,
                HTTPStatus: httpStatus,
        }
}</span>

// ErrorMapping maps error codes to HTTP status codes and types
var ErrorMapping = map[ErrorCode]struct {
        HTTPStatus int
        ErrorType  ErrorType
        Message    string
}{
        ErrorCodeInvalidRequest: {
                HTTPStatus: http.StatusBadRequest,
                ErrorType:  ErrorTypeValidation,
                Message:    "Invalid request format",
        },
        ErrorCodeMissingFields: {
                HTTPStatus: http.StatusBadRequest,
                ErrorType:  ErrorTypeValidation,
                Message:    "Missing required fields",
        },
        ErrorCodeInvalidChannel: {
                HTTPStatus: http.StatusBadRequest,
                ErrorType:  ErrorTypeValidation,
                Message:    "Invalid channel specified",
        },
        ErrorCodeInvalidOTP: {
                HTTPStatus: http.StatusUnauthorized,
                ErrorType:  ErrorTypeAuthentication,
                Message:    "Invalid OTP code",
        },
        ErrorCodeOTPExpired: {
                HTTPStatus: http.StatusUnauthorized,
                ErrorType:  ErrorTypeAuthentication,
                Message:    "OTP code has expired",
        },
        ErrorCodeOTPAlreadyUsed: {
                HTTPStatus: http.StatusUnauthorized,
                ErrorType:  ErrorTypeAuthentication,
                Message:    "OTP code has already been used",
        },
        ErrorCode2FAQuotaExceeded: {
                HTTPStatus: http.StatusTooManyRequests,
                ErrorType:  ErrorTypeQuotaExceeded,
                Message:    "2FA quota exceeded",
        },
        ErrorCodeFeatureDisabled: {
                HTTPStatus: http.StatusForbidden,
                ErrorType:  ErrorTypeFeatureDisabled,
                Message:    "Feature is disabled",
        },
        ErrorCodeInvalidSubscription: {
                HTTPStatus: http.StatusPaymentRequired,
                ErrorType:  ErrorTypeSubscription,
                Message:    "Invalid subscription",
        },
        ErrorCodeSubscriptionExpired: {
                HTTPStatus: http.StatusPaymentRequired,
                ErrorType:  ErrorTypeSubscription,
                Message:    "Subscription has expired",
        },
        ErrorCodeRateLimitExceeded: {
                HTTPStatus: http.StatusTooManyRequests,
                ErrorType:  ErrorTypeRateLimit,
                Message:    "Rate limit exceeded",
        },
        ErrorCodeServiceUnavailable: {
                HTTPStatus: http.StatusServiceUnavailable,
                ErrorType:  ErrorTypeServiceUnavailable,
                Message:    "Service temporarily unavailable",
        },
        ErrorCodeInternalError: {
                HTTPStatus: http.StatusInternalServerError,
                ErrorType:  ErrorTypeInternal,
                Message:    "Internal server error",
        },
        ErrorCodeNotFound: {
                HTTPStatus: http.StatusNotFound,
                ErrorType:  ErrorTypeNotFound,
                Message:    "Resource not found",
        },
        ErrorCodeAuthentication: {
                HTTPStatus: http.StatusUnauthorized,
                ErrorType:  ErrorTypeAuthentication,
                Message:    "Authentication failed",
        },
        ErrorCodeAuthorization: {
                HTTPStatus: http.StatusForbidden,
                ErrorType:  ErrorTypeAuthorization,
                Message:    "Authorization failed",
        },
}

// GetErrorInfo returns error information for a given error code
func GetErrorInfo(code ErrorCode) (int, ErrorType, string) <span class="cov0" title="0">{
        if info, exists := ErrorMapping[code]; exists </span><span class="cov0" title="0">{
                return info.HTTPStatus, info.ErrorType, info.Message
        }</span>
        // Default to internal error if code not found
        <span class="cov0" title="0">return http.StatusInternalServerError, ErrorTypeInternal, "Unknown error"</span>
}

// CreateError creates an API error from an error code
func CreateError(code ErrorCode, details ...string) *APIError <span class="cov0" title="0">{
        httpStatus, errorType, message := GetErrorInfo(code)

        apiError := NewAPIError(errorType, code, message, httpStatus)
        if len(details) &gt; 0 </span><span class="cov0" title="0">{
                apiError.Details = details[0]
        }</span>

        <span class="cov0" title="0">return apiError</span>
}

// Channel mapping for 2FA channels
var ChannelMapping = map[string]struct {
        Feature     string
        ChannelType string
}{
        "EMAIL": {
                Feature:     "2FA_EMAIL",
                ChannelType: "EMAIL",
        },
        "SMS": {
                Feature:     "2FA_SMS",
                ChannelType: "SMS",
        },
}

// GetChannelInfo returns channel information
func GetChannelInfo(channel string) (string, string, bool) <span class="cov0" title="0">{
        if info, exists := ChannelMapping[channel]; exists </span><span class="cov0" title="0">{
                return info.Feature, info.ChannelType, true
        }</span>
        <span class="cov0" title="0">return "", "", false</span>
}

// ValidChannels returns list of valid channels
func ValidChannels() []string <span class="cov0" title="0">{
        channels := make([]string, 0, len(ChannelMapping))
        for channel := range ChannelMapping </span><span class="cov0" title="0">{
                channels = append(channels, channel)
        }</span>
        <span class="cov0" title="0">return channels</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package service

import (
        "crypto/rand"
        "encoding/base32"
        "fmt"
        "strings"
        "time"

        "github.com/pquerna/otp"
        "github.com/pquerna/otp/totp"
        "github.com/skip2/go-qrcode"
)

// MFAService defines the interface for MFA operations
type MFAService interface {
        GenerateSecret(userID, tenantID string) (string, error)
        GenerateQRCode(secret, email, issuer string) ([]byte, error)
        ValidateTOTP(secret, code string) (bool, error)
        GenerateBackupCodes() ([]string, error)
}

type mfaService struct{}

func NewMFAService() MFAService <span class="cov0" title="0">{
        return &amp;mfaService{}
}</span>

// GenerateSecret creates a new TOTP secret for a user
func (s *mfaService) GenerateSecret(userID, tenantID string) (string, error) <span class="cov0" title="0">{
        // Generate a random base32 secret
        buf := make([]byte, 10)
        _, err := rand.Read(buf)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return strings.ToUpper(base32.StdEncoding.EncodeToString(buf)), nil</span>
}

// GenerateQRCode returns a PNG QR code for Google Authenticator setup
func (s *mfaService) GenerateQRCode(secret, email, issuer string) ([]byte, error) <span class="cov0" title="0">{
        otpURL := totp.GenerateOpts{
                Issuer:      issuer,
                AccountName: email,
                Secret:      []byte(secret),
        }
        key, err := totp.Generate(otpURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return qrcode.Encode(key.URL(), qrcode.Medium, 256)</span>
}

// ValidateTOTP checks if the provided code is valid for the secret
func (s *mfaService) ValidateTOTP(secret, code string) (bool, error) <span class="cov0" title="0">{
        valid, err := totp.ValidateCustom(code, secret, time.Now(), totp.ValidateOpts{
                Period:    30,
                Skew:      1,
                Digits:    otp.DigitsSix,
                Algorithm: otp.AlgorithmSHA1,
        })
        return valid, err
}</span>

// GenerateBackupCodes creates a set of backup codes
func (s *mfaService) GenerateBackupCodes() ([]string, error) <span class="cov0" title="0">{
        codes := make([]string, 8)
        for i := 0; i &lt; 8; i++ </span><span class="cov0" title="0">{
                buf := make([]byte, 5)
                _, err := rand.Read(buf)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">codes[i] = fmt.Sprintf("%06d", int(buf[0])&lt;&lt;8|int(buf[1]))</span>
        }
        <span class="cov0" title="0">return codes, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package service

import (
        "auth-service/internal/config"
        "auth-service/internal/models"
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "time"

        "github.com/sony/gobreaker"
)

// NotificationClient defines the interface for Notification Service communication
type NotificationClient interface {
        SendNotification(ctx context.Context, payload *models.NotificationPayload) (*models.NotificationResponse, error)
        GetCircuitBreakerState() gobreaker.State
}

// notificationClient implements NotificationClient
type notificationClient struct {
        httpClient     *http.Client
        baseURL        string
        circuitBreaker *gobreaker.CircuitBreaker
        config         config.NotificationServiceConfig
}

// NewNotificationClient creates a new Notification Service client
func NewNotificationClient(cfg config.NotificationServiceConfig) NotificationClient <span class="cov6" title="3">{
        circuitBreaker := cfg.CircuitBreaker.CreateCircuitBreaker("notification-service")

        return &amp;notificationClient{
                httpClient: &amp;http.Client{
                        Timeout: cfg.Timeout,
                },
                baseURL:        cfg.BaseURL,
                circuitBreaker: circuitBreaker,
                config:         cfg,
        }
}</span>

// SendNotification sends a templated notification to the Notification Service
func (c *notificationClient) SendNotification(ctx context.Context, payload *models.NotificationPayload) (*models.NotificationResponse, error) <span class="cov0" title="0">{
        // Use circuit breaker to protect against service failures
        result, err := c.circuitBreaker.Execute(func() (interface{}, error) </span><span class="cov0" title="0">{
                return c.sendNotificationWithRetry(ctx, payload)
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                // Check if it's a circuit breaker error
                if err == gobreaker.ErrOpenState </span><span class="cov0" title="0">{
                        return nil, models.CreateError(models.ErrorCodeServiceUnavailable, "Notification service circuit breaker is open")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("notification service error: %w", err)</span>
        }

        <span class="cov0" title="0">response, ok := result.(*models.NotificationResponse)
        if !ok </span><span class="cov0" title="0">{
                return nil, models.CreateError(models.ErrorCodeInternalError, "Invalid response type from notification service")
        }</span>

        <span class="cov0" title="0">return response, nil</span>
}

// sendNotificationWithRetry sends notification with retry logic
func (c *notificationClient) sendNotificationWithRetry(ctx context.Context, payload *models.NotificationPayload) (*models.NotificationResponse, error) <span class="cov0" title="0">{
        // Convert payload to JSON
        jsonData, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal notification payload: %w", err)
        }</span>

        // Create HTTP request
        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, "POST", c.baseURL+"/notifications/send", bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create HTTP request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("X-Service-Name", "auth-service")
        req.Header.Set("X-Request-ID", getRequestID(ctx))

        // Send request with retry logic
        var lastErr error
        for attempt := 1; attempt &lt;= c.config.MaxRetries; attempt++ </span><span class="cov0" title="0">{
                resp, err := c.httpClient.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        lastErr = fmt.Errorf("HTTP request failed (attempt %d): %w", attempt, err)

                        // If this is not the last attempt, wait before retrying
                        if attempt &lt; c.config.MaxRetries </span><span class="cov0" title="0">{
                                backoff := time.Duration(attempt) * c.config.RetryDelay
                                select </span>{
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        return nil, ctx.Err()</span>
                                case &lt;-time.After(backoff):<span class="cov0" title="0">
                                        continue</span>
                                }
                        }
                        <span class="cov0" title="0">continue</span>
                }

                // If we got a response, process it
                <span class="cov0" title="0">return c.processResponse(resp)</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("all retry attempts failed: %w", lastErr)</span>
}

// processResponse processes the HTTP response
func (c *notificationClient) processResponse(resp *http.Response) (*models.NotificationResponse, error) <span class="cov0" title="0">{
        defer resp.Body.Close()

        // Read response body
        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response body: %w", err)
        }</span>

        // Parse response
        <span class="cov0" title="0">var notificationResp models.NotificationResponse
        if err := json.Unmarshal(body, &amp;notificationResp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal notification response: %w", err)
        }</span>

        // Check HTTP status code and handle errors
        <span class="cov0" title="0">switch resp.StatusCode </span>{
        case http.StatusOK, http.StatusCreated, http.StatusAccepted:<span class="cov0" title="0">
                return &amp;notificationResp, nil</span>
        case http.StatusBadRequest:<span class="cov0" title="0">
                return nil, models.CreateError(models.ErrorCodeInvalidRequest, notificationResp.Error)</span>
        case http.StatusUnauthorized:<span class="cov0" title="0">
                return nil, models.CreateError(models.ErrorCodeAuthentication, notificationResp.Error)</span>
        case http.StatusForbidden:<span class="cov0" title="0">
                return nil, models.CreateError(models.ErrorCodeAuthorization, notificationResp.Error)</span>
        case http.StatusTooManyRequests:<span class="cov0" title="0">
                return nil, models.CreateError(models.ErrorCodeRateLimitExceeded, notificationResp.Error)</span>
        case http.StatusInternalServerError:<span class="cov0" title="0">
                return nil, models.CreateError(models.ErrorCodeInternalError, notificationResp.Error)</span>
        case http.StatusServiceUnavailable:<span class="cov0" title="0">
                return nil, models.CreateError(models.ErrorCodeServiceUnavailable, notificationResp.Error)</span>
        default:<span class="cov0" title="0">
                return nil, models.CreateError(models.ErrorCodeServiceUnavailable,
                        fmt.Sprintf("unexpected status code: %d", resp.StatusCode))</span>
        }
}

// GetCircuitBreakerState returns the current circuit breaker state
func (c *notificationClient) GetCircuitBreakerState() gobreaker.State <span class="cov0" title="0">{
        return c.circuitBreaker.State()
}</span>

// getRequestID extracts request ID from context
func getRequestID(ctx context.Context) string <span class="cov0" title="0">{
        if requestID, ok := ctx.Value("request_id").(string); ok </span><span class="cov0" title="0">{
                return requestID
        }</span>
        <span class="cov0" title="0">return "unknown"</span>
}

// MockNotificationClient for testing
type MockNotificationClient struct {
        SendNotificationFunc func(ctx context.Context, payload *models.NotificationPayload) (*models.NotificationResponse, error)
        CircuitBreakerState  gobreaker.State
}

func (m *MockNotificationClient) SendNotification(ctx context.Context, payload *models.NotificationPayload) (*models.NotificationResponse, error) <span class="cov10" title="6">{
        if m.SendNotificationFunc != nil </span><span class="cov10" title="6">{
                return m.SendNotificationFunc(ctx, payload)
        }</span>
        <span class="cov0" title="0">return &amp;models.NotificationResponse{Success: true, MessageID: "mock-message-id"}, nil</span>
}

func (m *MockNotificationClient) GetCircuitBreakerState() gobreaker.State <span class="cov0" title="0">{
        return m.CircuitBreakerState
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package service

import (
        "auth-service/internal/config"
        "auth-service/internal/models"
        "context"
        "crypto/rand"
        "fmt"
        "log"
        "math"
        "sync"
        "time"
)

// OTPService defines the interface for OTP operations
type OTPService interface {
        GenerateAndSendOTP(req *models.OTPRequest, config *models.TenantOTPConfig) (*models.OTPResponse, error)
        ValidateOTP(req *models.OTPVerifyRequest) (bool, error)
        GetTenantOTPConfig(tenantID string) (*models.TenantOTPConfig, error)
        UpdateUserOTPPreference(pref *models.UserOTPPreference) error
        GetSMSUsageInfo(tenantID string) (*models.SMSUsageInfo, error)
        ResetBillingCycle(tenantID string) error
        TriggerTwoFactorAuth(ctx context.Context, req *models.TwoFactorAuthRequest) (*models.TwoFactorAuthResponse, error)
        ValidateTenantOnboardingConfig(config *models.TenantOTPConfig) error
}

type otpService struct {
        store              map[string]*models.OTPRecord
        usage              map[string]*models.TenantOTPConfig // Track usage per tenant
        notificationClient NotificationClient
        subscriptionClient SubscriptionClient
        mu                 sync.Mutex
}

// NewOTPService creates a new OTP service with default configuration
func NewOTPService() OTPService <span class="cov3" title="3">{
        serviceConfig := config.DefaultServiceConfig()

        return &amp;otpService{
                store:              make(map[string]*models.OTPRecord),
                usage:              make(map[string]*models.TenantOTPConfig),
                notificationClient: NewNotificationClient(serviceConfig.NotificationService),
                subscriptionClient: NewSubscriptionClient(serviceConfig.SubscriptionService),
        }
}</span>

// NewOTPServiceWithConfig creates OTP service with custom configuration
func NewOTPServiceWithConfig(serviceConfig *config.ServiceConfig) OTPService <span class="cov0" title="0">{
        return &amp;otpService{
                store:              make(map[string]*models.OTPRecord),
                usage:              make(map[string]*models.TenantOTPConfig),
                notificationClient: NewNotificationClient(serviceConfig.NotificationService),
                subscriptionClient: NewSubscriptionClient(serviceConfig.SubscriptionService),
        }
}</span>

// NewOTPServiceWithClients creates OTP service with custom clients (for testing)
func NewOTPServiceWithClients(notificationClient NotificationClient, subscriptionClient SubscriptionClient) OTPService <span class="cov1" title="1">{
        return &amp;otpService{
                store:              make(map[string]*models.OTPRecord),
                usage:              make(map[string]*models.TenantOTPConfig),
                notificationClient: notificationClient,
                subscriptionClient: subscriptionClient,
        }
}</span>

// GenerateAndSendOTP generates and sends OTP based on field type and tenant configuration
func (s *otpService) GenerateAndSendOTP(req *models.OTPRequest, config *models.TenantOTPConfig) (*models.OTPResponse, error) <span class="cov7" title="17">{
        s.mu.Lock()
        defer s.mu.Unlock()

        // Validate that at least one field is provided
        if req.Email == "" &amp;&amp; req.Mobile == "" </span><span class="cov0" title="0">{
                return nil, models.CreateError(models.ErrorCodeMissingFields, "either email or mobile number is required")
        }</span>

        // Determine field type and validate
        <span class="cov7" title="17">fieldType, err := s.determineFieldType(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, models.CreateError(models.ErrorCodeInvalidRequest, err.Error())
        }</span>

        // Determine delivery method based on field type and tenant config
        <span class="cov7" title="17">deliveryMethod := s.determineDeliveryMethod(req, config, fieldType)

        // Validate that the chosen method is enabled for the tenant
        if !s.isDeliveryMethodEnabled(deliveryMethod, config) </span><span class="cov0" title="0">{
                return nil, models.CreateError(models.ErrorCodeFeatureDisabled,
                        fmt.Sprintf("delivery method %s is not enabled for this tenant", deliveryMethod))
        }</span>

        // Validate field type against tenant configuration
        <span class="cov7" title="17">if !s.isFieldTypeAllowed(fieldType, config) </span><span class="cov0" title="0">{
                return nil, models.CreateError(models.ErrorCodeFeatureDisabled,
                        fmt.Sprintf("field type %s is not allowed for this tenant", fieldType))
        }</span>

        // Check SMS limits if SMS delivery is requested
        <span class="cov7" title="17">if deliveryMethod == models.OTPDeliverySMS || deliveryMethod == models.OTPDeliveryBoth </span><span class="cov0" title="0">{
                if err := s.checkSMSLimit(config); err != nil </span><span class="cov0" title="0">{
                        return nil, models.CreateError(models.ErrorCode2FAQuotaExceeded, err.Error())
                }</span>
        }

        // Generate OTP with tenant-specific digit length
        <span class="cov7" title="17">code, digitLength, err := s.generateOTP(config)
        if err != nil </span><span class="cov5" title="6">{
                return nil, err
        }</span>

        <span class="cov6" title="11">expirationMinutes := config.OTPExpirationMinutes
        if expirationMinutes == 0 </span><span class="cov5" title="7">{
                expirationMinutes = 5 // default 5 minutes
        }</span>

        <span class="cov6" title="11">record := &amp;models.OTPRecord{
                Email:          req.Email,
                Mobile:         req.Mobile,
                TenantID:       req.TenantID,
                Code:           code,
                DeliveryMethod: deliveryMethod,
                FieldType:      fieldType,
                ExpiresAt:      time.Now().Add(time.Duration(expirationMinutes) * time.Minute),
                Used:           false,
                CreatedAt:      time.Now(),
        }

        key := s.generateKey(req, fieldType)
        s.store[key] = record

        // Track usage and send OTP
        var smsUsageInfo *models.SMSUsageInfo
        switch deliveryMethod </span>{
        case models.OTPDeliveryEmail:<span class="cov6" title="11">
                if fieldType == models.OTPFieldEmail </span><span class="cov6" title="11">{
                        s.sendEmailOTP(req.Email, code, req.TenantID)
                }</span> else<span class="cov0" title="0"> {
                        return nil, models.CreateError(models.ErrorCodeInvalidRequest, "email delivery method requires email field type")
                }</span>
        case models.OTPDeliverySMS:<span class="cov0" title="0">
                if fieldType == models.OTPFieldMobile </span><span class="cov0" title="0">{
                        s.sendSMSOTP(req.Mobile, code, req.TenantID)
                        s.incrementSMSUsage(config)
                        smsUsageInfo = s.getSMSUsageInfo(config)
                }</span> else<span class="cov0" title="0"> {
                        return nil, models.CreateError(models.ErrorCodeInvalidRequest, "SMS delivery method requires mobile field type")
                }</span>
        case models.OTPDeliveryBoth:<span class="cov0" title="0">
                if req.Email != "" </span><span class="cov0" title="0">{
                        s.sendEmailOTP(req.Email, code, req.TenantID)
                }</span>
                <span class="cov0" title="0">if req.Mobile != "" </span><span class="cov0" title="0">{
                        s.sendSMSOTP(req.Mobile, code, req.TenantID)
                        s.incrementSMSUsage(config)
                        smsUsageInfo = s.getSMSUsageInfo(config)
                }</span>
        }

        <span class="cov6" title="11">availableMethods := s.getAvailableMethods(config)
        availableFields := s.getAvailableFields(config)

        return &amp;models.OTPResponse{
                Message:          fmt.Sprintf("OTP sent via %s to %s", deliveryMethod, fieldType),
                DeliveryMethod:   deliveryMethod,
                FieldType:        fieldType,
                ExpiresIn:        expirationMinutes * 60,
                OTPDigitLength:   digitLength,
                AvailableMethods: availableMethods,
                AvailableFields:  availableFields,
                SMSUsageInfo:     smsUsageInfo,
        }, nil</span>
}

// ValidateOTP checks if the OTP is valid and not expired/used
func (s *otpService) ValidateOTP(req *models.OTPVerifyRequest) (bool, error) <span class="cov3" title="3">{
        s.mu.Lock()
        defer s.mu.Unlock()

        // Determine field type from request
        fieldType, err := s.determineFieldTypeFromVerify(req)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov3" title="3">key := s.generateKeyFromVerify(req, fieldType)
        record, ok := s.store[key]
        if !ok </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov3" title="3">if record.Used || time.Now().After(record.ExpiresAt) </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov3" title="3">if record.Code != req.Code </span><span class="cov3" title="3">{
                return false, nil
        }</span>

        <span class="cov0" title="0">record.Used = true
        return true, nil</span>
}

// GetTenantOTPConfig returns OTP configuration for a tenant
func (s *otpService) GetTenantOTPConfig(tenantID string) (*models.TenantOTPConfig, error) <span class="cov6" title="10">{
        // In real implementation, fetch from database
        // For demo, return default config based on tenant plan
        var config *models.TenantOTPConfig

        switch tenantID </span>{
        case "tenant-basic":<span class="cov2" title="2">
                config = &amp;models.TenantOTPConfig{
                        TenantID:              tenantID,
                        Plan:                  "basic",
                        EnableEmailOTP:        true,
                        EnableSMSOTP:          false,
                        DefaultDeliveryMethod: models.OTPDeliveryEmail,
                        AllowUserChoice:       false,
                        AllowFieldChoice:      false,
                        OTPExpirationMinutes:  5,
                        OTPDigitLength:        4, // 4-digit OTP for basic plan
                        MaxOTPAttempts:        3,
                        RateLimitPerHour:      5,
                        MonthlySMSLimit:       0, // No SMS for basic plan
                        CurrentSMSUsage:       0,
                        SMSCostPerMessage:     0.05,
                        BillingCycleStart:     time.Now().Truncate(24 * time.Hour),
                }</span>
        case "tenant-pro":<span class="cov4" title="4">
                config = &amp;models.TenantOTPConfig{
                        TenantID:              tenantID,
                        Plan:                  "pro",
                        EnableEmailOTP:        true,
                        EnableSMSOTP:          true,
                        DefaultDeliveryMethod: models.OTPDeliveryUserChoice,
                        AllowUserChoice:       true,
                        AllowFieldChoice:      true,
                        OTPExpirationMinutes:  10,
                        OTPDigitLength:        6, // 6-digit OTP for pro plan
                        MaxOTPAttempts:        5,
                        RateLimitPerHour:      10,
                        MonthlySMSLimit:       1000, // 1000 SMS per month
                        CurrentSMSUsage:       0,
                        SMSCostPerMessage:     0.05,
                        BillingCycleStart:     time.Now().Truncate(24 * time.Hour),
                }</span>
        case "tenant-enterprise":<span class="cov2" title="2">
                config = &amp;models.TenantOTPConfig{
                        TenantID:              tenantID,
                        Plan:                  "enterprise",
                        EnableEmailOTP:        true,
                        EnableSMSOTP:          true,
                        DefaultDeliveryMethod: models.OTPDeliveryBoth,
                        AllowUserChoice:       true,
                        AllowFieldChoice:      true,
                        OTPExpirationMinutes:  5,
                        OTPDigitLength:        8, // 8-digit OTP for enterprise plan
                        MaxOTPAttempts:        3,
                        RateLimitPerHour:      20,
                        MonthlySMSLimit:       10000, // 10,000 SMS per month
                        CurrentSMSUsage:       0,
                        SMSCostPerMessage:     0.05,
                        BillingCycleStart:     time.Now().Truncate(24 * time.Hour),
                }</span>
        default:<span class="cov2" title="2">
                // Default configuration for unknown tenants
                config = &amp;models.TenantOTPConfig{
                        TenantID:              tenantID,
                        Plan:                  "default",
                        EnableEmailOTP:        true,
                        EnableSMSOTP:          false,
                        DefaultDeliveryMethod: models.OTPDeliveryEmail,
                        AllowUserChoice:       false,
                        AllowFieldChoice:      false,
                        OTPExpirationMinutes:  5,
                        OTPDigitLength:        6, // Default 6-digit OTP
                        MaxOTPAttempts:        3,
                        RateLimitPerHour:      10,
                        MonthlySMSLimit:       0,
                        CurrentSMSUsage:       0,
                        SMSCostPerMessage:     0.05,
                        BillingCycleStart:     time.Now().Truncate(24 * time.Hour),
                }</span>
        }

        // Validate the configuration before returning
        <span class="cov6" title="10">if err := s.validateTenantOTPConfig(config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid tenant OTP configuration for %s: %w", tenantID, err)
        }</span>

        // Check if we need to reset billing cycle
        <span class="cov6" title="10">s.checkAndResetBillingCycle(config)

        // Load current usage from storage
        if storedConfig, exists := s.usage[tenantID]; exists </span><span class="cov0" title="0">{
                config.CurrentSMSUsage = storedConfig.CurrentSMSUsage
                config.BillingCycleStart = storedConfig.BillingCycleStart
        }</span>

        <span class="cov6" title="10">return config, nil</span>
}

// ValidateTenantOnboardingConfig validates OTP configuration during tenant onboarding
func (s *otpService) ValidateTenantOnboardingConfig(config *models.TenantOTPConfig) error <span class="cov0" title="0">{
        // Use the same validation logic
        if err := s.validateTenantOTPConfig(config); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Additional onboarding-specific validations
        <span class="cov0" title="0">if config.Plan == "" </span><span class="cov0" title="0">{
                return models.CreateError(models.ErrorCodeMissingFields, "plan is required for tenant onboarding")
        }</span>

        // Ensure digit length is explicitly set (not defaulted)
        <span class="cov0" title="0">if config.OTPDigitLength == 0 </span><span class="cov0" title="0">{
                return models.CreateError(models.ErrorCodeMissingFields,
                        "OTP digit length must be explicitly specified during tenant onboarding (cannot be 0)")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetSMSUsageInfo returns SMS usage information for a tenant
func (s *otpService) GetSMSUsageInfo(tenantID string) (*models.SMSUsageInfo, error) <span class="cov0" title="0">{
        config, err := s.GetTenantOTPConfig(tenantID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return s.getSMSUsageInfo(config), nil</span>
}

// ResetBillingCycle resets the billing cycle for a tenant
func (s *otpService) ResetBillingCycle(tenantID string) error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if storedConfig, exists := s.usage[tenantID]; exists </span><span class="cov0" title="0">{
                storedConfig.CurrentSMSUsage = 0
                storedConfig.BillingCycleStart = time.Now().Truncate(24 * time.Hour)
                log.Printf("[OTP] Reset billing cycle for tenant %s", tenantID)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UpdateUserOTPPreference updates user's OTP delivery preference
func (s *otpService) UpdateUserOTPPreference(pref *models.UserOTPPreference) error <span class="cov0" title="0">{
        // In real implementation, save to database
        pref.UpdatedAt = time.Now()
        log.Printf("[OTP] Updated user preference: %s prefers %s via %s", pref.UserID, pref.PreferredMethod, pref.PreferredField)
        return nil
}</span>

// Helper methods
func (s *otpService) checkSMSLimit(config *models.TenantOTPConfig) error <span class="cov0" title="0">{
        if config.MonthlySMSLimit == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("SMS OTP is not available for %s plan", config.Plan)
        }</span>

        <span class="cov0" title="0">if config.CurrentSMSUsage &gt;= config.MonthlySMSLimit </span><span class="cov0" title="0">{
                return fmt.Errorf("monthly SMS limit of %d reached for %s plan", config.MonthlySMSLimit, config.Plan)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *otpService) incrementSMSUsage(config *models.TenantOTPConfig) <span class="cov0" title="0">{
        // Store usage in memory (in real implementation, save to database)
        if storedConfig, exists := s.usage[config.TenantID]; exists </span><span class="cov0" title="0">{
                storedConfig.CurrentSMSUsage++
        }</span> else<span class="cov0" title="0"> {
                s.usage[config.TenantID] = &amp;models.TenantOTPConfig{
                        TenantID:          config.TenantID,
                        CurrentSMSUsage:   1,
                        BillingCycleStart: config.BillingCycleStart,
                }
        }</span>

        <span class="cov0" title="0">log.Printf("[OTP] SMS usage incremented for tenant %s: %d/%d",
                config.TenantID, s.usage[config.TenantID].CurrentSMSUsage, config.MonthlySMSLimit)</span>
}

func (s *otpService) getSMSUsageInfo(config *models.TenantOTPConfig) *models.SMSUsageInfo <span class="cov0" title="0">{
        currentUsage := 0
        if storedConfig, exists := s.usage[config.TenantID]; exists </span><span class="cov0" title="0">{
                currentUsage = storedConfig.CurrentSMSUsage
        }</span>

        <span class="cov0" title="0">remaining := config.MonthlySMSLimit - currentUsage
        if remaining &lt; 0 </span><span class="cov0" title="0">{
                remaining = 0
        }</span>

        <span class="cov0" title="0">usagePercentage := 0.0
        if config.MonthlySMSLimit &gt; 0 </span><span class="cov0" title="0">{
                usagePercentage = math.Round((float64(currentUsage) / float64(config.MonthlySMSLimit)) * 100)
        }</span>

        <span class="cov0" title="0">billingCycleEnd := config.BillingCycleStart.AddDate(0, 1, 0)

        return &amp;models.SMSUsageInfo{
                MonthlyLimit:    config.MonthlySMSLimit,
                CurrentUsage:    currentUsage,
                RemainingSMS:    remaining,
                UsagePercentage: usagePercentage,
                BillingCycleEnd: billingCycleEnd,
        }</span>
}

func (s *otpService) checkAndResetBillingCycle(config *models.TenantOTPConfig) <span class="cov6" title="10">{
        // Check if billing cycle needs to be reset (monthly)
        now := time.Now()
        nextBillingCycle := config.BillingCycleStart.AddDate(0, 1, 0)

        if now.After(nextBillingCycle) </span><span class="cov0" title="0">{
                // Reset billing cycle
                if storedConfig, exists := s.usage[config.TenantID]; exists </span><span class="cov0" title="0">{
                        storedConfig.CurrentSMSUsage = 0
                        storedConfig.BillingCycleStart = now.Truncate(24 * time.Hour)
                        log.Printf("[OTP] Billing cycle reset for tenant %s", config.TenantID)
                }</span>
        }
}

func (s *otpService) determineFieldType(req *models.OTPRequest) (models.OTPFieldType, error) <span class="cov7" title="17">{
        // If user specified field type, validate it
        if req.FieldType != "" </span><span class="cov0" title="0">{
                if req.FieldType == models.OTPFieldEmail &amp;&amp; req.Email == "" </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("email field type requires email address")
                }</span>
                <span class="cov0" title="0">if req.FieldType == models.OTPFieldMobile &amp;&amp; req.Mobile == "" </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("mobile field type requires mobile number")
                }</span>
                <span class="cov0" title="0">return req.FieldType, nil</span>
        }

        // Auto-determine based on provided fields
        <span class="cov7" title="17">if req.Email != "" &amp;&amp; req.Mobile == "" </span><span class="cov7" title="17">{
                return models.OTPFieldEmail, nil
        }</span>
        <span class="cov0" title="0">if req.Mobile != "" &amp;&amp; req.Email == "" </span><span class="cov0" title="0">{
                return models.OTPFieldMobile, nil
        }</span>
        <span class="cov0" title="0">if req.Email != "" &amp;&amp; req.Mobile != "" </span><span class="cov0" title="0">{
                // Both provided, default to email unless user specified mobile
                return models.OTPFieldEmail, nil
        }</span>

        <span class="cov0" title="0">return "", fmt.Errorf("either email or mobile number is required")</span>
}

func (s *otpService) determineFieldTypeFromVerify(req *models.OTPVerifyRequest) (models.OTPFieldType, error) <span class="cov3" title="3">{
        // If user specified field type, validate it
        if req.FieldType != "" </span><span class="cov0" title="0">{
                if req.FieldType == models.OTPFieldEmail &amp;&amp; req.Email == "" </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("email field type requires email address")
                }</span>
                <span class="cov0" title="0">if req.FieldType == models.OTPFieldMobile &amp;&amp; req.Mobile == "" </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("mobile field type requires mobile number")
                }</span>
                <span class="cov0" title="0">return req.FieldType, nil</span>
        }

        // Auto-determine based on provided fields
        <span class="cov3" title="3">if req.Email != "" &amp;&amp; req.Mobile == "" </span><span class="cov3" title="3">{
                return models.OTPFieldEmail, nil
        }</span>
        <span class="cov0" title="0">if req.Mobile != "" &amp;&amp; req.Email == "" </span><span class="cov0" title="0">{
                return models.OTPFieldMobile, nil
        }</span>
        <span class="cov0" title="0">if req.Email != "" &amp;&amp; req.Mobile != "" </span><span class="cov0" title="0">{
                // Both provided, default to email unless user specified mobile
                return models.OTPFieldEmail, nil
        }</span>

        <span class="cov0" title="0">return "", fmt.Errorf("either email or mobile number is required")</span>
}

func (s *otpService) determineDeliveryMethod(req *models.OTPRequest, config *models.TenantOTPConfig, fieldType models.OTPFieldType) models.OTPDeliveryMethod <span class="cov7" title="17">{
        // If user specified a method and it's allowed
        if req.DeliveryMethod != "" &amp;&amp; s.isDeliveryMethodEnabled(req.DeliveryMethod, config) </span><span class="cov0" title="0">{
                return req.DeliveryMethod
        }</span>

        // Auto-determine based on field type and tenant config
        <span class="cov7" title="17">switch fieldType </span>{
        case models.OTPFieldEmail:<span class="cov7" title="17">
                if config.EnableEmailOTP </span><span class="cov7" title="17">{
                        return models.OTPDeliveryEmail
                }</span>
        case models.OTPFieldMobile:<span class="cov0" title="0">
                if config.EnableSMSOTP </span><span class="cov0" title="0">{
                        return models.OTPDeliverySMS
                }</span>
        }

        // Use tenant default
        <span class="cov0" title="0">return config.DefaultDeliveryMethod</span>
}

func (s *otpService) isDeliveryMethodEnabled(method models.OTPDeliveryMethod, config *models.TenantOTPConfig) bool <span class="cov7" title="17">{
        switch method </span>{
        case models.OTPDeliveryEmail:<span class="cov7" title="17">
                return config.EnableEmailOTP</span>
        case models.OTPDeliverySMS:<span class="cov0" title="0">
                return config.EnableSMSOTP</span>
        case models.OTPDeliveryBoth:<span class="cov0" title="0">
                return config.EnableEmailOTP &amp;&amp; config.EnableSMSOTP</span>
        case models.OTPDeliveryUserChoice:<span class="cov0" title="0">
                return config.AllowUserChoice</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

func (s *otpService) isFieldTypeAllowed(fieldType models.OTPFieldType, config *models.TenantOTPConfig) bool <span class="cov7" title="17">{
        switch fieldType </span>{
        case models.OTPFieldEmail:<span class="cov7" title="17">
                return config.EnableEmailOTP</span>
        case models.OTPFieldMobile:<span class="cov0" title="0">
                return config.EnableSMSOTP</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

func (s *otpService) getAvailableMethods(config *models.TenantOTPConfig) []models.OTPDeliveryMethod <span class="cov6" title="11">{
        var methods []models.OTPDeliveryMethod
        if config.EnableEmailOTP </span><span class="cov6" title="11">{
                methods = append(methods, models.OTPDeliveryEmail)
        }</span>
        <span class="cov6" title="11">if config.EnableSMSOTP </span><span class="cov2" title="2">{
                methods = append(methods, models.OTPDeliverySMS)
        }</span>
        <span class="cov6" title="11">if config.EnableEmailOTP &amp;&amp; config.EnableSMSOTP </span><span class="cov2" title="2">{
                methods = append(methods, models.OTPDeliveryBoth)
        }</span>
        <span class="cov6" title="11">if config.AllowUserChoice </span><span class="cov2" title="2">{
                methods = append(methods, models.OTPDeliveryUserChoice)
        }</span>
        <span class="cov6" title="11">return methods</span>
}

func (s *otpService) getAvailableFields(config *models.TenantOTPConfig) []models.OTPFieldType <span class="cov6" title="11">{
        var fields []models.OTPFieldType
        if config.EnableEmailOTP </span><span class="cov6" title="11">{
                fields = append(fields, models.OTPFieldEmail)
        }</span>
        <span class="cov6" title="11">if config.EnableSMSOTP </span><span class="cov2" title="2">{
                fields = append(fields, models.OTPFieldMobile)
        }</span>
        <span class="cov6" title="11">return fields</span>
}

func (s *otpService) generateKey(req *models.OTPRequest, fieldType models.OTPFieldType) string <span class="cov6" title="11">{
        switch fieldType </span>{
        case models.OTPFieldEmail:<span class="cov6" title="11">
                return req.Email + ":" + req.TenantID</span>
        case models.OTPFieldMobile:<span class="cov0" title="0">
                return req.Mobile + ":" + req.TenantID</span>
        default:<span class="cov0" title="0">
                return req.Email + ":" + req.TenantID</span>
        }
}

func (s *otpService) generateKeyFromVerify(req *models.OTPVerifyRequest, fieldType models.OTPFieldType) string <span class="cov3" title="3">{
        switch fieldType </span>{
        case models.OTPFieldEmail:<span class="cov3" title="3">
                return req.Email + ":" + req.TenantID</span>
        case models.OTPFieldMobile:<span class="cov0" title="0">
                return req.Mobile + ":" + req.TenantID</span>
        default:<span class="cov0" title="0">
                return req.Email + ":" + req.TenantID</span>
        }
}

func (s *otpService) sendEmailOTP(email, code, tenantID string) <span class="cov6" title="11">{
        // For demo: log to console (replace with email service)
        log.Printf("[OTP-EMAIL] Sent OTP %s to %s (tenant: %s)", code, email, tenantID)
}</span>

func (s *otpService) sendSMSOTP(mobile, code, tenantID string) <span class="cov0" title="0">{
        // For demo: log to console (replace with SMS service)
        log.Printf("[OTP-SMS] Sent OTP %s to %s (tenant: %s)", code, mobile, tenantID)
}</span>

func randomInt(min, max int) int <span class="cov7" title="17">{
        b := make([]byte, 2)
        rand.Read(b)
        return min + int(b[0])%((max-min)+1)
}</span>

// TriggerTwoFactorAuth triggers 2FA via Notification Service with subscription validation
func (s *otpService) TriggerTwoFactorAuth(ctx context.Context, req *models.TwoFactorAuthRequest) (*models.TwoFactorAuthResponse, error) <span class="cov6" title="11">{
        s.mu.Lock()
        defer s.mu.Unlock()

        // Validate required fields using map-based validation
        if err := s.validateTwoFactorRequest(req); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get channel information using map lookup
        <span class="cov6" title="11">feature, channelType, valid := models.GetChannelInfo(req.Channel)
        if !valid </span><span class="cov1" title="1">{
                return nil, models.CreateError(models.ErrorCodeInvalidChannel,
                        fmt.Sprintf("Invalid channel: %s. Valid channels: %v", req.Channel, models.ValidChannels()))
        }</span>

        // Validate subscription and quota
        <span class="cov6" title="10">subscriptionResp, err := s.validateSubscription(ctx, req.ClientID, feature)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        // Check subscription validation results using map-based error handling
        <span class="cov6" title="9">if err := s.checkSubscriptionValidation(subscriptionResp, req.Channel); err != nil </span><span class="cov3" title="3">{
                return nil, err
        }</span>

        // Get tenant config for OTP settings
        <span class="cov5" title="6">config, err := s.GetTenantOTPConfig(req.ClientID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, models.CreateError(models.ErrorCodeInternalError,
                        fmt.Sprintf("failed to get tenant config: %v", err))
        }</span>

        // Generate OTP with tenant-specific digit length
        <span class="cov5" title="6">code, digitLength, err := s.generateOTP(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store OTP record
        <span class="cov5" title="6">record, err := s.createOTPRecord(req, code, channelType, config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store OTP with key based on recipient and client
        <span class="cov5" title="6">key := req.Recipient + ":" + req.ClientID
        s.store[key] = record

        // Prepare and send notification
        notificationResp, err := s.sendNotification(ctx, req, code, channelType, config)
        if err != nil </span><span class="cov1" title="1">{
                // Remove the stored OTP since notification failed
                delete(s.store, key)
                return nil, err
        }</span>

        // Log the 2FA trigger
        <span class="cov4" title="5">log.Printf("[2FA] Triggered %s 2FA for user %s (client: %s, message_id: %s)",
                req.Channel, req.UserID, req.ClientID, notificationResp.MessageID)

        return &amp;models.TwoFactorAuthResponse{
                Success:        true,
                Message:        fmt.Sprintf("2FA code sent via %s", req.Channel),
                OTPDigitLength: digitLength,
                ExpiresIn:      config.OTPExpirationMinutes * 60, // Convert to seconds
                MessageID:      notificationResp.MessageID,
        }, nil</span>
}

// validateTwoFactorRequest validates the 2FA request
func (s *otpService) validateTwoFactorRequest(req *models.TwoFactorAuthRequest) error <span class="cov6" title="11">{
        // Use map for required field validation
        requiredFields := map[string]string{
                "user_id":   req.UserID,
                "client_id": req.ClientID,
                "channel":   req.Channel,
                "recipient": req.Recipient,
        }

        for field, value := range requiredFields </span><span class="cov10" title="44">{
                if value == "" </span><span class="cov0" title="0">{
                        return models.CreateError(models.ErrorCodeMissingFields,
                                fmt.Sprintf("Missing required field: %s", field))
                }</span>
        }

        <span class="cov6" title="11">return nil</span>
}

// validateSubscription validates subscription with the subscription service
func (s *otpService) validateSubscription(ctx context.Context, clientID, feature string) (*models.SubscriptionValidationResponse, error) <span class="cov6" title="10">{
        subscriptionReq := &amp;models.SubscriptionValidationRequest{
                ClientID: clientID,
                Feature:  feature,
        }

        subscriptionResp, err := s.subscriptionClient.ValidateSubscription(ctx, subscriptionReq)
        if err != nil </span><span class="cov1" title="1">{
                return nil, models.CreateError(models.ErrorCodeServiceUnavailable,
                        fmt.Sprintf("subscription validation failed: %v", err))
        }</span>

        <span class="cov6" title="9">return subscriptionResp, nil</span>
}

// checkSubscriptionValidation checks subscription validation results
func (s *otpService) checkSubscriptionValidation(resp *models.SubscriptionValidationResponse, channel string) error <span class="cov6" title="9">{
        // Use map for validation checks
        validationChecks := map[string]struct {
                condition bool
                errorCode models.ErrorCode
                message   string
        }{
                "subscription_valid": {
                        condition: resp.Valid,
                        errorCode: models.ErrorCodeInvalidSubscription,
                        message:   "Client subscription is invalid",
                },
                "feature_enabled": {
                        condition: resp.FeatureEnabled,
                        errorCode: models.ErrorCodeFeatureDisabled,
                        message:   fmt.Sprintf("2FA %s feature is not enabled for this client", channel),
                },
                "quota_available": {
                        condition: resp.QuotaAvailable,
                        errorCode: models.ErrorCode2FAQuotaExceeded,
                        message:   fmt.Sprintf("The client's %s 2FA quota has been exceeded", channel),
                },
        }

        for _, check := range validationChecks </span><span class="cov8" title="23">{
                if !check.condition </span><span class="cov3" title="3">{
                        return models.CreateError(check.errorCode, check.message)
                }</span>
        }

        <span class="cov5" title="6">return nil</span>
}

// generateOTP generates OTP with tenant-specific digit length
func (s *otpService) generateOTP(config *models.TenantOTPConfig) (string, int, error) <span class="cov8" title="23">{
        digitLength := config.OTPDigitLength

        // Load system configuration for defaults and validation
        const (
                MinDigitLength = 4
                MaxDigitLength = 10
        )

        // STRICT VALIDATION - No fallbacks, configuration MUST be valid
        if digitLength &lt;= 0 </span><span class="cov1" title="1">{
                return "", 0, models.CreateError(models.ErrorCodeInvalidRequest,
                        fmt.Sprintf("OTP digit length cannot be 0 or negative, got %d", digitLength))
        }</span>

        // Validate digit length range
        <span class="cov8" title="22">if digitLength &lt; MinDigitLength || digitLength &gt; MaxDigitLength </span><span class="cov4" title="5">{
                return "", 0, models.CreateError(models.ErrorCodeInvalidRequest,
                        fmt.Sprintf("invalid OTP digit length: %d (must be between %d and %d)",
                                digitLength, MinDigitLength, MaxDigitLength))
        }</span>

        // Calculate min and max values for the digit length
        <span class="cov7" title="17">min := int(math.Pow10(digitLength - 1))
        max := int(math.Pow10(digitLength)) - 1
        code := fmt.Sprintf("%0*d", digitLength, randomInt(min, max))

        return code, digitLength, nil</span>
}

// createOTPRecord creates an OTP record
func (s *otpService) createOTPRecord(req *models.TwoFactorAuthRequest, code, channelType string, config *models.TenantOTPConfig) (*models.OTPRecord, error) <span class="cov5" title="6">{
        // Set expiration time
        expirationMinutes := config.OTPExpirationMinutes
        if expirationMinutes == 0 </span><span class="cov0" title="0">{
                expirationMinutes = 5 // default 5 minutes
        }</span>

        // Use map for delivery method mapping
        <span class="cov5" title="6">deliveryMethodMap := map[string]models.OTPDeliveryMethod{
                "EMAIL": models.OTPDeliveryEmail,
                "SMS":   models.OTPDeliverySMS,
        }

        // Use map for field type mapping
        fieldTypeMap := map[string]models.OTPFieldType{
                "EMAIL": models.OTPFieldEmail,
                "SMS":   models.OTPFieldMobile,
        }

        deliveryMethod, ok := deliveryMethodMap[channelType]
        if !ok </span><span class="cov0" title="0">{
                return nil, models.CreateError(models.ErrorCodeInvalidRequest,
                        fmt.Sprintf("invalid channel type: %s", channelType))
        }</span>

        <span class="cov5" title="6">fieldType, ok := fieldTypeMap[channelType]
        if !ok </span><span class="cov0" title="0">{
                return nil, models.CreateError(models.ErrorCodeInvalidRequest,
                        fmt.Sprintf("invalid channel type: %s", channelType))
        }</span>

        <span class="cov5" title="6">record := &amp;models.OTPRecord{
                Email:          req.Recipient, // For both email and SMS, store in email field
                Mobile:         req.Recipient, // For both email and SMS, store in mobile field
                TenantID:       req.ClientID,
                Code:           code,
                DeliveryMethod: deliveryMethod,
                FieldType:      fieldType,
                ExpiresAt:      time.Now().Add(time.Duration(expirationMinutes) * time.Minute),
                Used:           false,
                CreatedAt:      time.Now(),
        }

        return record, nil</span>
}

// sendNotification sends notification via the notification service
func (s *otpService) sendNotification(ctx context.Context, req *models.TwoFactorAuthRequest, code, channelType string, config *models.TenantOTPConfig) (*models.NotificationResponse, error) <span class="cov5" title="6">{
        // Prepare notification payload
        expiryUnit := models.ExpiryUnitMinutes
        expiryValue := config.OTPExpirationMinutes
        if expiryValue &gt;= 60 </span><span class="cov0" title="0">{
                expiryUnit = models.ExpiryUnitHours
                expiryValue = expiryValue / 60
        }</span>

        <span class="cov5" title="6">variables := map[string]interface{}{
                "otp":          code,
                "user_name":    req.UserName,
                "expiry_value": expiryValue,
                "expiry_unit":  expiryUnit,
                "client_name":  req.ClientID, // In real implementation, get actual client name
        }

        notificationPayload := &amp;models.NotificationPayload{
                ClientID:   req.ClientID,
                Channel:    models.NotificationChannel(channelType),
                TemplateID: "2FA_CODE",
                Recipient:  req.Recipient,
                Variables:  variables,
        }

        // Send notification
        notificationResp, err := s.notificationClient.SendNotification(ctx, notificationPayload)
        if err != nil </span><span class="cov1" title="1">{
                return nil, models.CreateError(models.ErrorCodeServiceUnavailable,
                        fmt.Sprintf("failed to send notification: %v", err))
        }</span>

        <span class="cov4" title="5">return notificationResp, nil</span>
}

// validateTenantOTPConfig validates tenant OTP configuration
func (s *otpService) validateTenantOTPConfig(config *models.TenantOTPConfig) error <span class="cov6" title="10">{
        const (
                MinDigitLength = 4
                MaxDigitLength = 10
        )

        // Validate required fields
        if config.TenantID == "" </span><span class="cov0" title="0">{
                return models.CreateError(models.ErrorCodeMissingFields, "tenant_id is required")
        }</span>

        // Validate digit length - MUST be within acceptable range, never 0
        <span class="cov6" title="10">if config.OTPDigitLength &lt;= 0 </span><span class="cov0" title="0">{
                return models.CreateError(models.ErrorCodeInvalidRequest,
                        fmt.Sprintf("OTP digit length cannot be 0 or negative, got %d", config.OTPDigitLength))
        }</span>

        <span class="cov6" title="10">if config.OTPDigitLength &lt; MinDigitLength || config.OTPDigitLength &gt; MaxDigitLength </span><span class="cov0" title="0">{
                return models.CreateError(models.ErrorCodeInvalidRequest,
                        fmt.Sprintf("OTP digit length must be between %d and %d, got %d",
                                MinDigitLength, MaxDigitLength, config.OTPDigitLength))
        }</span>

        // Validate expiration time
        <span class="cov6" title="10">if config.OTPExpirationMinutes &lt;= 0 </span><span class="cov0" title="0">{
                return models.CreateError(models.ErrorCodeInvalidRequest,
                        fmt.Sprintf("OTP expiration minutes must be positive, got %d", config.OTPExpirationMinutes))
        }</span>

        // Validate max attempts
        <span class="cov6" title="10">if config.MaxOTPAttempts &lt;= 0 </span><span class="cov0" title="0">{
                return models.CreateError(models.ErrorCodeInvalidRequest,
                        fmt.Sprintf("max OTP attempts must be positive, got %d", config.MaxOTPAttempts))
        }</span>

        // Validate at least one delivery method is enabled
        <span class="cov6" title="10">if !config.EnableEmailOTP &amp;&amp; !config.EnableSMSOTP </span><span class="cov0" title="0">{
                return models.CreateError(models.ErrorCodeFeatureDisabled,
                        "at least one OTP delivery method (email or SMS) must be enabled")
        }</span>

        <span class="cov6" title="10">return nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package service

import (
        "auth-service/internal/config"
        "auth-service/internal/models"
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "time"

        "github.com/sony/gobreaker"
)

// SubscriptionClient defines the interface for Subscription Service communication
type SubscriptionClient interface {
        ValidateSubscription(ctx context.Context, req *models.SubscriptionValidationRequest) (*models.SubscriptionValidationResponse, error)
        GetCircuitBreakerState() gobreaker.State
}

// subscriptionClient implements SubscriptionClient
type subscriptionClient struct {
        httpClient     *http.Client
        baseURL        string
        circuitBreaker *gobreaker.CircuitBreaker
        config         config.SubscriptionServiceConfig
}

// NewSubscriptionClient creates a new Subscription Service client
func NewSubscriptionClient(cfg config.SubscriptionServiceConfig) SubscriptionClient <span class="cov5" title="3">{
        circuitBreaker := cfg.CircuitBreaker.CreateCircuitBreaker("subscription-service")

        return &amp;subscriptionClient{
                httpClient: &amp;http.Client{
                        Timeout: cfg.Timeout,
                },
                baseURL:        cfg.BaseURL,
                circuitBreaker: circuitBreaker,
                config:         cfg,
        }
}</span>

// ValidateSubscription validates client subscription and quota for 2FA features
func (c *subscriptionClient) ValidateSubscription(ctx context.Context, req *models.SubscriptionValidationRequest) (*models.SubscriptionValidationResponse, error) <span class="cov0" title="0">{
        // Use circuit breaker to protect against service failures
        result, err := c.circuitBreaker.Execute(func() (interface{}, error) </span><span class="cov0" title="0">{
                return c.validateSubscriptionWithRetry(ctx, req)
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                // Check if it's a circuit breaker error
                if err == gobreaker.ErrOpenState </span><span class="cov0" title="0">{
                        return nil, models.CreateError(models.ErrorCodeServiceUnavailable, "Subscription service circuit breaker is open")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("subscription service error: %w", err)</span>
        }

        <span class="cov0" title="0">response, ok := result.(*models.SubscriptionValidationResponse)
        if !ok </span><span class="cov0" title="0">{
                return nil, models.CreateError(models.ErrorCodeInternalError, "Invalid response type from subscription service")
        }</span>

        <span class="cov0" title="0">return response, nil</span>
}

// validateSubscriptionWithRetry validates subscription with retry logic
func (c *subscriptionClient) validateSubscriptionWithRetry(ctx context.Context, req *models.SubscriptionValidationRequest) (*models.SubscriptionValidationResponse, error) <span class="cov0" title="0">{
        // Convert request to JSON
        jsonData, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal subscription validation request: %w", err)
        }</span>

        // Create HTTP request
        <span class="cov0" title="0">httpReq, err := http.NewRequestWithContext(ctx, "POST", c.baseURL+"/subscriptions/validate", bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create HTTP request: %w", err)
        }</span>

        <span class="cov0" title="0">httpReq.Header.Set("Content-Type", "application/json")
        httpReq.Header.Set("X-Service-Name", "auth-service")
        httpReq.Header.Set("X-Request-ID", getRequestID(ctx))

        // Send request with retry logic
        var lastErr error
        for attempt := 1; attempt &lt;= c.config.MaxRetries; attempt++ </span><span class="cov0" title="0">{
                resp, err := c.httpClient.Do(httpReq)
                if err != nil </span><span class="cov0" title="0">{
                        lastErr = fmt.Errorf("HTTP request failed (attempt %d): %w", attempt, err)

                        // If this is not the last attempt, wait before retrying
                        if attempt &lt; c.config.MaxRetries </span><span class="cov0" title="0">{
                                backoff := time.Duration(attempt) * c.config.RetryDelay
                                select </span>{
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        return nil, ctx.Err()</span>
                                case &lt;-time.After(backoff):<span class="cov0" title="0">
                                        continue</span>
                                }
                        }
                        <span class="cov0" title="0">continue</span>
                }

                // If we got a response, process it
                <span class="cov0" title="0">return c.processResponse(resp)</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("all retry attempts failed: %w", lastErr)</span>
}

// processResponse processes the HTTP response
func (c *subscriptionClient) processResponse(resp *http.Response) (*models.SubscriptionValidationResponse, error) <span class="cov0" title="0">{
        defer resp.Body.Close()

        // Read response body
        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response body: %w", err)
        }</span>

        // Parse response
        <span class="cov0" title="0">var subscriptionResp models.SubscriptionValidationResponse
        if err := json.Unmarshal(body, &amp;subscriptionResp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal subscription response: %w", err)
        }</span>

        // Check HTTP status code and handle errors
        <span class="cov0" title="0">switch resp.StatusCode </span>{
        case http.StatusOK:<span class="cov0" title="0">
                return &amp;subscriptionResp, nil</span>
        case http.StatusBadRequest:<span class="cov0" title="0">
                return nil, models.CreateError(models.ErrorCodeInvalidRequest, subscriptionResp.Error)</span>
        case http.StatusUnauthorized:<span class="cov0" title="0">
                return nil, models.CreateError(models.ErrorCodeAuthentication, subscriptionResp.Error)</span>
        case http.StatusForbidden:<span class="cov0" title="0">
                return nil, models.CreateError(models.ErrorCodeAuthorization, subscriptionResp.Error)</span>
        case http.StatusPaymentRequired:<span class="cov0" title="0">
                return nil, models.CreateError(models.ErrorCodeInvalidSubscription, subscriptionResp.Error)</span>
        case http.StatusTooManyRequests:<span class="cov0" title="0">
                return nil, models.CreateError(models.ErrorCodeRateLimitExceeded, subscriptionResp.Error)</span>
        case http.StatusInternalServerError:<span class="cov0" title="0">
                return nil, models.CreateError(models.ErrorCodeInternalError, subscriptionResp.Error)</span>
        case http.StatusServiceUnavailable:<span class="cov0" title="0">
                return nil, models.CreateError(models.ErrorCodeServiceUnavailable, subscriptionResp.Error)</span>
        default:<span class="cov0" title="0">
                return nil, models.CreateError(models.ErrorCodeServiceUnavailable,
                        fmt.Sprintf("unexpected status code: %d", resp.StatusCode))</span>
        }
}

// GetCircuitBreakerState returns the current circuit breaker state
func (c *subscriptionClient) GetCircuitBreakerState() gobreaker.State <span class="cov0" title="0">{
        return c.circuitBreaker.State()
}</span>

// MockSubscriptionClient for testing
type MockSubscriptionClient struct {
        ValidateSubscriptionFunc func(ctx context.Context, req *models.SubscriptionValidationRequest) (*models.SubscriptionValidationResponse, error)
        CircuitBreakerState      gobreaker.State
}

func (m *MockSubscriptionClient) ValidateSubscription(ctx context.Context, req *models.SubscriptionValidationRequest) (*models.SubscriptionValidationResponse, error) <span class="cov10" title="10">{
        if m.ValidateSubscriptionFunc != nil </span><span class="cov10" title="10">{
                return m.ValidateSubscriptionFunc(ctx, req)
        }</span>

        // Default mock response
        <span class="cov0" title="0">return &amp;models.SubscriptionValidationResponse{
                Valid:          true,
                FeatureEnabled: true,
                QuotaAvailable: true,
                DailyQuota:     1000,
                MonthlyQuota:   10000,
                DailyUsage:     100,
                MonthlyUsage:   1000,
        }, nil</span>
}

func (m *MockSubscriptionClient) GetCircuitBreakerState() gobreaker.State <span class="cov0" title="0">{
        return m.CircuitBreakerState
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package service

import (
        "auth-service/internal/models"
        "context"
        "crypto/rand"
        "encoding/hex"
        "errors"
        "fmt"
        "time"

        "github.com/golang-jwt/jwt/v5"
)

// TenantService defines the interface for tenant operations
type TenantService interface {
        CreateTenant(ctx context.Context, tenant *models.Tenant) error
        GetTenant(ctx context.Context, tenantID string) (*models.Tenant, error)
        GetTenantByClientID(ctx context.Context, clientID string) (*models.Tenant, error)
        UpdateTenant(ctx context.Context, tenant *models.Tenant) error
        DeleteTenant(ctx context.Context, tenantID string) error
        ListTenants(ctx context.Context, limit, offset int) ([]*models.Tenant, error)
        GetTenantStats(ctx context.Context, tenantID string) (*models.TenantStats, error)
        ValidateTenantAccess(ctx context.Context, tenantID string) error
        UpdateTenantStats(ctx context.Context, stats *models.TenantStats) error

        // Tenant Authentication
        AuthenticateTenant(ctx context.Context, req *models.TenantAuthRequest) (*models.TenantAuthResponse, error)
        ValidateTenantToken(ctx context.Context, token string) (*models.TenantToken, error)
        RefreshTenantToken(ctx context.Context, refreshToken string) (*models.TenantAuthResponse, error)
        RevokeTenantToken(ctx context.Context, token string) error
}

// tenantService implements TenantService
type tenantService struct {
        // TODO: Add database repository
        // repo repository.TenantRepository
}

// NewTenantService creates a new tenant service
func NewTenantService() TenantService <span class="cov0" title="0">{
        return &amp;tenantService{}
}</span>

// CreateTenant creates a new tenant (client organization)
func (s *tenantService) CreateTenant(ctx context.Context, tenant *models.Tenant) error <span class="cov0" title="0">{
        // Validate tenant data
        if tenant.Name == "" </span><span class="cov0" title="0">{
                return errors.New("tenant name is required")
        }</span>
        <span class="cov0" title="0">if tenant.Domain == "" </span><span class="cov0" title="0">{
                return errors.New("tenant domain is required")
        }</span>

        // Set default values
        <span class="cov0" title="0">now := time.Now()
        tenant.CreatedAt = now
        tenant.UpdatedAt = now
        tenant.Status = "active"

        // Set default settings based on plan
        s.setDefaultSettings(tenant)

        // TODO: Save to database
        // return s.repo.CreateTenant(ctx, tenant)

        // Mock implementation
        return nil</span>
}

// GetTenant retrieves a tenant by ID
func (s *tenantService) GetTenant(ctx context.Context, tenantID string) (*models.Tenant, error) <span class="cov0" title="0">{
        if tenantID == "" </span><span class="cov0" title="0">{
                return nil, errors.New("tenant ID is required")
        }</span>

        // TODO: Get from database
        // return s.repo.GetTenant(ctx, tenantID)

        // Mock implementation
        <span class="cov0" title="0">return &amp;models.Tenant{
                ID:       tenantID,
                Name:     "Example Client",
                Domain:   "example.com",
                Status:   "active",
                Plan:     "pro",
                MaxUsers: 1000,
                Settings: models.TenantSettings{
                        AllowedOrigins: []string{"https://example.com"},
                        EnableOAuth:    true,
                        EnableMFA:      true,
                        SessionTimeout: 60,
                },
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
        }, nil</span>
}

// UpdateTenant updates an existing tenant
func (s *tenantService) UpdateTenant(ctx context.Context, tenant *models.Tenant) error <span class="cov0" title="0">{
        if tenant.ID == "" </span><span class="cov0" title="0">{
                return errors.New("tenant ID is required")
        }</span>

        <span class="cov0" title="0">tenant.UpdatedAt = time.Now()

        // TODO: Update in database
        // return s.repo.UpdateTenant(ctx, tenant)

        // Mock implementation
        return nil</span>
}

// DeleteTenant deletes a tenant
func (s *tenantService) DeleteTenant(ctx context.Context, tenantID string) error <span class="cov0" title="0">{
        if tenantID == "" </span><span class="cov0" title="0">{
                return errors.New("tenant ID is required")
        }</span>

        // TODO: Delete from database
        // return s.repo.DeleteTenant(ctx, tenantID)

        // Mock implementation
        <span class="cov0" title="0">return nil</span>
}

// ListTenants retrieves a list of tenants
func (s *tenantService) ListTenants(ctx context.Context, limit, offset int) ([]*models.Tenant, error) <span class="cov0" title="0">{
        // TODO: Get from database
        // return s.repo.ListTenants(ctx, limit, offset)

        // Mock implementation
        return []*models.Tenant{
                {
                        ID:     "tenant-1",
                        Name:   "Client A",
                        Domain: "clienta.com",
                        Status: "active",
                        Plan:   "basic",
                },
                {
                        ID:     "tenant-2",
                        Name:   "Client B",
                        Domain: "clientb.com",
                        Status: "active",
                        Plan:   "pro",
                },
        }, nil
}</span>

// GetTenantStats retrieves usage statistics for a tenant
func (s *tenantService) GetTenantStats(ctx context.Context, tenantID string) (*models.TenantStats, error) <span class="cov0" title="0">{
        if tenantID == "" </span><span class="cov0" title="0">{
                return nil, errors.New("tenant ID is required")
        }</span>

        // TODO: Get from database
        // return s.repo.GetTenantStats(ctx, tenantID)

        // Mock implementation
        <span class="cov0" title="0">return &amp;models.TenantStats{
                TenantID:    tenantID,
                TotalUsers:  150,
                ActiveUsers: 120,
                TotalLogins: 1250,
                LastLoginAt: time.Now(),
                StorageUsed: 1024 * 1024 * 50, // 50MB
                APIRequests: 5000,
                UpdatedAt:   time.Now(),
        }, nil</span>
}

// ValidateTenantAccess validates if a tenant can access the service
func (s *tenantService) ValidateTenantAccess(ctx context.Context, tenantID string) error <span class="cov0" title="0">{
        tenant, err := s.GetTenant(ctx, tenantID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("tenant not found: %w", err)
        }</span>

        // Check if tenant is active
        <span class="cov0" title="0">if tenant.Status != "active" </span><span class="cov0" title="0">{
                return fmt.Errorf("tenant is %s", tenant.Status)
        }</span>

        // Check if tenant has expired
        <span class="cov0" title="0">if tenant.ExpiresAt != nil &amp;&amp; time.Now().After(*tenant.ExpiresAt) </span><span class="cov0" title="0">{
                return errors.New("tenant subscription has expired")
        }</span>

        // TODO: Check usage limits
        // stats, err := s.GetTenantStats(ctx, tenantID)
        // if err != nil {
        //     return err
        // }
        // if stats.TotalUsers &gt;= tenant.MaxUsers {
        //     return errors.New("tenant has reached maximum user limit")
        // }

        <span class="cov0" title="0">return nil</span>
}

// UpdateTenantStats updates usage statistics for a tenant
func (s *tenantService) UpdateTenantStats(ctx context.Context, stats *models.TenantStats) error <span class="cov0" title="0">{
        if stats.TenantID == "" </span><span class="cov0" title="0">{
                return errors.New("tenant ID is required")
        }</span>

        <span class="cov0" title="0">stats.UpdatedAt = time.Now()

        // TODO: Update in database
        // return s.repo.UpdateTenantStats(ctx, stats)

        // Mock implementation
        return nil</span>
}

// setDefaultSettings sets default tenant settings based on plan
func (s *tenantService) setDefaultSettings(tenant *models.Tenant) <span class="cov0" title="0">{
        switch tenant.Plan </span>{
        case "basic":<span class="cov0" title="0">
                tenant.MaxUsers = 100
                tenant.Settings = models.TenantSettings{
                        AllowedOrigins:   []string{fmt.Sprintf("https://%s", tenant.Domain)},
                        CustomBranding:   false,
                        EnableOAuth:      false,
                        EnableMFA:        false,
                        SessionTimeout:   30,
                        MaxLoginAttempts: 5,
                        EnableAuditLog:   false,
                        PasswordPolicy: models.PasswordPolicy{
                                MinLength:      8,
                                RequireUpper:   true,
                                RequireLower:   true,
                                RequireNumbers: true,
                                RequireSpecial: false,
                                MaxAge:         90,
                        },
                }</span>
        case "pro":<span class="cov0" title="0">
                tenant.MaxUsers = 1000
                tenant.Settings = models.TenantSettings{
                        AllowedOrigins:   []string{fmt.Sprintf("https://%s", tenant.Domain)},
                        CustomBranding:   true,
                        EnableOAuth:      true,
                        EnableMFA:        true,
                        SessionTimeout:   60,
                        MaxLoginAttempts: 10,
                        EnableAuditLog:   true,
                        PasswordPolicy: models.PasswordPolicy{
                                MinLength:      10,
                                RequireUpper:   true,
                                RequireLower:   true,
                                RequireNumbers: true,
                                RequireSpecial: true,
                                MaxAge:         60,
                        },
                }</span>
        case "enterprise":<span class="cov0" title="0">
                tenant.MaxUsers = 10000
                tenant.Settings = models.TenantSettings{
                        AllowedOrigins:   []string{fmt.Sprintf("https://%s", tenant.Domain)},
                        CustomBranding:   true,
                        EnableOAuth:      true,
                        EnableMFA:        true,
                        SessionTimeout:   120,
                        MaxLoginAttempts: 15,
                        EnableAuditLog:   true,
                        PasswordPolicy: models.PasswordPolicy{
                                MinLength:      12,
                                RequireUpper:   true,
                                RequireLower:   true,
                                RequireNumbers: true,
                                RequireSpecial: true,
                                MaxAge:         30,
                        },
                }</span>
        default:<span class="cov0" title="0">
                // Default to basic plan
                tenant.Plan = "basic"
                s.setDefaultSettings(tenant)</span>
        }
}

// AuthenticateTenant authenticates a tenant using client credentials
func (s *tenantService) AuthenticateTenant(ctx context.Context, req *models.TenantAuthRequest) (*models.TenantAuthResponse, error) <span class="cov0" title="0">{
        if req.GrantType != "client_credentials" </span><span class="cov0" title="0">{
                return nil, errors.New("unsupported grant type")
        }</span>

        // Find tenant by client ID
        <span class="cov0" title="0">tenant, err := s.GetTenantByClientID(ctx, req.ClientID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid client credentials: %w", err)
        }</span>

        // Validate client secret
        <span class="cov0" title="0">if tenant.ClientSecret != req.ClientSecret </span><span class="cov0" title="0">{
                return nil, errors.New("invalid client credentials")
        }</span>

        // Validate tenant access
        <span class="cov0" title="0">if err := s.ValidateTenantAccess(ctx, tenant.ID); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("tenant access denied: %w", err)
        }</span>

        // Generate tenant token
        <span class="cov0" title="0">accessToken, err := s.generateTenantToken(tenant)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate token: %w", err)
        }</span>

        // Generate refresh token
        <span class="cov0" title="0">refreshToken, err := s.generateRefreshToken(tenant.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate refresh token: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;models.TenantAuthResponse{
                AccessToken:  accessToken,
                TokenType:    "Bearer",
                ExpiresIn:    3600, // 1 hour
                RefreshToken: refreshToken,
                Scope:        "tenant:read tenant:write user:read user:write",
                TenantID:     tenant.ID,
                TenantName:   tenant.Name,
                Plan:         tenant.Plan,
        }, nil</span>
}

// ValidateTenantToken validates a tenant token
func (s *tenantService) ValidateTenantToken(ctx context.Context, tokenString string) (*models.TenantToken, error) <span class="cov0" title="0">{
        // Parse and validate JWT token
        token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                // Validate signing method
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov0" title="0">return []byte("tenant-secret-key"), nil</span> // TODO: Use proper secret from config
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid token: %w", err)
        }</span>

        <span class="cov0" title="0">if !token.Valid </span><span class="cov0" title="0">{
                return nil, errors.New("invalid token")
        }</span>

        // Extract claims
        <span class="cov0" title="0">claims, ok := token.Claims.(jwt.MapClaims)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("invalid token claims")
        }</span>

        // Validate token type
        <span class="cov0" title="0">if claims["type"] != "tenant" </span><span class="cov0" title="0">{
                return nil, errors.New("invalid token type")
        }</span>

        // Check expiration
        <span class="cov0" title="0">if exp, ok := claims["exp"].(float64); ok </span><span class="cov0" title="0">{
                if time.Now().Unix() &gt; int64(exp) </span><span class="cov0" title="0">{
                        return nil, errors.New("token expired")
                }</span>
        }

        <span class="cov0" title="0">tenantID, ok := claims["tenant_id"].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("invalid tenant ID in token")
        }</span>

        // Validate tenant still exists and is active
        <span class="cov0" title="0">if err := s.ValidateTenantAccess(ctx, tenantID); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("tenant access denied: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;models.TenantToken{
                TenantID:  tenantID,
                Token:     tokenString,
                TokenType: "Bearer",
                ExpiresAt: time.Unix(int64(claims["exp"].(float64)), 0),
                Scope:     claims["scope"].(string),
                CreatedAt: time.Unix(int64(claims["iat"].(float64)), 0),
        }, nil</span>
}

// RefreshTenantToken refreshes a tenant token
func (s *tenantService) RefreshTenantToken(ctx context.Context, refreshToken string) (*models.TenantAuthResponse, error) <span class="cov0" title="0">{
        // TODO: Implement refresh token validation
        // For now, we'll generate a new token

        // Extract tenant ID from refresh token (in real implementation, validate against stored refresh tokens)
        // This is a simplified implementation
        tenantID := "tenant-1234567890" // TODO: Extract from refresh token

        tenant, err := s.GetTenant(ctx, tenantID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("tenant not found: %w", err)
        }</span>

        // Validate tenant access
        <span class="cov0" title="0">if err := s.ValidateTenantAccess(ctx, tenant.ID); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("tenant access denied: %w", err)
        }</span>

        // Generate new access token
        <span class="cov0" title="0">accessToken, err := s.generateTenantToken(tenant)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate token: %w", err)
        }</span>

        // Generate new refresh token
        <span class="cov0" title="0">newRefreshToken, err := s.generateRefreshToken(tenant.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate refresh token: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;models.TenantAuthResponse{
                AccessToken:  accessToken,
                TokenType:    "Bearer",
                ExpiresIn:    3600, // 1 hour
                RefreshToken: newRefreshToken,
                Scope:        "tenant:read tenant:write user:read user:write",
                TenantID:     tenant.ID,
                TenantName:   tenant.Name,
                Plan:         tenant.Plan,
        }, nil</span>
}

// RevokeTenantToken revokes a tenant token
func (s *tenantService) RevokeTenantToken(ctx context.Context, token string) error <span class="cov0" title="0">{
        // TODO: Implement token revocation (add to blacklist)
        // For now, just validate the token
        _, err := s.ValidateTenantToken(ctx, token)
        return err
}</span>

// GetTenantByClientID retrieves a tenant by client ID
func (s *tenantService) GetTenantByClientID(ctx context.Context, clientID string) (*models.Tenant, error) <span class="cov0" title="0">{
        if clientID == "" </span><span class="cov0" title="0">{
                return nil, errors.New("client ID is required")
        }</span>

        // TODO: Get from database
        // return s.repo.GetTenantByClientID(ctx, clientID)

        // Mock implementation
        <span class="cov0" title="0">if clientID == "client-1234567890" </span><span class="cov0" title="0">{
                return &amp;models.Tenant{
                        ID:           "tenant-1234567890",
                        Name:         "Acme Corp",
                        Domain:       "acme.com",
                        Status:       "active",
                        Plan:         "pro",
                        MaxUsers:     1000,
                        ClientID:     "client-1234567890",
                        ClientSecret: "secret-1234567890",
                        Settings: models.TenantSettings{
                                AllowedOrigins: []string{"https://acme.com"},
                                EnableOAuth:    true,
                                EnableMFA:      true,
                                SessionTimeout: 60,
                        },
                        CreatedAt: time.Now(),
                        UpdatedAt: time.Now(),
                }, nil
        }</span>

        <span class="cov0" title="0">return nil, errors.New("tenant not found")</span>
}

// generateTenantToken generates a JWT token for tenant authentication
func (s *tenantService) generateTenantToken(tenant *models.Tenant) (string, error) <span class="cov0" title="0">{
        claims := jwt.MapClaims{
                "tenant_id": tenant.ID,
                "type":      "tenant",
                "scope":     "tenant:read tenant:write user:read user:write",
                "iat":       time.Now().Unix(),
                "exp":       time.Now().Add(time.Hour).Unix(),
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString([]byte("tenant-secret-key")) // TODO: Use proper secret from config
}</span>

// generateRefreshToken generates a refresh token
func (s *tenantService) generateRefreshToken(tenantID string) (string, error) <span class="cov0" title="0">{
        // Generate a random refresh token
        bytes := make([]byte, 32)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return hex.EncodeToString(bytes), nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package tracing

import (
        "context"
        "crypto/rand"
        "fmt"
        "net/http"
        "strings"
        "time"

        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/propagation"
        "go.opentelemetry.io/otel/trace"
)

const (
        // Standard tracing headers
        TraceIDHeader      = "X-Trace-ID"
        SpanIDHeader       = "X-Span-ID"
        ParentSpanIDHeader = "X-Parent-Span-ID"

        // Cloud-native tracing headers (AWS X-Ray, Google Cloud Trace, etc.)
        XRayTraceIDHeader = "X-Amzn-Trace-Id"
        CloudTraceHeader  = "X-Cloud-Trace-Context"

        // Response header for trace ID
        ResponseTraceIDHeader = "X-Req-ID"
)

// TracingContext holds tracing information
type TracingContext struct {
        TraceID      string
        SpanID       string
        ParentSpanID string
        IsSampled    bool
}

// ExtractTracingFromRequest extracts tracing information from HTTP request headers
func ExtractTracingFromRequest(r *http.Request) *TracingContext <span class="cov8" title="7">{
        // First, try to extract from OpenTelemetry context
        ctx := r.Context()
        span := trace.SpanFromContext(ctx)

        traceID := ""
        spanID := ""
        parentSpanID := ""
        isSampled := true // Default to true for sampling

        if span.SpanContext().IsValid() </span><span class="cov0" title="0">{
                traceID = span.SpanContext().TraceID().String()
                spanID = span.SpanContext().SpanID().String()
                isSampled = span.SpanContext().IsSampled()
        }</span>

        // If no OpenTelemetry context, try custom headers
        <span class="cov8" title="7">if traceID == "" </span><span class="cov8" title="7">{
                traceID = extractTraceIDFromHeaders(r)
        }</span>

        <span class="cov8" title="7">if spanID == "" </span><span class="cov8" title="7">{
                spanID = extractSpanIDFromHeaders(r)
        }</span>
        <span class="cov8" title="7">if spanID == "" </span><span class="cov6" title="4">{
                spanID = generateSpanID()
        }</span>

        <span class="cov8" title="7">parentSpanID = r.Header.Get(ParentSpanIDHeader)

        // If still no trace ID, generate one
        if traceID == "" </span><span class="cov1" title="1">{
                traceID = generateTraceID()
        }</span>

        // If no span ID, generate one
        <span class="cov8" title="7">if spanID == "" </span><span class="cov0" title="0">{
                spanID = generateSpanID()
        }</span>

        <span class="cov8" title="7">return &amp;TracingContext{
                TraceID:      traceID,
                SpanID:       spanID,
                ParentSpanID: parentSpanID,
                IsSampled:    isSampled,
        }</span>
}

// extractTraceIDFromHeaders extracts trace ID from various header formats
func extractTraceIDFromHeaders(r *http.Request) string <span class="cov8" title="7">{
        // Try standard trace ID header
        if traceID := r.Header.Get(TraceIDHeader); traceID != "" </span><span class="cov3" title="2">{
                return traceID
        }</span>

        // Try AWS X-Ray format
        <span class="cov7" title="5">if xrayTraceID := r.Header.Get(XRayTraceIDHeader); xrayTraceID != "" </span><span class="cov1" title="1">{
                return extractXRayTraceID(xrayTraceID)
        }</span>

        // Try Google Cloud Trace format
        <span class="cov6" title="4">if cloudTrace := r.Header.Get(CloudTraceHeader); cloudTrace != "" </span><span class="cov1" title="1">{
                return extractCloudTraceID(cloudTrace)
        }</span>

        // Try request ID as fallback
        <span class="cov5" title="3">if reqID := r.Header.Get("X-Request-ID"); reqID != "" </span><span class="cov3" title="2">{
                return reqID
        }</span>

        <span class="cov1" title="1">return ""</span>
}

// extractSpanIDFromHeaders extracts span ID from headers
func extractSpanIDFromHeaders(r *http.Request) string <span class="cov8" title="7">{
        if spanID := r.Header.Get(SpanIDHeader); spanID != "" </span><span class="cov3" title="2">{
                return spanID
        }</span>

        // Try to extract from AWS X-Ray
        <span class="cov7" title="5">if xrayTraceID := r.Header.Get(XRayTraceIDHeader); xrayTraceID != "" </span><span class="cov1" title="1">{
                return extractXRaySpanID(xrayTraceID)
        }</span>

        <span class="cov6" title="4">return ""</span>
}

// extractXRayTraceID extracts trace ID from AWS X-Ray format
// Format: Root=1-5759e988-bd862e3fe1be46a994272793;Parent=53995c3f42cd8ad8;Sampled=1
func extractXRayTraceID(xrayHeader string) string <span class="cov7" title="5">{
        parts := strings.Split(xrayHeader, ";")
        for _, part := range parts </span><span class="cov7" title="5">{
                if strings.HasPrefix(part, "Root=") </span><span class="cov5" title="3">{
                        root := strings.TrimPrefix(part, "Root=")
                        // X-Ray trace ID format: 1-5759e988-bd862e3fe1be46a994272793
                        // We'll use the full root as trace ID
                        return root
                }</span>
        }
        <span class="cov3" title="2">return ""</span>
}

// extractXRaySpanID extracts span ID from AWS X-Ray format
func extractXRaySpanID(xrayHeader string) string <span class="cov6" title="4">{
        parts := strings.Split(xrayHeader, ";")
        for _, part := range parts </span><span class="cov8" title="7">{
                if strings.HasPrefix(part, "Parent=") </span><span class="cov3" title="2">{
                        return strings.TrimPrefix(part, "Parent=")
                }</span>
        }
        <span class="cov3" title="2">return ""</span>
}

// extractCloudTraceID extracts trace ID from Google Cloud Trace format
// Format: 105445aa7843bc8bf206b12000100000/0;o=1
func extractCloudTraceID(cloudTraceHeader string) string <span class="cov7" title="5">{
        parts := strings.Split(cloudTraceHeader, "/")
        if len(parts) &gt; 0 </span><span class="cov7" title="5">{
                return parts[0]
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// generateTraceID generates a new trace ID
func generateTraceID() string <span class="cov6" title="4">{
        // Generate a 32-character hex string (16 bytes)
        // This follows the W3C trace context specification
        return fmt.Sprintf("%032x", generateRandomBytes(16))
}</span>

// generateSpanID generates a new span ID
func generateSpanID() string <span class="cov8" title="7">{
        // Generate a 16-character hex string (8 bytes)
        return fmt.Sprintf("%016x", generateRandomBytes(8))
}</span>

// generateRandomBytes generates random bytes for trace/span IDs
func generateRandomBytes(n int) []byte <span class="cov10" title="11">{
        bytes := make([]byte, n)
        _, err := rand.Read(bytes)
        if err != nil </span><span class="cov0" title="0">{
                // Fallback to timestamp-based generation if crypto/rand fails
                timestamp := time.Now().UnixNano()
                for i := range bytes </span><span class="cov0" title="0">{
                        bytes[i] = byte((timestamp &gt;&gt; (i * 8)) &amp; 0xFF)
                }</span>
        }
        <span class="cov10" title="11">return bytes</span>
}

// AddTracingHeaders adds tracing headers to HTTP response
func AddTracingHeaders(w http.ResponseWriter, traceCtx *TracingContext) <span class="cov1" title="1">{
        w.Header().Set(ResponseTraceIDHeader, traceCtx.TraceID)
        w.Header().Set(TraceIDHeader, traceCtx.TraceID)
        w.Header().Set(SpanIDHeader, traceCtx.SpanID)
}</span>

// CreateSpan creates a new span with the given name and context
func CreateSpan(ctx context.Context, name string, traceCtx *TracingContext) (context.Context, trace.Span) <span class="cov1" title="1">{
        tracer := otel.Tracer("auth-service")

        // Create span context from trace ID and span ID
        spanCtx := createSpanContext(traceCtx)

        // Create span with the extracted context
        return tracer.Start(spanCtx, name)
}</span>

// createSpanContext creates a span context from trace and span IDs
func createSpanContext(traceCtx *TracingContext) context.Context <span class="cov1" title="1">{
        // Create a context with the trace ID as a value
        ctx := context.WithValue(context.Background(), "trace_id", traceCtx.TraceID)
        ctx = context.WithValue(ctx, "span_id", traceCtx.SpanID)

        return ctx
}</span>

// PropagateTracing propagates tracing context to outgoing requests
func PropagateTracing(ctx context.Context, req *http.Request) <span class="cov1" title="1">{
        // Use OpenTelemetry propagator to inject tracing context
        propagator := otel.GetTextMapPropagator()
        propagator.Inject(ctx, propagation.HeaderCarrier(req.Header))
}</span>

// GetTracingContextFromContext extracts tracing context from Go context
func GetTracingContextFromContext(ctx context.Context) *TracingContext <span class="cov3" title="2">{
        traceID, _ := ctx.Value("trace_id").(string)
        spanID, _ := ctx.Value("span_id").(string)

        if traceID == "" </span><span class="cov1" title="1">{
                traceID = generateTraceID()
        }</span>
        <span class="cov3" title="2">if spanID == "" </span><span class="cov1" title="1">{
                spanID = generateSpanID()
        }</span>

        <span class="cov3" title="2">return &amp;TracingContext{
                TraceID:   traceID,
                SpanID:    spanID,
                IsSampled: true,
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
